// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LocalCifsUsersAndGroupsImport local cifs users and groups import
//
// swagger:model local_cifs_users_and_groups_import
type LocalCifsUsersAndGroupsImport struct {

	// links
	Links *LocalCifsUsersAndGroupsImportLinks `json:"_links,omitempty"`

	// Password to decrypt the compressed file.
	// Max Length: 128
	DecryptionPassword string `json:"decryption_password,omitempty"`

	// detailed status
	DetailedStatus *LocalCifsUsersAndGroupsImportDetailedStatus `json:"detailed_status,omitempty"`

	// Number of elements ignored.
	ElementsIgnored int64 `json:"elements_ignored,omitempty"`

	// Number of elements successfully imported.
	ElementsImported int64 `json:"elements_imported,omitempty"`

	// import uri
	ImportURI *LocalCifsUsersAndGroupsImportImportURI `json:"import_uri,omitempty"`

	// Operation status.
	// Enum: [failed success success_with_warnings in_progress unknown]
	State string `json:"state,omitempty"`

	// status uri
	StatusURI *LocalCifsUsersAndGroupsImportStatusURI `json:"status_uri,omitempty"`

	// svm
	Svm *LocalCifsUsersAndGroupsImportSvm `json:"svm,omitempty"`
}

// Validate validates this local cifs users and groups import
func (m *LocalCifsUsersAndGroupsImport) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDecryptionPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDetailedStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImport) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) validateDecryptionPassword(formats strfmt.Registry) error {
	if swag.IsZero(m.DecryptionPassword) { // not required
		return nil
	}

	if err := validate.MaxLength("decryption_password", "body", m.DecryptionPassword, 128); err != nil {
		return err
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) validateDetailedStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.DetailedStatus) { // not required
		return nil
	}

	if m.DetailedStatus != nil {
		if err := m.DetailedStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("detailed_status")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) validateImportURI(formats strfmt.Registry) error {
	if swag.IsZero(m.ImportURI) { // not required
		return nil
	}

	if m.ImportURI != nil {
		if err := m.ImportURI.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("import_uri")
			}
			return err
		}
	}

	return nil
}

var localCifsUsersAndGroupsImportTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["failed","success","success_with_warnings","in_progress","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		localCifsUsersAndGroupsImportTypeStatePropEnum = append(localCifsUsersAndGroupsImportTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// local_cifs_users_and_groups_import
	// LocalCifsUsersAndGroupsImport
	// state
	// State
	// failed
	// END DEBUGGING
	// LocalCifsUsersAndGroupsImportStateFailed captures enum value "failed"
	LocalCifsUsersAndGroupsImportStateFailed string = "failed"

	// BEGIN DEBUGGING
	// local_cifs_users_and_groups_import
	// LocalCifsUsersAndGroupsImport
	// state
	// State
	// success
	// END DEBUGGING
	// LocalCifsUsersAndGroupsImportStateSuccess captures enum value "success"
	LocalCifsUsersAndGroupsImportStateSuccess string = "success"

	// BEGIN DEBUGGING
	// local_cifs_users_and_groups_import
	// LocalCifsUsersAndGroupsImport
	// state
	// State
	// success_with_warnings
	// END DEBUGGING
	// LocalCifsUsersAndGroupsImportStateSuccessWithWarnings captures enum value "success_with_warnings"
	LocalCifsUsersAndGroupsImportStateSuccessWithWarnings string = "success_with_warnings"

	// BEGIN DEBUGGING
	// local_cifs_users_and_groups_import
	// LocalCifsUsersAndGroupsImport
	// state
	// State
	// in_progress
	// END DEBUGGING
	// LocalCifsUsersAndGroupsImportStateInProgress captures enum value "in_progress"
	LocalCifsUsersAndGroupsImportStateInProgress string = "in_progress"

	// BEGIN DEBUGGING
	// local_cifs_users_and_groups_import
	// LocalCifsUsersAndGroupsImport
	// state
	// State
	// unknown
	// END DEBUGGING
	// LocalCifsUsersAndGroupsImportStateUnknown captures enum value "unknown"
	LocalCifsUsersAndGroupsImportStateUnknown string = "unknown"
)

// prop value enum
func (m *LocalCifsUsersAndGroupsImport) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, localCifsUsersAndGroupsImportTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImport) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) validateStatusURI(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusURI) { // not required
		return nil
	}

	if m.StatusURI != nil {
		if err := m.StatusURI.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status_uri")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this local cifs users and groups import based on the context it is used
func (m *LocalCifsUsersAndGroupsImport) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDetailedStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImportURI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatusURI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImport) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) contextValidateDetailedStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.DetailedStatus != nil {
		if err := m.DetailedStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("detailed_status")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) contextValidateImportURI(ctx context.Context, formats strfmt.Registry) error {

	if m.ImportURI != nil {
		if err := m.ImportURI.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("import_uri")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) contextValidateStatusURI(ctx context.Context, formats strfmt.Registry) error {

	if m.StatusURI != nil {
		if err := m.StatusURI.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status_uri")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImport) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImport) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImport) UnmarshalBinary(b []byte) error {
	var res LocalCifsUsersAndGroupsImport
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LocalCifsUsersAndGroupsImportDetailedStatus local cifs users and groups import detailed status
//
// swagger:model LocalCifsUsersAndGroupsImportDetailedStatus
type LocalCifsUsersAndGroupsImportDetailedStatus struct {

	// Code corresponding to the import status failure.
	//
	// Example: 6684732
	Code string `json:"code,omitempty"`

	// Detailed description of the import status.
	//
	Message string `json:"message,omitempty"`
}

// Validate validates this local cifs users and groups import detailed status
func (m *LocalCifsUsersAndGroupsImportDetailedStatus) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this local cifs users and groups import detailed status based on context it is used
func (m *LocalCifsUsersAndGroupsImportDetailedStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportDetailedStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportDetailedStatus) UnmarshalBinary(b []byte) error {
	var res LocalCifsUsersAndGroupsImportDetailedStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LocalCifsUsersAndGroupsImportImportURI local cifs users and groups import import URI
//
// swagger:model LocalCifsUsersAndGroupsImportImportURI
type LocalCifsUsersAndGroupsImportImportURI struct {

	// Password of the specified URI.
	// Max Length: 128
	Password string `json:"password,omitempty"`

	// URI from which to load the input file containing the CIFS local users and groups. The file must be encrypted using the 7zip utility. URI can be FTP or HTTP.
	// Example: http://web.sample.com/web1/file1.7z
	Path string `json:"path,omitempty"`

	// Username of the specified URI.
	// Example: user1
	// Max Length: 128
	Username string `json:"username,omitempty"`
}

// Validate validates this local cifs users and groups import import URI
func (m *LocalCifsUsersAndGroupsImportImportURI) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsername(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportImportURI) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.MaxLength("import_uri"+"."+"password", "body", m.Password, 128); err != nil {
		return err
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImportImportURI) validateUsername(formats strfmt.Registry) error {
	if swag.IsZero(m.Username) { // not required
		return nil
	}

	if err := validate.MaxLength("import_uri"+"."+"username", "body", m.Username, 128); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this local cifs users and groups import import URI based on context it is used
func (m *LocalCifsUsersAndGroupsImportImportURI) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportImportURI) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportImportURI) UnmarshalBinary(b []byte) error {
	var res LocalCifsUsersAndGroupsImportImportURI
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LocalCifsUsersAndGroupsImportLinks local cifs users and groups import links
//
// swagger:model LocalCifsUsersAndGroupsImportLinks
type LocalCifsUsersAndGroupsImportLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this local cifs users and groups import links
func (m *LocalCifsUsersAndGroupsImportLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this local cifs users and groups import links based on the context it is used
func (m *LocalCifsUsersAndGroupsImportLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportLinks) UnmarshalBinary(b []byte) error {
	var res LocalCifsUsersAndGroupsImportLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LocalCifsUsersAndGroupsImportStatusURI local cifs users and groups import status URI
//
// swagger:model LocalCifsUsersAndGroupsImportStatusURI
type LocalCifsUsersAndGroupsImportStatusURI struct {

	// Password of the specified URI.
	// Max Length: 128
	Password string `json:"password,omitempty"`

	// URI from which to load the input file containing the CIFS local users and groups. The file must be encrypted using the 7zip utility. URI can be FTP or HTTP.
	// Example: http://web.sample.com/web1/file1.7z
	Path string `json:"path,omitempty"`

	// Username of the specified URI.
	// Example: user1
	// Max Length: 128
	Username string `json:"username,omitempty"`
}

// Validate validates this local cifs users and groups import status URI
func (m *LocalCifsUsersAndGroupsImportStatusURI) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsername(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportStatusURI) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.MaxLength("status_uri"+"."+"password", "body", m.Password, 128); err != nil {
		return err
	}

	return nil
}

func (m *LocalCifsUsersAndGroupsImportStatusURI) validateUsername(formats strfmt.Registry) error {
	if swag.IsZero(m.Username) { // not required
		return nil
	}

	if err := validate.MaxLength("status_uri"+"."+"username", "body", m.Username, 128); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this local cifs users and groups import status URI based on context it is used
func (m *LocalCifsUsersAndGroupsImportStatusURI) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportStatusURI) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportStatusURI) UnmarshalBinary(b []byte) error {
	var res LocalCifsUsersAndGroupsImportStatusURI
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LocalCifsUsersAndGroupsImportSvm local cifs users and groups import svm
//
// swagger:model LocalCifsUsersAndGroupsImportSvm
type LocalCifsUsersAndGroupsImportSvm struct {

	// links
	Links *LocalCifsUsersAndGroupsImportSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this local cifs users and groups import svm
func (m *LocalCifsUsersAndGroupsImportSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this local cifs users and groups import svm based on the context it is used
func (m *LocalCifsUsersAndGroupsImportSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportSvm) UnmarshalBinary(b []byte) error {
	var res LocalCifsUsersAndGroupsImportSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LocalCifsUsersAndGroupsImportSvmLinks local cifs users and groups import svm links
//
// swagger:model LocalCifsUsersAndGroupsImportSvmLinks
type LocalCifsUsersAndGroupsImportSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this local cifs users and groups import svm links
func (m *LocalCifsUsersAndGroupsImportSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this local cifs users and groups import svm links based on the context it is used
func (m *LocalCifsUsersAndGroupsImportSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCifsUsersAndGroupsImportSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCifsUsersAndGroupsImportSvmLinks) UnmarshalBinary(b []byte) error {
	var res LocalCifsUsersAndGroupsImportSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

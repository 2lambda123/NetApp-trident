// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Disk disk
//
// swagger:model disk
type Disk struct {

	// List of aggregates sharing this disk
	Aggregates []*DiskAggregatesItems0 `json:"aggregates,omitempty"`

	// Disk shelf bay
	// Example: 1
	Bay int64 `json:"bay,omitempty"`

	// Disk class
	// Example: solid_state
	// Enum: [unknown capacity performance archive solid_state array virtual]
	Class string `json:"class,omitempty"`

	// Type of overlying disk container
	// Example: spare
	// Enum: [aggregate broken foreign labelmaint maintenance shared spare unassigned unknown unsupported remote mediator]
	ContainerType string `json:"container_type,omitempty"`

	// dr node
	DrNode *DiskDrNode `json:"dr_node,omitempty"`

	// drawer
	Drawer *DiskDrawer `json:"drawer,omitempty"`

	// Encryption operation to apply to the drives. Possible values are:
	// - rekey_data_default
	// - rekey_data_auto_id
	//
	EncryptionOperation string `json:"encryption_operation,omitempty"`

	// fips certified
	FipsCertified bool `json:"fips_certified,omitempty"`

	// firmware version
	// Example: NA51
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// home node
	HomeNode *DiskHomeNode `json:"home_node,omitempty"`

	// key id
	KeyID *DiskKeyID `json:"key_id,omitempty"`

	// model
	// Example: X421_HCOBE450A10
	Model string `json:"model,omitempty"`

	// Cluster-wide disk name
	// Example: 1.0.1
	Name string `json:"name,omitempty"`

	// node
	Node *DiskNode `json:"node,omitempty"`

	// Pool to which disk is assigned
	// Example: pool0
	// Enum: [pool0 pool1 failed none]
	Pool string `json:"pool,omitempty"`

	// Mode of drive data protection and FIPS compliance. Possible values are:
	// - _open_ - Disk is unprotected
	// - _data_ - Data protection only without FIPS compliance
	// - _part_ - Partial protection with FIPS compliance only
	// - _full_ - Full data and FIPS compliance protection
	//
	// Enum: [open data part full]
	ProtectionMode string `json:"protection_mode,omitempty"`

	// Percentage of rated life used
	// Example: 10
	RatedLifeUsedPercent int64 `json:"rated_life_used_percent,omitempty"`

	// Revolutions per minute
	// Example: 15000
	Rpm int64 `json:"rpm,omitempty"`

	// self encrypting
	SelfEncrypting bool `json:"self_encrypting,omitempty"`

	// serial number
	// Example: KHG2VX8R
	SerialNumber string `json:"serial_number,omitempty"`

	// shelf
	Shelf *ShelfReference `json:"shelf,omitempty"`

	// State
	// Example: present
	// Enum: [broken copy maintenance partner pending present reconstructing removed spare unfail zeroing]
	State string `json:"state,omitempty"`

	// Disk interface type
	// Example: ssd
	// Enum: [ata bsas fcal fsas lun sas msata ssd vmdisk unknown ssd_nvm]
	Type string `json:"type,omitempty"`

	// The unique identifier for a disk
	// Example: 002538E5:71B00B2F:00000000:00000000:00000000:00000000:00000000:00000000:00000000:00000000
	UID string `json:"uid,omitempty"`

	// usable size
	// Example: 959934889984
	UsableSize int64 `json:"usable_size,omitempty"`

	// vendor
	// Example: NETAPP
	Vendor string `json:"vendor,omitempty"`
}

// Validate validates this disk
func (m *Disk) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContainerType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrawer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePool(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Disk) validateAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregates) { // not required
		return nil
	}

	for i := 0; i < len(m.Aggregates); i++ {
		if swag.IsZero(m.Aggregates[i]) { // not required
			continue
		}

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var diskTypeClassPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","capacity","performance","archive","solid_state","array","virtual"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeClassPropEnum = append(diskTypeClassPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// unknown
	// END RIPPY DEBUGGING
	// DiskClassUnknown captures enum value "unknown"
	DiskClassUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// capacity
	// END RIPPY DEBUGGING
	// DiskClassCapacity captures enum value "capacity"
	DiskClassCapacity string = "capacity"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// performance
	// END RIPPY DEBUGGING
	// DiskClassPerformance captures enum value "performance"
	DiskClassPerformance string = "performance"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// archive
	// END RIPPY DEBUGGING
	// DiskClassArchive captures enum value "archive"
	DiskClassArchive string = "archive"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// solid_state
	// END RIPPY DEBUGGING
	// DiskClassSolidState captures enum value "solid_state"
	DiskClassSolidState string = "solid_state"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// array
	// END RIPPY DEBUGGING
	// DiskClassArray captures enum value "array"
	DiskClassArray string = "array"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// virtual
	// END RIPPY DEBUGGING
	// DiskClassVirtual captures enum value "virtual"
	DiskClassVirtual string = "virtual"
)

// prop value enum
func (m *Disk) validateClassEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeClassPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(m.Class) { // not required
		return nil
	}

	// value enum
	if err := m.validateClassEnum("class", "body", m.Class); err != nil {
		return err
	}

	return nil
}

var diskTypeContainerTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aggregate","broken","foreign","labelmaint","maintenance","shared","spare","unassigned","unknown","unsupported","remote","mediator"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeContainerTypePropEnum = append(diskTypeContainerTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// aggregate
	// END RIPPY DEBUGGING
	// DiskContainerTypeAggregate captures enum value "aggregate"
	DiskContainerTypeAggregate string = "aggregate"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// broken
	// END RIPPY DEBUGGING
	// DiskContainerTypeBroken captures enum value "broken"
	DiskContainerTypeBroken string = "broken"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// foreign
	// END RIPPY DEBUGGING
	// DiskContainerTypeForeign captures enum value "foreign"
	DiskContainerTypeForeign string = "foreign"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// labelmaint
	// END RIPPY DEBUGGING
	// DiskContainerTypeLabelmaint captures enum value "labelmaint"
	DiskContainerTypeLabelmaint string = "labelmaint"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// maintenance
	// END RIPPY DEBUGGING
	// DiskContainerTypeMaintenance captures enum value "maintenance"
	DiskContainerTypeMaintenance string = "maintenance"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// shared
	// END RIPPY DEBUGGING
	// DiskContainerTypeShared captures enum value "shared"
	DiskContainerTypeShared string = "shared"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// spare
	// END RIPPY DEBUGGING
	// DiskContainerTypeSpare captures enum value "spare"
	DiskContainerTypeSpare string = "spare"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// unassigned
	// END RIPPY DEBUGGING
	// DiskContainerTypeUnassigned captures enum value "unassigned"
	DiskContainerTypeUnassigned string = "unassigned"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// unknown
	// END RIPPY DEBUGGING
	// DiskContainerTypeUnknown captures enum value "unknown"
	DiskContainerTypeUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// unsupported
	// END RIPPY DEBUGGING
	// DiskContainerTypeUnsupported captures enum value "unsupported"
	DiskContainerTypeUnsupported string = "unsupported"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// remote
	// END RIPPY DEBUGGING
	// DiskContainerTypeRemote captures enum value "remote"
	DiskContainerTypeRemote string = "remote"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// mediator
	// END RIPPY DEBUGGING
	// DiskContainerTypeMediator captures enum value "mediator"
	DiskContainerTypeMediator string = "mediator"
)

// prop value enum
func (m *Disk) validateContainerTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeContainerTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateContainerType(formats strfmt.Registry) error {
	if swag.IsZero(m.ContainerType) { // not required
		return nil
	}

	// value enum
	if err := m.validateContainerTypeEnum("container_type", "body", m.ContainerType); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateDrNode(formats strfmt.Registry) error {
	if swag.IsZero(m.DrNode) { // not required
		return nil
	}

	if m.DrNode != nil {
		if err := m.DrNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dr_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateDrawer(formats strfmt.Registry) error {
	if swag.IsZero(m.Drawer) { // not required
		return nil
	}

	if m.Drawer != nil {
		if err := m.Drawer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drawer")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateHomeNode(formats strfmt.Registry) error {
	if swag.IsZero(m.HomeNode) { // not required
		return nil
	}

	if m.HomeNode != nil {
		if err := m.HomeNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateKeyID(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyID) { // not required
		return nil
	}

	if m.KeyID != nil {
		if err := m.KeyID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("key_id")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

var diskTypePoolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pool0","pool1","failed","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypePoolPropEnum = append(diskTypePoolPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// pool0
	// END RIPPY DEBUGGING
	// DiskPoolPool0 captures enum value "pool0"
	DiskPoolPool0 string = "pool0"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// pool1
	// END RIPPY DEBUGGING
	// DiskPoolPool1 captures enum value "pool1"
	DiskPoolPool1 string = "pool1"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// failed
	// END RIPPY DEBUGGING
	// DiskPoolFailed captures enum value "failed"
	DiskPoolFailed string = "failed"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// none
	// END RIPPY DEBUGGING
	// DiskPoolNone captures enum value "none"
	DiskPoolNone string = "none"
)

// prop value enum
func (m *Disk) validatePoolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypePoolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validatePool(formats strfmt.Registry) error {
	if swag.IsZero(m.Pool) { // not required
		return nil
	}

	// value enum
	if err := m.validatePoolEnum("pool", "body", m.Pool); err != nil {
		return err
	}

	return nil
}

var diskTypeProtectionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["open","data","part","full"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeProtectionModePropEnum = append(diskTypeProtectionModePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// open
	// END RIPPY DEBUGGING
	// DiskProtectionModeOpen captures enum value "open"
	DiskProtectionModeOpen string = "open"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// data
	// END RIPPY DEBUGGING
	// DiskProtectionModeData captures enum value "data"
	DiskProtectionModeData string = "data"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// part
	// END RIPPY DEBUGGING
	// DiskProtectionModePart captures enum value "part"
	DiskProtectionModePart string = "part"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// full
	// END RIPPY DEBUGGING
	// DiskProtectionModeFull captures enum value "full"
	DiskProtectionModeFull string = "full"
)

// prop value enum
func (m *Disk) validateProtectionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeProtectionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateProtectionMode(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtectionModeEnum("protection_mode", "body", m.ProtectionMode); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateShelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Shelf) { // not required
		return nil
	}

	if m.Shelf != nil {
		if err := m.Shelf.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf")
			}
			return err
		}
	}

	return nil
}

var diskTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["broken","copy","maintenance","partner","pending","present","reconstructing","removed","spare","unfail","zeroing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeStatePropEnum = append(diskTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// broken
	// END RIPPY DEBUGGING
	// DiskStateBroken captures enum value "broken"
	DiskStateBroken string = "broken"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// copy
	// END RIPPY DEBUGGING
	// DiskStateCopy captures enum value "copy"
	DiskStateCopy string = "copy"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// maintenance
	// END RIPPY DEBUGGING
	// DiskStateMaintenance captures enum value "maintenance"
	DiskStateMaintenance string = "maintenance"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// partner
	// END RIPPY DEBUGGING
	// DiskStatePartner captures enum value "partner"
	DiskStatePartner string = "partner"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// pending
	// END RIPPY DEBUGGING
	// DiskStatePending captures enum value "pending"
	DiskStatePending string = "pending"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// present
	// END RIPPY DEBUGGING
	// DiskStatePresent captures enum value "present"
	DiskStatePresent string = "present"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// reconstructing
	// END RIPPY DEBUGGING
	// DiskStateReconstructing captures enum value "reconstructing"
	DiskStateReconstructing string = "reconstructing"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// removed
	// END RIPPY DEBUGGING
	// DiskStateRemoved captures enum value "removed"
	DiskStateRemoved string = "removed"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// spare
	// END RIPPY DEBUGGING
	// DiskStateSpare captures enum value "spare"
	DiskStateSpare string = "spare"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// unfail
	// END RIPPY DEBUGGING
	// DiskStateUnfail captures enum value "unfail"
	DiskStateUnfail string = "unfail"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// state
	// State
	// zeroing
	// END RIPPY DEBUGGING
	// DiskStateZeroing captures enum value "zeroing"
	DiskStateZeroing string = "zeroing"
)

// prop value enum
func (m *Disk) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var diskTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ata","bsas","fcal","fsas","lun","sas","msata","ssd","vmdisk","unknown","ssd_nvm"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeTypePropEnum = append(diskTypeTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// ata
	// END RIPPY DEBUGGING
	// DiskTypeAta captures enum value "ata"
	DiskTypeAta string = "ata"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// bsas
	// END RIPPY DEBUGGING
	// DiskTypeBsas captures enum value "bsas"
	DiskTypeBsas string = "bsas"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// fcal
	// END RIPPY DEBUGGING
	// DiskTypeFcal captures enum value "fcal"
	DiskTypeFcal string = "fcal"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// fsas
	// END RIPPY DEBUGGING
	// DiskTypeFsas captures enum value "fsas"
	DiskTypeFsas string = "fsas"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// lun
	// END RIPPY DEBUGGING
	// DiskTypeLun captures enum value "lun"
	DiskTypeLun string = "lun"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// sas
	// END RIPPY DEBUGGING
	// DiskTypeSas captures enum value "sas"
	DiskTypeSas string = "sas"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// msata
	// END RIPPY DEBUGGING
	// DiskTypeMsata captures enum value "msata"
	DiskTypeMsata string = "msata"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// ssd
	// END RIPPY DEBUGGING
	// DiskTypeSsd captures enum value "ssd"
	DiskTypeSsd string = "ssd"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// vmdisk
	// END RIPPY DEBUGGING
	// DiskTypeVmdisk captures enum value "vmdisk"
	DiskTypeVmdisk string = "vmdisk"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// unknown
	// END RIPPY DEBUGGING
	// DiskTypeUnknown captures enum value "unknown"
	DiskTypeUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// ssd_nvm
	// END RIPPY DEBUGGING
	// DiskTypeSsdNvm captures enum value "ssd_nvm"
	DiskTypeSsdNvm string = "ssd_nvm"
)

// prop value enum
func (m *Disk) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this disk based on the context it is used
func (m *Disk) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrawer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHomeNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeyID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Disk) contextValidateAggregates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Aggregates); i++ {

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) contextValidateDrNode(ctx context.Context, formats strfmt.Registry) error {

	if m.DrNode != nil {
		if err := m.DrNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dr_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateDrawer(ctx context.Context, formats strfmt.Registry) error {

	if m.Drawer != nil {
		if err := m.Drawer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drawer")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateHomeNode(ctx context.Context, formats strfmt.Registry) error {

	if m.HomeNode != nil {
		if err := m.HomeNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateKeyID(ctx context.Context, formats strfmt.Registry) error {

	if m.KeyID != nil {
		if err := m.KeyID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("key_id")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateShelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Shelf != nil {
		if err := m.Shelf.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Disk) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Disk) UnmarshalBinary(b []byte) error {
	var res Disk
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskAggregatesItems0 Aggregate
//
// swagger:model DiskAggregatesItems0
type DiskAggregatesItems0 struct {

	// links
	Links *DiskAggregatesItems0Links `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk aggregates items0
func (m *DiskAggregatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk aggregates items0 based on the context it is used
func (m *DiskAggregatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskAggregatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskAggregatesItems0) UnmarshalBinary(b []byte) error {
	var res DiskAggregatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskAggregatesItems0Links disk aggregates items0 links
//
// swagger:model DiskAggregatesItems0Links
type DiskAggregatesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this disk aggregates items0 links
func (m *DiskAggregatesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk aggregates items0 links based on the context it is used
func (m *DiskAggregatesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskAggregatesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskAggregatesItems0Links) UnmarshalBinary(b []byte) error {
	var res DiskAggregatesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskDrNode disk dr node
//
// swagger:model DiskDrNode
type DiskDrNode struct {

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk dr node
func (m *DiskDrNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this disk dr node based on the context it is used
func (m *DiskDrNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *DiskDrNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskDrNode) UnmarshalBinary(b []byte) error {
	var res DiskDrNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskDrawer disk drawer
//
// swagger:model DiskDrawer
type DiskDrawer struct {

	// id
	ID int64 `json:"id,omitempty"`

	// slot
	Slot int64 `json:"slot,omitempty"`
}

// Validate validates this disk drawer
func (m *DiskDrawer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this disk drawer based on context it is used
func (m *DiskDrawer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DiskDrawer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskDrawer) UnmarshalBinary(b []byte) error {
	var res DiskDrawer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskHomeNode disk home node
//
// swagger:model DiskHomeNode
type DiskHomeNode struct {

	// links
	Links *DiskHomeNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk home node
func (m *DiskHomeNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk home node based on the context it is used
func (m *DiskHomeNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskHomeNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskHomeNode) UnmarshalBinary(b []byte) error {
	var res DiskHomeNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskHomeNodeLinks disk home node links
//
// swagger:model DiskHomeNodeLinks
type DiskHomeNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this disk home node links
func (m *DiskHomeNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk home node links based on the context it is used
func (m *DiskHomeNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskHomeNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskHomeNodeLinks) UnmarshalBinary(b []byte) error {
	var res DiskHomeNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskKeyID disk key ID
//
// swagger:model DiskKeyID
type DiskKeyID struct {

	// Key ID of the data authentication key
	Data string `json:"data,omitempty"`

	// Key ID of the FIPS authentication key
	Fips string `json:"fips,omitempty"`
}

// Validate validates this disk key ID
func (m *DiskKeyID) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this disk key ID based on context it is used
func (m *DiskKeyID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DiskKeyID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskKeyID) UnmarshalBinary(b []byte) error {
	var res DiskKeyID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskNode disk node
//
// swagger:model DiskNode
type DiskNode struct {

	// links
	Links *DiskNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk node
func (m *DiskNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk node based on the context it is used
func (m *DiskNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskNode) UnmarshalBinary(b []byte) error {
	var res DiskNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskNodeLinks disk node links
//
// swagger:model DiskNodeLinks
type DiskNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this disk node links
func (m *DiskNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk node links based on the context it is used
func (m *DiskNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskNodeLinks) UnmarshalBinary(b []byte) error {
	var res DiskNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

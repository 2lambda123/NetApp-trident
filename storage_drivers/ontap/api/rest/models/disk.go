// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Disk disk
//
// swagger:model disk
type Disk struct {

	// List of aggregates sharing this disk
	// Read Only: true
	Aggregates []*DiskAggregatesItems0 `json:"aggregates,omitempty"`

	// Disk shelf bay
	// Example: 1
	// Read Only: true
	Bay int64 `json:"bay,omitempty"`

	// Bytes per sector.
	// Example: 520
	// Read Only: true
	BytesPerSector int64 `json:"bytes_per_sector,omitempty"`

	// Disk class
	// Example: solid_state
	// Read Only: true
	// Enum: [unknown capacity performance archive solid_state array virtual]
	Class string `json:"class,omitempty"`

	// Type of overlying disk container
	// Example: spare
	// Read Only: true
	// Enum: [aggregate broken foreign labelmaint maintenance shared spare unassigned unknown unsupported remote mediator]
	ContainerType string `json:"container_type,omitempty"`

	// dr node
	DrNode *DiskDrNode `json:"dr_node,omitempty"`

	// drawer
	Drawer *DiskDrawer `json:"drawer,omitempty"`

	// Effective Disk type
	// Example: vmdisk
	// Read Only: true
	// Enum: [ata fcal lun msata sas bsas ssd ssd_nvm ssd_cap fsas vmdisk unknown]
	EffectiveType string `json:"effective_type,omitempty"`

	// This field should only be set as a query parameter in a PATCH operation. It is input only and won't be returned by a subsequent GET.
	//
	EncryptionOperation string `json:"encryption_operation,omitempty"`

	// List of disk errors information.
	// Read Only: true
	Error []*DiskErrorInfo `json:"error,omitempty"`

	// fips certified
	// Read Only: true
	FipsCertified *bool `json:"fips_certified,omitempty"`

	// firmware version
	// Example: NA51
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// home node
	HomeNode *DiskHomeNode `json:"home_node,omitempty"`

	// key id
	KeyID *DiskKeyID `json:"key_id,omitempty"`

	// Indicates if a disk is locally attached versus being remotely attached.
	// A locally attached disk resides in the same proximity as the host
	// cluster versus been attached to the remote cluster.
	//
	// Read Only: true
	Local *bool `json:"local,omitempty"`

	// model
	// Example: X421_HCOBE450A10
	// Read Only: true
	Model string `json:"model,omitempty"`

	// Cluster-wide disk name
	// Example: 1.0.1
	// Read Only: true
	Name string `json:"name,omitempty"`

	// node
	Node *DiskNode `json:"node,omitempty"`

	// outage
	Outage *DiskOutage `json:"outage,omitempty"`

	// List of paths to a disk
	// Read Only: true
	Paths []*DiskPathInfo `json:"paths,omitempty"`

	// Pool to which disk is assigned
	// Example: pool0
	// Read Only: true
	// Enum: [pool0 pool1 failed none]
	Pool string `json:"pool,omitempty"`

	// Mode of drive data protection and FIPS compliance. Possible values are:
	// - _open_ - Disk is unprotected
	// - _data_ - Data protection only without FIPS compliance
	// - _part_ - Partial protection with FIPS compliance only
	// - _full_ - Full data and FIPS compliance protection
	//
	// Read Only: true
	// Enum: [open data part full]
	ProtectionMode string `json:"protection_mode,omitempty"`

	// Percentage of rated life used
	// Example: 10
	// Read Only: true
	RatedLifeUsedPercent int64 `json:"rated_life_used_percent,omitempty"`

	// Revolutions per minute
	// Example: 15000
	// Read Only: true
	Rpm int64 `json:"rpm,omitempty"`

	// Number of sectors on the disk.
	// Example: 1172123568
	// Read Only: true
	SectorCount int64 `json:"sector_count,omitempty"`

	// self encrypting
	// Read Only: true
	SelfEncrypting *bool `json:"self_encrypting,omitempty"`

	// serial number
	// Example: KHG2VX8R
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// shelf
	Shelf *DiskShelf `json:"shelf,omitempty"`

	// State
	// Example: present
	// Read Only: true
	// Enum: [broken copy maintenance partner pending present reconstructing removed spare unfail zeroing]
	State string `json:"state,omitempty"`

	// stats
	Stats *DiskStats `json:"stats,omitempty"`

	// Disk interface type
	// Example: ssd
	// Read Only: true
	// Enum: [ata bsas fcal fsas lun sas msata ssd vmdisk unknown ssd_cap ssd_nvm]
	Type string `json:"type,omitempty"`

	// The unique identifier for a disk
	// Example: 002538E5:71B00B2F:00000000:00000000:00000000:00000000:00000000:00000000:00000000:00000000
	// Read Only: true
	UID string `json:"uid,omitempty"`

	// usable size
	// Example: 959934889984
	// Read Only: true
	UsableSize int64 `json:"usable_size,omitempty"`

	// vendor
	// Example: NETAPP
	// Read Only: true
	Vendor string `json:"vendor,omitempty"`
}

// Validate validates this disk
func (m *Disk) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContainerType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrawer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaths(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePool(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Disk) validateAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregates) { // not required
		return nil
	}

	for i := 0; i < len(m.Aggregates); i++ {
		if swag.IsZero(m.Aggregates[i]) { // not required
			continue
		}

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var diskTypeClassPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","capacity","performance","archive","solid_state","array","virtual"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeClassPropEnum = append(diskTypeClassPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// unknown
	// END DEBUGGING
	// DiskClassUnknown captures enum value "unknown"
	DiskClassUnknown string = "unknown"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// capacity
	// END DEBUGGING
	// DiskClassCapacity captures enum value "capacity"
	DiskClassCapacity string = "capacity"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// performance
	// END DEBUGGING
	// DiskClassPerformance captures enum value "performance"
	DiskClassPerformance string = "performance"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// archive
	// END DEBUGGING
	// DiskClassArchive captures enum value "archive"
	DiskClassArchive string = "archive"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// solid_state
	// END DEBUGGING
	// DiskClassSolidState captures enum value "solid_state"
	DiskClassSolidState string = "solid_state"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// array
	// END DEBUGGING
	// DiskClassArray captures enum value "array"
	DiskClassArray string = "array"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// class
	// Class
	// virtual
	// END DEBUGGING
	// DiskClassVirtual captures enum value "virtual"
	DiskClassVirtual string = "virtual"
)

// prop value enum
func (m *Disk) validateClassEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeClassPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(m.Class) { // not required
		return nil
	}

	// value enum
	if err := m.validateClassEnum("class", "body", m.Class); err != nil {
		return err
	}

	return nil
}

var diskTypeContainerTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aggregate","broken","foreign","labelmaint","maintenance","shared","spare","unassigned","unknown","unsupported","remote","mediator"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeContainerTypePropEnum = append(diskTypeContainerTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// aggregate
	// END DEBUGGING
	// DiskContainerTypeAggregate captures enum value "aggregate"
	DiskContainerTypeAggregate string = "aggregate"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// broken
	// END DEBUGGING
	// DiskContainerTypeBroken captures enum value "broken"
	DiskContainerTypeBroken string = "broken"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// foreign
	// END DEBUGGING
	// DiskContainerTypeForeign captures enum value "foreign"
	DiskContainerTypeForeign string = "foreign"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// labelmaint
	// END DEBUGGING
	// DiskContainerTypeLabelmaint captures enum value "labelmaint"
	DiskContainerTypeLabelmaint string = "labelmaint"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// maintenance
	// END DEBUGGING
	// DiskContainerTypeMaintenance captures enum value "maintenance"
	DiskContainerTypeMaintenance string = "maintenance"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// shared
	// END DEBUGGING
	// DiskContainerTypeShared captures enum value "shared"
	DiskContainerTypeShared string = "shared"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// spare
	// END DEBUGGING
	// DiskContainerTypeSpare captures enum value "spare"
	DiskContainerTypeSpare string = "spare"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// unassigned
	// END DEBUGGING
	// DiskContainerTypeUnassigned captures enum value "unassigned"
	DiskContainerTypeUnassigned string = "unassigned"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// unknown
	// END DEBUGGING
	// DiskContainerTypeUnknown captures enum value "unknown"
	DiskContainerTypeUnknown string = "unknown"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// unsupported
	// END DEBUGGING
	// DiskContainerTypeUnsupported captures enum value "unsupported"
	DiskContainerTypeUnsupported string = "unsupported"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// remote
	// END DEBUGGING
	// DiskContainerTypeRemote captures enum value "remote"
	DiskContainerTypeRemote string = "remote"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// container_type
	// ContainerType
	// mediator
	// END DEBUGGING
	// DiskContainerTypeMediator captures enum value "mediator"
	DiskContainerTypeMediator string = "mediator"
)

// prop value enum
func (m *Disk) validateContainerTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeContainerTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateContainerType(formats strfmt.Registry) error {
	if swag.IsZero(m.ContainerType) { // not required
		return nil
	}

	// value enum
	if err := m.validateContainerTypeEnum("container_type", "body", m.ContainerType); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateDrNode(formats strfmt.Registry) error {
	if swag.IsZero(m.DrNode) { // not required
		return nil
	}

	if m.DrNode != nil {
		if err := m.DrNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dr_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateDrawer(formats strfmt.Registry) error {
	if swag.IsZero(m.Drawer) { // not required
		return nil
	}

	if m.Drawer != nil {
		if err := m.Drawer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drawer")
			}
			return err
		}
	}

	return nil
}

var diskTypeEffectiveTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ata","fcal","lun","msata","sas","bsas","ssd","ssd_nvm","ssd_cap","fsas","vmdisk","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeEffectiveTypePropEnum = append(diskTypeEffectiveTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// ata
	// END DEBUGGING
	// DiskEffectiveTypeAta captures enum value "ata"
	DiskEffectiveTypeAta string = "ata"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// fcal
	// END DEBUGGING
	// DiskEffectiveTypeFcal captures enum value "fcal"
	DiskEffectiveTypeFcal string = "fcal"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// lun
	// END DEBUGGING
	// DiskEffectiveTypeLun captures enum value "lun"
	DiskEffectiveTypeLun string = "lun"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// msata
	// END DEBUGGING
	// DiskEffectiveTypeMsata captures enum value "msata"
	DiskEffectiveTypeMsata string = "msata"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// sas
	// END DEBUGGING
	// DiskEffectiveTypeSas captures enum value "sas"
	DiskEffectiveTypeSas string = "sas"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// bsas
	// END DEBUGGING
	// DiskEffectiveTypeBsas captures enum value "bsas"
	DiskEffectiveTypeBsas string = "bsas"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// ssd
	// END DEBUGGING
	// DiskEffectiveTypeSsd captures enum value "ssd"
	DiskEffectiveTypeSsd string = "ssd"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// ssd_nvm
	// END DEBUGGING
	// DiskEffectiveTypeSsdNvm captures enum value "ssd_nvm"
	DiskEffectiveTypeSsdNvm string = "ssd_nvm"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// ssd_cap
	// END DEBUGGING
	// DiskEffectiveTypeSsdCap captures enum value "ssd_cap"
	DiskEffectiveTypeSsdCap string = "ssd_cap"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// fsas
	// END DEBUGGING
	// DiskEffectiveTypeFsas captures enum value "fsas"
	DiskEffectiveTypeFsas string = "fsas"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// vmdisk
	// END DEBUGGING
	// DiskEffectiveTypeVmdisk captures enum value "vmdisk"
	DiskEffectiveTypeVmdisk string = "vmdisk"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// effective_type
	// EffectiveType
	// unknown
	// END DEBUGGING
	// DiskEffectiveTypeUnknown captures enum value "unknown"
	DiskEffectiveTypeUnknown string = "unknown"
)

// prop value enum
func (m *Disk) validateEffectiveTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeEffectiveTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateEffectiveType(formats strfmt.Registry) error {
	if swag.IsZero(m.EffectiveType) { // not required
		return nil
	}

	// value enum
	if err := m.validateEffectiveTypeEnum("effective_type", "body", m.EffectiveType); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	for i := 0; i < len(m.Error); i++ {
		if swag.IsZero(m.Error[i]) { // not required
			continue
		}

		if m.Error[i] != nil {
			if err := m.Error[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("error" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) validateHomeNode(formats strfmt.Registry) error {
	if swag.IsZero(m.HomeNode) { // not required
		return nil
	}

	if m.HomeNode != nil {
		if err := m.HomeNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateKeyID(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyID) { // not required
		return nil
	}

	if m.KeyID != nil {
		if err := m.KeyID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("key_id")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validateOutage(formats strfmt.Registry) error {
	if swag.IsZero(m.Outage) { // not required
		return nil
	}

	if m.Outage != nil {
		if err := m.Outage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outage")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) validatePaths(formats strfmt.Registry) error {
	if swag.IsZero(m.Paths) { // not required
		return nil
	}

	for i := 0; i < len(m.Paths); i++ {
		if swag.IsZero(m.Paths[i]) { // not required
			continue
		}

		if m.Paths[i] != nil {
			if err := m.Paths[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("paths" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var diskTypePoolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pool0","pool1","failed","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypePoolPropEnum = append(diskTypePoolPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// pool0
	// END DEBUGGING
	// DiskPoolPool0 captures enum value "pool0"
	DiskPoolPool0 string = "pool0"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// pool1
	// END DEBUGGING
	// DiskPoolPool1 captures enum value "pool1"
	DiskPoolPool1 string = "pool1"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// failed
	// END DEBUGGING
	// DiskPoolFailed captures enum value "failed"
	DiskPoolFailed string = "failed"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// pool
	// Pool
	// none
	// END DEBUGGING
	// DiskPoolNone captures enum value "none"
	DiskPoolNone string = "none"
)

// prop value enum
func (m *Disk) validatePoolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypePoolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validatePool(formats strfmt.Registry) error {
	if swag.IsZero(m.Pool) { // not required
		return nil
	}

	// value enum
	if err := m.validatePoolEnum("pool", "body", m.Pool); err != nil {
		return err
	}

	return nil
}

var diskTypeProtectionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["open","data","part","full"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeProtectionModePropEnum = append(diskTypeProtectionModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// open
	// END DEBUGGING
	// DiskProtectionModeOpen captures enum value "open"
	DiskProtectionModeOpen string = "open"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// data
	// END DEBUGGING
	// DiskProtectionModeData captures enum value "data"
	DiskProtectionModeData string = "data"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// part
	// END DEBUGGING
	// DiskProtectionModePart captures enum value "part"
	DiskProtectionModePart string = "part"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// protection_mode
	// ProtectionMode
	// full
	// END DEBUGGING
	// DiskProtectionModeFull captures enum value "full"
	DiskProtectionModeFull string = "full"
)

// prop value enum
func (m *Disk) validateProtectionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeProtectionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateProtectionMode(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtectionModeEnum("protection_mode", "body", m.ProtectionMode); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateShelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Shelf) { // not required
		return nil
	}

	if m.Shelf != nil {
		if err := m.Shelf.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf")
			}
			return err
		}
	}

	return nil
}

var diskTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["broken","copy","maintenance","partner","pending","present","reconstructing","removed","spare","unfail","zeroing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeStatePropEnum = append(diskTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// broken
	// END DEBUGGING
	// DiskStateBroken captures enum value "broken"
	DiskStateBroken string = "broken"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// copy
	// END DEBUGGING
	// DiskStateCopy captures enum value "copy"
	DiskStateCopy string = "copy"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// maintenance
	// END DEBUGGING
	// DiskStateMaintenance captures enum value "maintenance"
	DiskStateMaintenance string = "maintenance"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// partner
	// END DEBUGGING
	// DiskStatePartner captures enum value "partner"
	DiskStatePartner string = "partner"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// pending
	// END DEBUGGING
	// DiskStatePending captures enum value "pending"
	DiskStatePending string = "pending"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// present
	// END DEBUGGING
	// DiskStatePresent captures enum value "present"
	DiskStatePresent string = "present"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// reconstructing
	// END DEBUGGING
	// DiskStateReconstructing captures enum value "reconstructing"
	DiskStateReconstructing string = "reconstructing"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// removed
	// END DEBUGGING
	// DiskStateRemoved captures enum value "removed"
	DiskStateRemoved string = "removed"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// spare
	// END DEBUGGING
	// DiskStateSpare captures enum value "spare"
	DiskStateSpare string = "spare"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// unfail
	// END DEBUGGING
	// DiskStateUnfail captures enum value "unfail"
	DiskStateUnfail string = "unfail"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// state
	// State
	// zeroing
	// END DEBUGGING
	// DiskStateZeroing captures enum value "zeroing"
	DiskStateZeroing string = "zeroing"
)

// prop value enum
func (m *Disk) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateStats(formats strfmt.Registry) error {
	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

var diskTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ata","bsas","fcal","fsas","lun","sas","msata","ssd","vmdisk","unknown","ssd_cap","ssd_nvm"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeTypePropEnum = append(diskTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// ata
	// END DEBUGGING
	// DiskTypeAta captures enum value "ata"
	DiskTypeAta string = "ata"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// bsas
	// END DEBUGGING
	// DiskTypeBsas captures enum value "bsas"
	DiskTypeBsas string = "bsas"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// fcal
	// END DEBUGGING
	// DiskTypeFcal captures enum value "fcal"
	DiskTypeFcal string = "fcal"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// fsas
	// END DEBUGGING
	// DiskTypeFsas captures enum value "fsas"
	DiskTypeFsas string = "fsas"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// lun
	// END DEBUGGING
	// DiskTypeLun captures enum value "lun"
	DiskTypeLun string = "lun"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// sas
	// END DEBUGGING
	// DiskTypeSas captures enum value "sas"
	DiskTypeSas string = "sas"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// msata
	// END DEBUGGING
	// DiskTypeMsata captures enum value "msata"
	DiskTypeMsata string = "msata"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// ssd
	// END DEBUGGING
	// DiskTypeSsd captures enum value "ssd"
	DiskTypeSsd string = "ssd"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// vmdisk
	// END DEBUGGING
	// DiskTypeVmdisk captures enum value "vmdisk"
	DiskTypeVmdisk string = "vmdisk"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// unknown
	// END DEBUGGING
	// DiskTypeUnknown captures enum value "unknown"
	DiskTypeUnknown string = "unknown"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// ssd_cap
	// END DEBUGGING
	// DiskTypeSsdCap captures enum value "ssd_cap"
	DiskTypeSsdCap string = "ssd_cap"

	// BEGIN DEBUGGING
	// disk
	// Disk
	// type
	// Type
	// ssd_nvm
	// END DEBUGGING
	// DiskTypeSsdNvm captures enum value "ssd_nvm"
	DiskTypeSsdNvm string = "ssd_nvm"
)

// prop value enum
func (m *Disk) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this disk based on the context it is used
func (m *Disk) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBay(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBytesPerSector(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClass(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContainerType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrawer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEffectiveType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFipsCertified(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHomeNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeyID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOutage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaths(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePool(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectionMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRatedLifeUsedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRpm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSectorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfEncrypting(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsableSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVendor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Disk) contextValidateAggregates(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregates", "body", []*DiskAggregatesItems0(m.Aggregates)); err != nil {
		return err
	}

	for i := 0; i < len(m.Aggregates); i++ {

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) contextValidateBay(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "bay", "body", int64(m.Bay)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateBytesPerSector(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "bytes_per_sector", "body", int64(m.BytesPerSector)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateClass(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "class", "body", string(m.Class)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateContainerType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "container_type", "body", string(m.ContainerType)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateDrNode(ctx context.Context, formats strfmt.Registry) error {

	if m.DrNode != nil {
		if err := m.DrNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dr_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateDrawer(ctx context.Context, formats strfmt.Registry) error {

	if m.Drawer != nil {
		if err := m.Drawer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drawer")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateEffectiveType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "effective_type", "body", string(m.EffectiveType)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "error", "body", []*DiskErrorInfo(m.Error)); err != nil {
		return err
	}

	for i := 0; i < len(m.Error); i++ {

		if m.Error[i] != nil {
			if err := m.Error[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("error" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) contextValidateFipsCertified(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fips_certified", "body", m.FipsCertified); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateHomeNode(ctx context.Context, formats strfmt.Registry) error {

	if m.HomeNode != nil {
		if err := m.HomeNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateKeyID(ctx context.Context, formats strfmt.Registry) error {

	if m.KeyID != nil {
		if err := m.KeyID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("key_id")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "local", "body", m.Local); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateOutage(ctx context.Context, formats strfmt.Registry) error {

	if m.Outage != nil {
		if err := m.Outage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outage")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidatePaths(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "paths", "body", []*DiskPathInfo(m.Paths)); err != nil {
		return err
	}

	for i := 0; i < len(m.Paths); i++ {

		if m.Paths[i] != nil {
			if err := m.Paths[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("paths" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) contextValidatePool(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "pool", "body", string(m.Pool)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateProtectionMode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "protection_mode", "body", string(m.ProtectionMode)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateRatedLifeUsedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rated_life_used_percent", "body", int64(m.RatedLifeUsedPercent)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateRpm(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rpm", "body", int64(m.Rpm)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateSectorCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sector_count", "body", int64(m.SectorCount)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateSelfEncrypting(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "self_encrypting", "body", m.SelfEncrypting); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateShelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Shelf != nil {
		if err := m.Shelf.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {
		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *Disk) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uid", "body", string(m.UID)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateUsableSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "usable_size", "body", int64(m.UsableSize)); err != nil {
		return err
	}

	return nil
}

func (m *Disk) contextValidateVendor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vendor", "body", string(m.Vendor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Disk) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Disk) UnmarshalBinary(b []byte) error {
	var res Disk
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskAggregatesItems0 Aggregate
//
// swagger:model DiskAggregatesItems0
type DiskAggregatesItems0 struct {

	// links
	Links *DiskAggregatesItems0Links `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk aggregates items0
func (m *DiskAggregatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk aggregates items0 based on the context it is used
func (m *DiskAggregatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskAggregatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskAggregatesItems0) UnmarshalBinary(b []byte) error {
	var res DiskAggregatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskAggregatesItems0Links disk aggregates items0 links
//
// swagger:model DiskAggregatesItems0Links
type DiskAggregatesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this disk aggregates items0 links
func (m *DiskAggregatesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk aggregates items0 links based on the context it is used
func (m *DiskAggregatesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskAggregatesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskAggregatesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskAggregatesItems0Links) UnmarshalBinary(b []byte) error {
	var res DiskAggregatesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskDrNode disk dr node
//
// swagger:model DiskDrNode
type DiskDrNode struct {

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk dr node
func (m *DiskDrNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this disk dr node based on context it is used
func (m *DiskDrNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DiskDrNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskDrNode) UnmarshalBinary(b []byte) error {
	var res DiskDrNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskDrawer disk drawer
//
// swagger:model DiskDrawer
type DiskDrawer struct {

	// id
	ID int64 `json:"id,omitempty"`

	// slot
	Slot int64 `json:"slot,omitempty"`
}

// Validate validates this disk drawer
func (m *DiskDrawer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this disk drawer based on the context it is used
func (m *DiskDrawer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *DiskDrawer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskDrawer) UnmarshalBinary(b []byte) error {
	var res DiskDrawer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskHomeNode disk home node
//
// swagger:model DiskHomeNode
type DiskHomeNode struct {

	// links
	Links *DiskHomeNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk home node
func (m *DiskHomeNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk home node based on the context it is used
func (m *DiskHomeNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskHomeNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskHomeNode) UnmarshalBinary(b []byte) error {
	var res DiskHomeNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskHomeNodeLinks disk home node links
//
// swagger:model DiskHomeNodeLinks
type DiskHomeNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this disk home node links
func (m *DiskHomeNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk home node links based on the context it is used
func (m *DiskHomeNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskHomeNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskHomeNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskHomeNodeLinks) UnmarshalBinary(b []byte) error {
	var res DiskHomeNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskKeyID disk key ID
//
// swagger:model DiskKeyID
type DiskKeyID struct {

	// Key ID of the data authentication key
	Data string `json:"data,omitempty"`

	// Key ID of the FIPS authentication key
	Fips string `json:"fips,omitempty"`
}

// Validate validates this disk key ID
func (m *DiskKeyID) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this disk key ID based on the context it is used
func (m *DiskKeyID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *DiskKeyID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskKeyID) UnmarshalBinary(b []byte) error {
	var res DiskKeyID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskNode disk node
//
// swagger:model DiskNode
type DiskNode struct {

	// links
	Links *DiskNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this disk node
func (m *DiskNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk node based on the context it is used
func (m *DiskNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskNode) UnmarshalBinary(b []byte) error {
	var res DiskNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskNodeLinks disk node links
//
// swagger:model DiskNodeLinks
type DiskNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this disk node links
func (m *DiskNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk node links based on the context it is used
func (m *DiskNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskNodeLinks) UnmarshalBinary(b []byte) error {
	var res DiskNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskOutage Indicates if a disk has an entry in the failed disk registry, along with the reason for the failure.
//
// swagger:model DiskOutage
type DiskOutage struct {

	// Indicates whether RAID maintains the state of this disk as failed accross reboots.
	// Read Only: true
	PersistentlyFailed *bool `json:"persistently_failed,omitempty"`

	// reason
	Reason *DiskOutageReason `json:"reason,omitempty"`
}

// Validate validates this disk outage
func (m *DiskOutage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateReason(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskOutage) validateReason(formats strfmt.Registry) error {
	if swag.IsZero(m.Reason) { // not required
		return nil
	}

	if m.Reason != nil {
		if err := m.Reason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outage" + "." + "reason")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk outage based on the context it is used
func (m *DiskOutage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePersistentlyFailed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskOutage) contextValidatePersistentlyFailed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "outage"+"."+"persistently_failed", "body", m.PersistentlyFailed); err != nil {
		return err
	}

	return nil
}

func (m *DiskOutage) contextValidateReason(ctx context.Context, formats strfmt.Registry) error {

	if m.Reason != nil {
		if err := m.Reason.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outage" + "." + "reason")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskOutage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskOutage) UnmarshalBinary(b []byte) error {
	var res DiskOutage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskOutageReason disk outage reason
//
// swagger:model DiskOutageReason
type DiskOutageReason struct {

	// This field provides the error code explaining why a disk failed.
	// Example: 721081
	// Read Only: true
	Code string `json:"code,omitempty"`

	// This field provides the error message explaining why a disk failed.
	// Example: not responding
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this disk outage reason
func (m *DiskOutageReason) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this disk outage reason based on the context it is used
func (m *DiskOutageReason) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskOutageReason) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "outage"+"."+"reason"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *DiskOutageReason) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "outage"+"."+"reason"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskOutageReason) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskOutageReason) UnmarshalBinary(b []byte) error {
	var res DiskOutageReason
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskShelf disk shelf
//
// swagger:model DiskShelf
type DiskShelf struct {

	// links
	Links *DiskShelfLinks `json:"_links,omitempty"`

	// uid
	// Example: 7777841915827391056
	UID string `json:"uid,omitempty"`
}

// Validate validates this disk shelf
func (m *DiskShelf) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskShelf) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk shelf based on the context it is used
func (m *DiskShelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskShelf) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskShelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskShelf) UnmarshalBinary(b []byte) error {
	var res DiskShelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskShelfLinks disk shelf links
//
// swagger:model DiskShelfLinks
type DiskShelfLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this disk shelf links
func (m *DiskShelfLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskShelfLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this disk shelf links based on the context it is used
func (m *DiskShelfLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskShelfLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shelf" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskShelfLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskShelfLinks) UnmarshalBinary(b []byte) error {
	var res DiskShelfLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DiskStats disk stats
//
// swagger:model DiskStats
type DiskStats struct {

	// Average I/O latency across all active paths, in milliseconds.
	// Example: 3
	// Read Only: true
	AverageLatency int64 `json:"average_latency,omitempty"`

	// Total I/O operations per second read and written to this disk across all active paths.
	// Example: 12854
	// Read Only: true
	IopsTotal int64 `json:"iops_total,omitempty"`

	// Disk path error count; failed I/O operations.
	// Example: 0
	// Read Only: true
	PathErrorCount int64 `json:"path_error_count,omitempty"`

	// Hours powered on.
	// Example: 21016
	// Read Only: true
	PowerOnHours int64 `json:"power_on_hours,omitempty"`

	// Total disk throughput per second across all active paths, in bytes.
	// Example: 1957888
	// Read Only: true
	Throughput int64 `json:"throughput,omitempty"`
}

// Validate validates this disk stats
func (m *DiskStats) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this disk stats based on the context it is used
func (m *DiskStats) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAverageLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIopsTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePathErrorCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePowerOnHours(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskStats) contextValidateAverageLatency(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "stats"+"."+"average_latency", "body", int64(m.AverageLatency)); err != nil {
		return err
	}

	return nil
}

func (m *DiskStats) contextValidateIopsTotal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "stats"+"."+"iops_total", "body", int64(m.IopsTotal)); err != nil {
		return err
	}

	return nil
}

func (m *DiskStats) contextValidatePathErrorCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "stats"+"."+"path_error_count", "body", int64(m.PathErrorCount)); err != nil {
		return err
	}

	return nil
}

func (m *DiskStats) contextValidatePowerOnHours(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "stats"+"."+"power_on_hours", "body", int64(m.PowerOnHours)); err != nil {
		return err
	}

	return nil
}

func (m *DiskStats) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "stats"+"."+"throughput", "body", int64(m.Throughput)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskStats) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskStats) UnmarshalBinary(b []byte) error {
	var res DiskStats
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Port port
//
// swagger:model port
type Port struct {

	// links
	Links *PortLinks `json:"_links,omitempty"`

	// broadcast domain
	BroadcastDomain *PortBroadcastDomain `json:"broadcast_domain,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// Number of interfaces hosted. This field is only applicable for cluster administrators. No value is returned for SVM administrators. If the node hosting a port is not healthy no value will be returned.
	// Read Only: true
	InterfaceCount int64 `json:"interface_count,omitempty"`

	// lag
	Lag *PortLag `json:"lag,omitempty"`

	// mac address
	// Example: 01:02:03:04:05:06
	// Read Only: true
	MacAddress string `json:"mac_address,omitempty"`

	// metric
	Metric *PortMetric `json:"metric,omitempty"`

	// MTU of the port in bytes. Set by broadcast domain.
	// Example: 1500
	// Read Only: true
	// Minimum: 68
	Mtu int64 `json:"mtu,omitempty"`

	// Portname, such as e0a, e1b-100 (VLAN on Ethernet), a0c (LAG/ifgrp), a0d-200 (VLAN on LAG/ifgrp), e0a.pv1 (p-VLAN, in select environments only)
	// Example: e1b
	// Read Only: true
	Name string `json:"name,omitempty"`

	// node
	Node *PortNode `json:"node,omitempty"`

	// Supported RDMA offload protocols
	// Read Only: true
	RdmaProtocols []string `json:"rdma_protocols,omitempty"`

	// Reachability status of the port. Enum value "ok" is the only acceptable value for a PATCH request to repair a port.
	// Example: ok
	// Enum: [ok repairable not_repairable]
	Reachability string `json:"reachability,omitempty"`

	// Reachable broadcast domains.
	// Read Only: true
	ReachableBroadcastDomains []*PortReachableBroadcastDomainsItems0 `json:"reachable_broadcast_domains,omitempty"`

	// Link speed in Mbps
	// Example: 1000
	// Read Only: true
	Speed int64 `json:"speed,omitempty"`

	// Operational state of the port. The state is set to 'down' if the operational state of the port is down. The state is set to 'up' if the link state of the port is up and the port is healthy. The state is set to 'up' if the link state of the port is up and configured to ignore health status. The state is 'degraded' if the link state of the port is up, and the port is not healthy.
	// Read Only: true
	// Enum: [up down degraded]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *PortStatisticsType `json:"statistics,omitempty"`

	// Type of physical or virtual port
	// Enum: [vlan physical lag pvlan]
	Type string `json:"type,omitempty"`

	// Port UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// vlan
	Vlan *PortVlan `json:"vlan,omitempty"`
}

// Validate validates this port
func (m *Port) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBroadcastDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMtu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRdmaProtocols(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReachability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReachableBroadcastDomains(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlan(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Port) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Port) validateBroadcastDomain(formats strfmt.Registry) error {
	if swag.IsZero(m.BroadcastDomain) { // not required
		return nil
	}

	if m.BroadcastDomain != nil {
		if err := m.BroadcastDomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain")
			}
			return err
		}
	}

	return nil
}

func (m *Port) validateLag(formats strfmt.Registry) error {
	if swag.IsZero(m.Lag) { // not required
		return nil
	}

	if m.Lag != nil {
		if err := m.Lag.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lag")
			}
			return err
		}
	}

	return nil
}

func (m *Port) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Port) validateMtu(formats strfmt.Registry) error {
	if swag.IsZero(m.Mtu) { // not required
		return nil
	}

	if err := validate.MinimumInt("mtu", "body", m.Mtu, 68, false); err != nil {
		return err
	}

	return nil
}

func (m *Port) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

var portRdmaProtocolsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["roce"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portRdmaProtocolsItemsEnum = append(portRdmaProtocolsItemsEnum, v)
	}
}

func (m *Port) validateRdmaProtocolsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portRdmaProtocolsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Port) validateRdmaProtocols(formats strfmt.Registry) error {
	if swag.IsZero(m.RdmaProtocols) { // not required
		return nil
	}

	for i := 0; i < len(m.RdmaProtocols); i++ {

		// value enum
		if err := m.validateRdmaProtocolsItemsEnum("rdma_protocols"+"."+strconv.Itoa(i), "body", m.RdmaProtocols[i]); err != nil {
			return err
		}

	}

	return nil
}

var portTypeReachabilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","repairable","not_repairable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portTypeReachabilityPropEnum = append(portTypeReachabilityPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// port
	// Port
	// reachability
	// Reachability
	// ok
	// END DEBUGGING
	// PortReachabilityOk captures enum value "ok"
	PortReachabilityOk string = "ok"

	// BEGIN DEBUGGING
	// port
	// Port
	// reachability
	// Reachability
	// repairable
	// END DEBUGGING
	// PortReachabilityRepairable captures enum value "repairable"
	PortReachabilityRepairable string = "repairable"

	// BEGIN DEBUGGING
	// port
	// Port
	// reachability
	// Reachability
	// not_repairable
	// END DEBUGGING
	// PortReachabilityNotRepairable captures enum value "not_repairable"
	PortReachabilityNotRepairable string = "not_repairable"
)

// prop value enum
func (m *Port) validateReachabilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portTypeReachabilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Port) validateReachability(formats strfmt.Registry) error {
	if swag.IsZero(m.Reachability) { // not required
		return nil
	}

	// value enum
	if err := m.validateReachabilityEnum("reachability", "body", m.Reachability); err != nil {
		return err
	}

	return nil
}

func (m *Port) validateReachableBroadcastDomains(formats strfmt.Registry) error {
	if swag.IsZero(m.ReachableBroadcastDomains) { // not required
		return nil
	}

	for i := 0; i < len(m.ReachableBroadcastDomains); i++ {
		if swag.IsZero(m.ReachableBroadcastDomains[i]) { // not required
			continue
		}

		if m.ReachableBroadcastDomains[i] != nil {
			if err := m.ReachableBroadcastDomains[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reachable_broadcast_domains" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var portTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down","degraded"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portTypeStatePropEnum = append(portTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// port
	// Port
	// state
	// State
	// up
	// END DEBUGGING
	// PortStateUp captures enum value "up"
	PortStateUp string = "up"

	// BEGIN DEBUGGING
	// port
	// Port
	// state
	// State
	// down
	// END DEBUGGING
	// PortStateDown captures enum value "down"
	PortStateDown string = "down"

	// BEGIN DEBUGGING
	// port
	// Port
	// state
	// State
	// degraded
	// END DEBUGGING
	// PortStateDegraded captures enum value "degraded"
	PortStateDegraded string = "degraded"
)

// prop value enum
func (m *Port) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Port) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Port) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

var portTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["vlan","physical","lag","pvlan"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portTypeTypePropEnum = append(portTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// port
	// Port
	// type
	// Type
	// vlan
	// END DEBUGGING
	// PortTypeVlan captures enum value "vlan"
	PortTypeVlan string = "vlan"

	// BEGIN DEBUGGING
	// port
	// Port
	// type
	// Type
	// physical
	// END DEBUGGING
	// PortTypePhysical captures enum value "physical"
	PortTypePhysical string = "physical"

	// BEGIN DEBUGGING
	// port
	// Port
	// type
	// Type
	// lag
	// END DEBUGGING
	// PortTypeLag captures enum value "lag"
	PortTypeLag string = "lag"

	// BEGIN DEBUGGING
	// port
	// Port
	// type
	// Type
	// pvlan
	// END DEBUGGING
	// PortTypePvlan captures enum value "pvlan"
	PortTypePvlan string = "pvlan"
)

// prop value enum
func (m *Port) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Port) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Port) validateVlan(formats strfmt.Registry) error {
	if swag.IsZero(m.Vlan) { // not required
		return nil
	}

	if m.Vlan != nil {
		if err := m.Vlan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port based on the context it is used
func (m *Port) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBroadcastDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInterfaceCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLag(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMtu(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRdmaProtocols(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReachableBroadcastDomains(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpeed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVlan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Port) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateBroadcastDomain(ctx context.Context, formats strfmt.Registry) error {

	if m.BroadcastDomain != nil {
		if err := m.BroadcastDomain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateInterfaceCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "interface_count", "body", int64(m.InterfaceCount)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateLag(ctx context.Context, formats strfmt.Registry) error {

	if m.Lag != nil {
		if err := m.Lag.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lag")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateMacAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mac_address", "body", string(m.MacAddress)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateMtu(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mtu", "body", int64(m.Mtu)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateRdmaProtocols(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "rdma_protocols", "body", []string(m.RdmaProtocols)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateReachableBroadcastDomains(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "reachable_broadcast_domains", "body", []*PortReachableBroadcastDomainsItems0(m.ReachableBroadcastDomains)); err != nil {
		return err
	}

	for i := 0; i < len(m.ReachableBroadcastDomains); i++ {

		if m.ReachableBroadcastDomains[i] != nil {
			if err := m.ReachableBroadcastDomains[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reachable_broadcast_domains" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Port) contextValidateSpeed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "speed", "body", int64(m.Speed)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateVlan(ctx context.Context, formats strfmt.Registry) error {

	if m.Vlan != nil {
		if err := m.Vlan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Port) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Port) UnmarshalBinary(b []byte) error {
	var res Port
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortBroadcastDomain Broadcast domain UUID along with a readable name. Either the UUID or both names may be provided on input.
//
// swagger:model PortBroadcastDomain
type PortBroadcastDomain struct {

	// links
	Links *PortBroadcastDomainLinks `json:"_links,omitempty"`

	// ipspace
	Ipspace *PortBroadcastDomainIpspace `json:"ipspace,omitempty"`

	// Name of the broadcast domain, scoped to its IPspace
	// Example: bd1
	Name string `json:"name,omitempty"`

	// Broadcast domain UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port broadcast domain
func (m *PortBroadcastDomain) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomain) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortBroadcastDomain) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "ipspace")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port broadcast domain based on the context it is used
func (m *PortBroadcastDomain) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomain) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortBroadcastDomain) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "ipspace")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortBroadcastDomain) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortBroadcastDomain) UnmarshalBinary(b []byte) error {
	var res PortBroadcastDomain
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortBroadcastDomainIpspace port broadcast domain ipspace
//
// swagger:model PortBroadcastDomainIpspace
type PortBroadcastDomainIpspace struct {

	// Name of the broadcast domain's IPspace
	// Example: ipspace1
	Name string `json:"name,omitempty"`
}

// Validate validates this port broadcast domain ipspace
func (m *PortBroadcastDomainIpspace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port broadcast domain ipspace based on context it is used
func (m *PortBroadcastDomainIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortBroadcastDomainIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortBroadcastDomainIpspace) UnmarshalBinary(b []byte) error {
	var res PortBroadcastDomainIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortBroadcastDomainLinks port broadcast domain links
//
// swagger:model PortBroadcastDomainLinks
type PortBroadcastDomainLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port broadcast domain links
func (m *PortBroadcastDomainLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomainLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port broadcast domain links based on the context it is used
func (m *PortBroadcastDomainLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomainLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortBroadcastDomainLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortBroadcastDomainLinks) UnmarshalBinary(b []byte) error {
	var res PortBroadcastDomainLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLag port lag
//
// swagger:model PortLag
type PortLag struct {

	// Active ports of a LAG (ifgrp). (Some member ports may be inactive.)
	// Read Only: true
	ActivePorts []*PortLagActivePortsItems0 `json:"active_ports,omitempty"`

	// Policy for mapping flows to ports for outbound packets through a LAG (ifgrp).
	// Enum: [port ip mac sequential]
	DistributionPolicy string `json:"distribution_policy,omitempty"`

	// Array of ports belonging to the LAG, regardless of their state.
	MemberPorts []*PortLagMemberPortsItems0 `json:"member_ports,omitempty"`

	// Determines how the ports interact with the switch.
	// Enum: [multimode_lacp multimode singlemode]
	Mode string `json:"mode,omitempty"`
}

// Validate validates this port lag
func (m *PortLag) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActivePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDistributionPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemberPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLag) validateActivePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.ActivePorts) { // not required
		return nil
	}

	for i := 0; i < len(m.ActivePorts); i++ {
		if swag.IsZero(m.ActivePorts[i]) { // not required
			continue
		}

		if m.ActivePorts[i] != nil {
			if err := m.ActivePorts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "active_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var portLagTypeDistributionPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["port","ip","mac","sequential"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portLagTypeDistributionPolicyPropEnum = append(portLagTypeDistributionPolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// port
	// END DEBUGGING
	// PortLagDistributionPolicyPort captures enum value "port"
	PortLagDistributionPolicyPort string = "port"

	// BEGIN DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// ip
	// END DEBUGGING
	// PortLagDistributionPolicyIP captures enum value "ip"
	PortLagDistributionPolicyIP string = "ip"

	// BEGIN DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// mac
	// END DEBUGGING
	// PortLagDistributionPolicyMac captures enum value "mac"
	PortLagDistributionPolicyMac string = "mac"

	// BEGIN DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// sequential
	// END DEBUGGING
	// PortLagDistributionPolicySequential captures enum value "sequential"
	PortLagDistributionPolicySequential string = "sequential"
)

// prop value enum
func (m *PortLag) validateDistributionPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portLagTypeDistributionPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PortLag) validateDistributionPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.DistributionPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateDistributionPolicyEnum("lag"+"."+"distribution_policy", "body", m.DistributionPolicy); err != nil {
		return err
	}

	return nil
}

func (m *PortLag) validateMemberPorts(formats strfmt.Registry) error {
	if swag.IsZero(m.MemberPorts) { // not required
		return nil
	}

	for i := 0; i < len(m.MemberPorts); i++ {
		if swag.IsZero(m.MemberPorts[i]) { // not required
			continue
		}

		if m.MemberPorts[i] != nil {
			if err := m.MemberPorts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "member_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var portLagTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["multimode_lacp","multimode","singlemode"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portLagTypeModePropEnum = append(portLagTypeModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// PortLag
	// PortLag
	// mode
	// Mode
	// multimode_lacp
	// END DEBUGGING
	// PortLagModeMultimodeLacp captures enum value "multimode_lacp"
	PortLagModeMultimodeLacp string = "multimode_lacp"

	// BEGIN DEBUGGING
	// PortLag
	// PortLag
	// mode
	// Mode
	// multimode
	// END DEBUGGING
	// PortLagModeMultimode captures enum value "multimode"
	PortLagModeMultimode string = "multimode"

	// BEGIN DEBUGGING
	// PortLag
	// PortLag
	// mode
	// Mode
	// singlemode
	// END DEBUGGING
	// PortLagModeSinglemode captures enum value "singlemode"
	PortLagModeSinglemode string = "singlemode"
)

// prop value enum
func (m *PortLag) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portLagTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PortLag) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("lag"+"."+"mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this port lag based on the context it is used
func (m *PortLag) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActivePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemberPorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLag) contextValidateActivePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lag"+"."+"active_ports", "body", []*PortLagActivePortsItems0(m.ActivePorts)); err != nil {
		return err
	}

	for i := 0; i < len(m.ActivePorts); i++ {

		if m.ActivePorts[i] != nil {
			if err := m.ActivePorts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "active_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PortLag) contextValidateMemberPorts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MemberPorts); i++ {

		if m.MemberPorts[i] != nil {
			if err := m.MemberPorts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "member_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLag) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLag) UnmarshalBinary(b []byte) error {
	var res PortLag
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagActivePortsItems0 port lag active ports items0
//
// swagger:model PortLagActivePortsItems0
type PortLagActivePortsItems0 struct {

	// links
	Links *PortLagActivePortsItems0Links `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *PortLagActivePortsItems0Node `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port lag active ports items0
func (m *PortLagActivePortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagActivePortsItems0) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag active ports items0 based on the context it is used
func (m *PortLagActivePortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagActivePortsItems0) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagActivePortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagActivePortsItems0) UnmarshalBinary(b []byte) error {
	var res PortLagActivePortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagActivePortsItems0Links port lag active ports items0 links
//
// swagger:model PortLagActivePortsItems0Links
type PortLagActivePortsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port lag active ports items0 links
func (m *PortLagActivePortsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag active ports items0 links based on the context it is used
func (m *PortLagActivePortsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagActivePortsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagActivePortsItems0Links) UnmarshalBinary(b []byte) error {
	var res PortLagActivePortsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagActivePortsItems0Node port lag active ports items0 node
//
// swagger:model PortLagActivePortsItems0Node
type PortLagActivePortsItems0Node struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this port lag active ports items0 node
func (m *PortLagActivePortsItems0Node) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port lag active ports items0 node based on context it is used
func (m *PortLagActivePortsItems0Node) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortLagActivePortsItems0Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagActivePortsItems0Node) UnmarshalBinary(b []byte) error {
	var res PortLagActivePortsItems0Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagMemberPortsItems0 port lag member ports items0
//
// swagger:model PortLagMemberPortsItems0
type PortLagMemberPortsItems0 struct {

	// links
	Links *PortLagMemberPortsItems0Links `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *PortLagMemberPortsItems0Node `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port lag member ports items0
func (m *PortLagMemberPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagMemberPortsItems0) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag member ports items0 based on the context it is used
func (m *PortLagMemberPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagMemberPortsItems0) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagMemberPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagMemberPortsItems0) UnmarshalBinary(b []byte) error {
	var res PortLagMemberPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagMemberPortsItems0Links port lag member ports items0 links
//
// swagger:model PortLagMemberPortsItems0Links
type PortLagMemberPortsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port lag member ports items0 links
func (m *PortLagMemberPortsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag member ports items0 links based on the context it is used
func (m *PortLagMemberPortsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Links) UnmarshalBinary(b []byte) error {
	var res PortLagMemberPortsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagMemberPortsItems0Node port lag member ports items0 node
//
// swagger:model PortLagMemberPortsItems0Node
type PortLagMemberPortsItems0Node struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this port lag member ports items0 node
func (m *PortLagMemberPortsItems0Node) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port lag member ports items0 node based on context it is used
func (m *PortLagMemberPortsItems0Node) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Node) UnmarshalBinary(b []byte) error {
	var res PortLagMemberPortsItems0Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLinks port links
//
// swagger:model PortLinks
type PortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port links
func (m *PortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port links based on the context it is used
func (m *PortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLinks) UnmarshalBinary(b []byte) error {
	var res PortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortMetric The most recent sample of I/O metrics for the port.
//
// swagger:model PortMetric
type PortMetric struct {

	// links
	Links *PortMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *PortMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this port metric
func (m *PortMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var portMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portMetricTypeDurationPropEnum = append(portMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// PortMetricDurationPT15S captures enum value "PT15S"
	PortMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// PortMetricDurationPT4M captures enum value "PT4M"
	PortMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// PortMetricDurationPT30M captures enum value "PT30M"
	PortMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// PortMetricDurationPT2H captures enum value "PT2H"
	PortMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// PortMetricDurationP1D captures enum value "P1D"
	PortMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// PortMetricDurationPT5M captures enum value "PT5M"
	PortMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *PortMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PortMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

var portMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portMetricTypeStatusPropEnum = append(portMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// PortMetricStatusOk captures enum value "ok"
	PortMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// PortMetricStatusError captures enum value "error"
	PortMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// PortMetricStatusPartialNoData captures enum value "partial_no_data"
	PortMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// PortMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	PortMetricStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// PortMetricStatusPartialNoResponse captures enum value "partial_no_response"
	PortMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// PortMetricStatusPartialOtherError captures enum value "partial_other_error"
	PortMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// PortMetricStatusNegativeDelta captures enum value "negative_delta"
	PortMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// PortMetricStatusBackfilledData captures enum value "backfilled_data"
	PortMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// PortMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	PortMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// PortMetric
	// PortMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// PortMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	PortMetricStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *PortMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PortMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *PortMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *PortMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this port metric based on the context it is used
func (m *PortMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortMetric) UnmarshalBinary(b []byte) error {
	var res PortMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortMetricLinks port metric links
//
// swagger:model PortMetricLinks
type PortMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port metric links
func (m *PortMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port metric links based on the context it is used
func (m *PortMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortMetricLinks) UnmarshalBinary(b []byte) error {
	var res PortMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortMetricThroughput The rate of throughput bytes per second observed at the interface.
//
// swagger:model PortMetricThroughput
type PortMetricThroughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this port metric throughput
func (m *PortMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port metric throughput based on context it is used
func (m *PortMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortMetricThroughput) UnmarshalBinary(b []byte) error {
	var res PortMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortNode port node
//
// swagger:model PortNode
type PortNode struct {

	// links
	Links *PortNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port node
func (m *PortNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port node based on the context it is used
func (m *PortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortNode) UnmarshalBinary(b []byte) error {
	var res PortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortNodeLinks port node links
//
// swagger:model PortNodeLinks
type PortNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port node links
func (m *PortNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port node links based on the context it is used
func (m *PortNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortNodeLinks) UnmarshalBinary(b []byte) error {
	var res PortNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortReachableBroadcastDomainsItems0 Broadcast domain UUID along with a readable name. Either the UUID or both names may be provided on input.
//
// swagger:model PortReachableBroadcastDomainsItems0
type PortReachableBroadcastDomainsItems0 struct {

	// links
	Links *PortReachableBroadcastDomainsItems0Links `json:"_links,omitempty"`

	// ipspace
	Ipspace *PortReachableBroadcastDomainsItems0Ipspace `json:"ipspace,omitempty"`

	// Name of the broadcast domain, scoped to its IPspace
	// Example: bd1
	Name string `json:"name,omitempty"`

	// Broadcast domain UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port reachable broadcast domains items0
func (m *PortReachableBroadcastDomainsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortReachableBroadcastDomainsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortReachableBroadcastDomainsItems0) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port reachable broadcast domains items0 based on the context it is used
func (m *PortReachableBroadcastDomainsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortReachableBroadcastDomainsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortReachableBroadcastDomainsItems0) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortReachableBroadcastDomainsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortReachableBroadcastDomainsItems0) UnmarshalBinary(b []byte) error {
	var res PortReachableBroadcastDomainsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortReachableBroadcastDomainsItems0Ipspace port reachable broadcast domains items0 ipspace
//
// swagger:model PortReachableBroadcastDomainsItems0Ipspace
type PortReachableBroadcastDomainsItems0Ipspace struct {

	// Name of the broadcast domain's IPspace
	// Example: ipspace1
	Name string `json:"name,omitempty"`
}

// Validate validates this port reachable broadcast domains items0 ipspace
func (m *PortReachableBroadcastDomainsItems0Ipspace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port reachable broadcast domains items0 ipspace based on context it is used
func (m *PortReachableBroadcastDomainsItems0Ipspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortReachableBroadcastDomainsItems0Ipspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortReachableBroadcastDomainsItems0Ipspace) UnmarshalBinary(b []byte) error {
	var res PortReachableBroadcastDomainsItems0Ipspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortReachableBroadcastDomainsItems0Links port reachable broadcast domains items0 links
//
// swagger:model PortReachableBroadcastDomainsItems0Links
type PortReachableBroadcastDomainsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port reachable broadcast domains items0 links
func (m *PortReachableBroadcastDomainsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortReachableBroadcastDomainsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port reachable broadcast domains items0 links based on the context it is used
func (m *PortReachableBroadcastDomainsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortReachableBroadcastDomainsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortReachableBroadcastDomainsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortReachableBroadcastDomainsItems0Links) UnmarshalBinary(b []byte) error {
	var res PortReachableBroadcastDomainsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortStatisticsType The real time I/O statistics for the port.
//
// swagger:model PortStatisticsType
type PortStatisticsType struct {

	// device
	Device *PortStatisticsTypeDeviceType `json:"device,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *PortStatisticsTypeThroughputRawType `json:"throughput_raw,omitempty"`

	// The timestamp of the throughput_raw performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this port statistics type
func (m *PortStatisticsType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortStatisticsType) validateDevice(formats strfmt.Registry) error {
	if swag.IsZero(m.Device) { // not required
		return nil
	}

	if m.Device != nil {
		if err := m.Device.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "device")
			}
			return err
		}
	}

	return nil
}

var portStatisticsTypeTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portStatisticsTypeTypeStatusPropEnum = append(portStatisticsTypeTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// ok
	// END DEBUGGING
	// PortStatisticsTypeStatusOk captures enum value "ok"
	PortStatisticsTypeStatusOk string = "ok"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// error
	// END DEBUGGING
	// PortStatisticsTypeStatusError captures enum value "error"
	PortStatisticsTypeStatusError string = "error"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// PortStatisticsTypeStatusPartialNoData captures enum value "partial_no_data"
	PortStatisticsTypeStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// PortStatisticsTypeStatusPartialNoUUID captures enum value "partial_no_uuid"
	PortStatisticsTypeStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// PortStatisticsTypeStatusPartialNoResponse captures enum value "partial_no_response"
	PortStatisticsTypeStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// PortStatisticsTypeStatusPartialOtherError captures enum value "partial_other_error"
	PortStatisticsTypeStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// PortStatisticsTypeStatusNegativeDelta captures enum value "negative_delta"
	PortStatisticsTypeStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// PortStatisticsTypeStatusBackfilledData captures enum value "backfilled_data"
	PortStatisticsTypeStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// PortStatisticsTypeStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	PortStatisticsTypeStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// PortStatisticsType
	// PortStatisticsType
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// PortStatisticsTypeStatusInconsistentOldData captures enum value "inconsistent_old_data"
	PortStatisticsTypeStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *PortStatisticsType) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portStatisticsTypeTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PortStatisticsType) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *PortStatisticsType) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *PortStatisticsType) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this port statistics type based on the context it is used
func (m *PortStatisticsType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortStatisticsType) contextValidateDevice(ctx context.Context, formats strfmt.Registry) error {

	if m.Device != nil {
		if err := m.Device.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "device")
			}
			return err
		}
	}

	return nil
}

func (m *PortStatisticsType) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortStatisticsType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortStatisticsType) UnmarshalBinary(b []byte) error {
	var res PortStatisticsType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortStatisticsTypeDeviceType Device-related counters for the port object. These counters are applicable at the lowest layer of the networking stack. These values can be used to calculate both transmit and receive packet and error rates by comparing two samples taken at different times and calculating the increase in counter value divided by the elapsed time between the two samples.
//
// swagger:model PortStatisticsTypeDeviceType
type PortStatisticsTypeDeviceType struct {

	// The number of link state changes from up to down seen on the device.
	// Example: 3
	LinkDownCountRaw int64 `json:"link_down_count_raw,omitempty"`

	// receive raw
	ReceiveRaw *PortStatisticsTypeDeviceTypeReceiveRawType `json:"receive_raw,omitempty"`

	// The timestamp when the device specific counters were collected.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`

	// transmit raw
	TransmitRaw *PortStatisticsTypeDeviceTypeTransmitRawType `json:"transmit_raw,omitempty"`
}

// Validate validates this port statistics type device type
func (m *PortStatisticsTypeDeviceType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateReceiveRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransmitRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortStatisticsTypeDeviceType) validateReceiveRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ReceiveRaw) { // not required
		return nil
	}

	if m.ReceiveRaw != nil {
		if err := m.ReceiveRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "device" + "." + "receive_raw")
			}
			return err
		}
	}

	return nil
}

func (m *PortStatisticsTypeDeviceType) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"device"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PortStatisticsTypeDeviceType) validateTransmitRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.TransmitRaw) { // not required
		return nil
	}

	if m.TransmitRaw != nil {
		if err := m.TransmitRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "device" + "." + "transmit_raw")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port statistics type device type based on the context it is used
func (m *PortStatisticsTypeDeviceType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReceiveRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransmitRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortStatisticsTypeDeviceType) contextValidateReceiveRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ReceiveRaw != nil {
		if err := m.ReceiveRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "device" + "." + "receive_raw")
			}
			return err
		}
	}

	return nil
}

func (m *PortStatisticsTypeDeviceType) contextValidateTransmitRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.TransmitRaw != nil {
		if err := m.TransmitRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "device" + "." + "transmit_raw")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortStatisticsTypeDeviceType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortStatisticsTypeDeviceType) UnmarshalBinary(b []byte) error {
	var res PortStatisticsTypeDeviceType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortStatisticsTypeDeviceTypeReceiveRawType Packet receive counters for the Ethernet port.
//
// swagger:model PortStatisticsTypeDeviceTypeReceiveRawType
type PortStatisticsTypeDeviceTypeReceiveRawType struct {

	// Total number of discarded packets.
	// Example: 100
	Discards int64 `json:"discards,omitempty"`

	// Number of packet errors.
	// Example: 200
	Errors int64 `json:"errors,omitempty"`

	// Total packet count.
	// Example: 500
	Packets int64 `json:"packets,omitempty"`
}

// Validate validates this port statistics type device type receive raw type
func (m *PortStatisticsTypeDeviceTypeReceiveRawType) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port statistics type device type receive raw type based on context it is used
func (m *PortStatisticsTypeDeviceTypeReceiveRawType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortStatisticsTypeDeviceTypeReceiveRawType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortStatisticsTypeDeviceTypeReceiveRawType) UnmarshalBinary(b []byte) error {
	var res PortStatisticsTypeDeviceTypeReceiveRawType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortStatisticsTypeDeviceTypeTransmitRawType Packet transmit counters for the Ethernet port.
//
// swagger:model PortStatisticsTypeDeviceTypeTransmitRawType
type PortStatisticsTypeDeviceTypeTransmitRawType struct {

	// Total number of discarded packets.
	// Example: 100
	Discards int64 `json:"discards,omitempty"`

	// Number of packet errors.
	// Example: 200
	Errors int64 `json:"errors,omitempty"`

	// Total packet count.
	// Example: 500
	Packets int64 `json:"packets,omitempty"`
}

// Validate validates this port statistics type device type transmit raw type
func (m *PortStatisticsTypeDeviceTypeTransmitRawType) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port statistics type device type transmit raw type based on context it is used
func (m *PortStatisticsTypeDeviceTypeTransmitRawType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortStatisticsTypeDeviceTypeTransmitRawType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortStatisticsTypeDeviceTypeTransmitRawType) UnmarshalBinary(b []byte) error {
	var res PortStatisticsTypeDeviceTypeTransmitRawType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortStatisticsTypeThroughputRawType Throughput bytes observed at the port object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model PortStatisticsTypeThroughputRawType
type PortStatisticsTypeThroughputRawType struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this port statistics type throughput raw type
func (m *PortStatisticsTypeThroughputRawType) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port statistics type throughput raw type based on context it is used
func (m *PortStatisticsTypeThroughputRawType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortStatisticsTypeThroughputRawType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortStatisticsTypeThroughputRawType) UnmarshalBinary(b []byte) error {
	var res PortStatisticsTypeThroughputRawType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlan port vlan
//
// swagger:model PortVlan
type PortVlan struct {

	// base port
	BasePort *PortVlanBasePort `json:"base_port,omitempty"`

	// VLAN ID
	// Example: 100
	// Maximum: 4095
	// Minimum: 0
	Tag *int64 `json:"tag,omitempty"`
}

// Validate validates this port vlan
func (m *PortVlan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBasePort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTag(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlan) validateBasePort(formats strfmt.Registry) error {
	if swag.IsZero(m.BasePort) { // not required
		return nil
	}

	if m.BasePort != nil {
		if err := m.BasePort.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port")
			}
			return err
		}
	}

	return nil
}

func (m *PortVlan) validateTag(formats strfmt.Registry) error {
	if swag.IsZero(m.Tag) { // not required
		return nil
	}

	if err := validate.MinimumInt("vlan"+"."+"tag", "body", *m.Tag, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vlan"+"."+"tag", "body", *m.Tag, 4095, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this port vlan based on the context it is used
func (m *PortVlan) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBasePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlan) contextValidateBasePort(ctx context.Context, formats strfmt.Registry) error {

	if m.BasePort != nil {
		if err := m.BasePort.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortVlan) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlan) UnmarshalBinary(b []byte) error {
	var res PortVlan
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlanBasePort port vlan base port
//
// swagger:model PortVlanBasePort
type PortVlanBasePort struct {

	// links
	Links *PortVlanBasePortLinks `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *PortVlanBasePortNode `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port vlan base port
func (m *PortVlanBasePort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortVlanBasePort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port vlan base port based on the context it is used
func (m *PortVlanBasePort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortVlanBasePort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortVlanBasePort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlanBasePort) UnmarshalBinary(b []byte) error {
	var res PortVlanBasePort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlanBasePortLinks port vlan base port links
//
// swagger:model PortVlanBasePortLinks
type PortVlanBasePortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port vlan base port links
func (m *PortVlanBasePortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port vlan base port links based on the context it is used
func (m *PortVlanBasePortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortVlanBasePortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlanBasePortLinks) UnmarshalBinary(b []byte) error {
	var res PortVlanBasePortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlanBasePortNode port vlan base port node
//
// swagger:model PortVlanBasePortNode
type PortVlanBasePortNode struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this port vlan base port node
func (m *PortVlanBasePortNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port vlan base port node based on context it is used
func (m *PortVlanBasePortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortVlanBasePortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlanBasePortNode) UnmarshalBinary(b []byte) error {
	var res PortVlanBasePortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

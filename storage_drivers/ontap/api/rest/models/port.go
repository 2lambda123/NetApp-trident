// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Port port
//
// swagger:model port
type Port struct {

	// links
	Links *PortLinks `json:"_links,omitempty"`

	// broadcast domain
	BroadcastDomain *PortBroadcastDomain `json:"broadcast_domain,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// lag
	Lag *PortLag `json:"lag,omitempty"`

	// mac address
	// Example: 01:02:03:04:05:06
	// Read Only: true
	MacAddress string `json:"mac_address,omitempty"`

	// MTU of the port in bytes. Set by broadcast domain.
	// Example: 1500
	// Read Only: true
	// Minimum: 68
	Mtu int64 `json:"mtu,omitempty"`

	// Portname, such as e0a, e1b-100 (VLAN on ethernet), a0c (LAG/ifgrp), a0d-200 (vlan on LAG/ifgrp)
	// Example: e1b
	// Read Only: true
	Name string `json:"name,omitempty"`

	// node
	Node *PortNode `json:"node,omitempty"`

	// Link speed in Mbps
	// Example: 1000
	// Read Only: true
	Speed int64 `json:"speed,omitempty"`

	// Operational state of the port.
	// Read Only: true
	// Enum: [up down]
	State string `json:"state,omitempty"`

	// Type of physical or virtual port
	// Enum: [vlan physical lag]
	Type string `json:"type,omitempty"`

	// Port UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// vlan
	Vlan *PortVlan `json:"vlan,omitempty"`
}

// Validate validates this port
func (m *Port) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBroadcastDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMtu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlan(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Port) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Port) validateBroadcastDomain(formats strfmt.Registry) error {
	if swag.IsZero(m.BroadcastDomain) { // not required
		return nil
	}

	if m.BroadcastDomain != nil {
		if err := m.BroadcastDomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain")
			}
			return err
		}
	}

	return nil
}

func (m *Port) validateLag(formats strfmt.Registry) error {
	if swag.IsZero(m.Lag) { // not required
		return nil
	}

	if m.Lag != nil {
		if err := m.Lag.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lag")
			}
			return err
		}
	}

	return nil
}

func (m *Port) validateMtu(formats strfmt.Registry) error {
	if swag.IsZero(m.Mtu) { // not required
		return nil
	}

	if err := validate.MinimumInt("mtu", "body", m.Mtu, 68, false); err != nil {
		return err
	}

	return nil
}

func (m *Port) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

var portTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portTypeStatePropEnum = append(portTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// port
	// Port
	// state
	// State
	// up
	// END RIPPY DEBUGGING
	// PortStateUp captures enum value "up"
	PortStateUp string = "up"

	// BEGIN RIPPY DEBUGGING
	// port
	// Port
	// state
	// State
	// down
	// END RIPPY DEBUGGING
	// PortStateDown captures enum value "down"
	PortStateDown string = "down"
)

// prop value enum
func (m *Port) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Port) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var portTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["vlan","physical","lag"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portTypeTypePropEnum = append(portTypeTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// port
	// Port
	// type
	// Type
	// vlan
	// END RIPPY DEBUGGING
	// PortTypeVlan captures enum value "vlan"
	PortTypeVlan string = "vlan"

	// BEGIN RIPPY DEBUGGING
	// port
	// Port
	// type
	// Type
	// physical
	// END RIPPY DEBUGGING
	// PortTypePhysical captures enum value "physical"
	PortTypePhysical string = "physical"

	// BEGIN RIPPY DEBUGGING
	// port
	// Port
	// type
	// Type
	// lag
	// END RIPPY DEBUGGING
	// PortTypeLag captures enum value "lag"
	PortTypeLag string = "lag"
)

// prop value enum
func (m *Port) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Port) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Port) validateVlan(formats strfmt.Registry) error {
	if swag.IsZero(m.Vlan) { // not required
		return nil
	}

	if m.Vlan != nil {
		if err := m.Vlan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port based on the context it is used
func (m *Port) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBroadcastDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLag(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMtu(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpeed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVlan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Port) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateBroadcastDomain(ctx context.Context, formats strfmt.Registry) error {

	if m.BroadcastDomain != nil {
		if err := m.BroadcastDomain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateLag(ctx context.Context, formats strfmt.Registry) error {

	if m.Lag != nil {
		if err := m.Lag.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lag")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateMacAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mac_address", "body", string(m.MacAddress)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateMtu(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mtu", "body", int64(m.Mtu)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *Port) contextValidateSpeed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "speed", "body", int64(m.Speed)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *Port) contextValidateVlan(ctx context.Context, formats strfmt.Registry) error {

	if m.Vlan != nil {
		if err := m.Vlan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Port) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Port) UnmarshalBinary(b []byte) error {
	var res Port
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortBroadcastDomain Broadcast domain UUID along with a readable name. Either the UUID or both names may be provided on input.
//
// swagger:model PortBroadcastDomain
type PortBroadcastDomain struct {

	// links
	Links *PortBroadcastDomainLinks `json:"_links,omitempty"`

	// ipspace
	Ipspace *PortBroadcastDomainIpspace `json:"ipspace,omitempty"`

	// Name of the broadcast domain, scoped to its IPspace
	// Example: bd1
	Name string `json:"name,omitempty"`

	// Broadcast domain UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port broadcast domain
func (m *PortBroadcastDomain) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomain) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortBroadcastDomain) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "ipspace")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port broadcast domain based on the context it is used
func (m *PortBroadcastDomain) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomain) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortBroadcastDomain) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "ipspace")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortBroadcastDomain) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortBroadcastDomain) UnmarshalBinary(b []byte) error {
	var res PortBroadcastDomain
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortBroadcastDomainIpspace port broadcast domain ipspace
//
// swagger:model PortBroadcastDomainIpspace
type PortBroadcastDomainIpspace struct {

	// Name of the broadcast domain's IPspace
	// Example: ipspace1
	Name string `json:"name,omitempty"`
}

// Validate validates this port broadcast domain ipspace
func (m *PortBroadcastDomainIpspace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port broadcast domain ipspace based on context it is used
func (m *PortBroadcastDomainIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortBroadcastDomainIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortBroadcastDomainIpspace) UnmarshalBinary(b []byte) error {
	var res PortBroadcastDomainIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortBroadcastDomainLinks port broadcast domain links
//
// swagger:model PortBroadcastDomainLinks
type PortBroadcastDomainLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port broadcast domain links
func (m *PortBroadcastDomainLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomainLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port broadcast domain links based on the context it is used
func (m *PortBroadcastDomainLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortBroadcastDomainLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("broadcast_domain" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortBroadcastDomainLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortBroadcastDomainLinks) UnmarshalBinary(b []byte) error {
	var res PortBroadcastDomainLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLag port lag
//
// swagger:model PortLag
type PortLag struct {

	// Active ports of a LAG (ifgrp). (Some member ports may be inactive.)
	// Read Only: true
	ActivePorts []*PortLagActivePortsItems0 `json:"active_ports,omitempty"`

	// Policy for mapping flows to ports for outbound packets through a LAG (ifgrp).
	// Enum: [port ip mac sequential]
	DistributionPolicy string `json:"distribution_policy,omitempty"`

	// member ports
	MemberPorts []*PortLagMemberPortsItems0 `json:"member_ports,omitempty"`

	// Determines how the ports interact with the switch.
	// Enum: [multimode_lacp multimode singlemode]
	Mode string `json:"mode,omitempty"`
}

// Validate validates this port lag
func (m *PortLag) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActivePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDistributionPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemberPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLag) validateActivePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.ActivePorts) { // not required
		return nil
	}

	for i := 0; i < len(m.ActivePorts); i++ {
		if swag.IsZero(m.ActivePorts[i]) { // not required
			continue
		}

		if m.ActivePorts[i] != nil {
			if err := m.ActivePorts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "active_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var portLagTypeDistributionPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["port","ip","mac","sequential"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portLagTypeDistributionPolicyPropEnum = append(portLagTypeDistributionPolicyPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// port
	// END RIPPY DEBUGGING
	// PortLagDistributionPolicyPort captures enum value "port"
	PortLagDistributionPolicyPort string = "port"

	// BEGIN RIPPY DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// ip
	// END RIPPY DEBUGGING
	// PortLagDistributionPolicyIP captures enum value "ip"
	PortLagDistributionPolicyIP string = "ip"

	// BEGIN RIPPY DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// mac
	// END RIPPY DEBUGGING
	// PortLagDistributionPolicyMac captures enum value "mac"
	PortLagDistributionPolicyMac string = "mac"

	// BEGIN RIPPY DEBUGGING
	// PortLag
	// PortLag
	// distribution_policy
	// DistributionPolicy
	// sequential
	// END RIPPY DEBUGGING
	// PortLagDistributionPolicySequential captures enum value "sequential"
	PortLagDistributionPolicySequential string = "sequential"
)

// prop value enum
func (m *PortLag) validateDistributionPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portLagTypeDistributionPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PortLag) validateDistributionPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.DistributionPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateDistributionPolicyEnum("lag"+"."+"distribution_policy", "body", m.DistributionPolicy); err != nil {
		return err
	}

	return nil
}

func (m *PortLag) validateMemberPorts(formats strfmt.Registry) error {
	if swag.IsZero(m.MemberPorts) { // not required
		return nil
	}

	for i := 0; i < len(m.MemberPorts); i++ {
		if swag.IsZero(m.MemberPorts[i]) { // not required
			continue
		}

		if m.MemberPorts[i] != nil {
			if err := m.MemberPorts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "member_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var portLagTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["multimode_lacp","multimode","singlemode"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		portLagTypeModePropEnum = append(portLagTypeModePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// PortLag
	// PortLag
	// mode
	// Mode
	// multimode_lacp
	// END RIPPY DEBUGGING
	// PortLagModeMultimodeLacp captures enum value "multimode_lacp"
	PortLagModeMultimodeLacp string = "multimode_lacp"

	// BEGIN RIPPY DEBUGGING
	// PortLag
	// PortLag
	// mode
	// Mode
	// multimode
	// END RIPPY DEBUGGING
	// PortLagModeMultimode captures enum value "multimode"
	PortLagModeMultimode string = "multimode"

	// BEGIN RIPPY DEBUGGING
	// PortLag
	// PortLag
	// mode
	// Mode
	// singlemode
	// END RIPPY DEBUGGING
	// PortLagModeSinglemode captures enum value "singlemode"
	PortLagModeSinglemode string = "singlemode"
)

// prop value enum
func (m *PortLag) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, portLagTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PortLag) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("lag"+"."+"mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this port lag based on the context it is used
func (m *PortLag) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActivePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemberPorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLag) contextValidateActivePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lag"+"."+"active_ports", "body", []*PortLagActivePortsItems0(m.ActivePorts)); err != nil {
		return err
	}

	for i := 0; i < len(m.ActivePorts); i++ {

		if m.ActivePorts[i] != nil {
			if err := m.ActivePorts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "active_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PortLag) contextValidateMemberPorts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MemberPorts); i++ {

		if m.MemberPorts[i] != nil {
			if err := m.MemberPorts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lag" + "." + "member_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLag) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLag) UnmarshalBinary(b []byte) error {
	var res PortLag
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagActivePortsItems0 Port UUID along with readable names. Either the UUID or both names may be supplied on input.
//
// swagger:model PortLagActivePortsItems0
type PortLagActivePortsItems0 struct {

	// links
	Links *PortLagActivePortsItems0Links `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *PortLagActivePortsItems0Node `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port lag active ports items0
func (m *PortLagActivePortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagActivePortsItems0) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag active ports items0 based on the context it is used
func (m *PortLagActivePortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagActivePortsItems0) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagActivePortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagActivePortsItems0) UnmarshalBinary(b []byte) error {
	var res PortLagActivePortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagActivePortsItems0Links port lag active ports items0 links
//
// swagger:model PortLagActivePortsItems0Links
type PortLagActivePortsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port lag active ports items0 links
func (m *PortLagActivePortsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag active ports items0 links based on the context it is used
func (m *PortLagActivePortsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagActivePortsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagActivePortsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagActivePortsItems0Links) UnmarshalBinary(b []byte) error {
	var res PortLagActivePortsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagActivePortsItems0Node port lag active ports items0 node
//
// swagger:model PortLagActivePortsItems0Node
type PortLagActivePortsItems0Node struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this port lag active ports items0 node
func (m *PortLagActivePortsItems0Node) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port lag active ports items0 node based on context it is used
func (m *PortLagActivePortsItems0Node) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortLagActivePortsItems0Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagActivePortsItems0Node) UnmarshalBinary(b []byte) error {
	var res PortLagActivePortsItems0Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagMemberPortsItems0 Port UUID along with readable names. Either the UUID or both names may be supplied on input.
//
// swagger:model PortLagMemberPortsItems0
type PortLagMemberPortsItems0 struct {

	// links
	Links *PortLagMemberPortsItems0Links `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *PortLagMemberPortsItems0Node `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port lag member ports items0
func (m *PortLagMemberPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagMemberPortsItems0) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag member ports items0 based on the context it is used
func (m *PortLagMemberPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortLagMemberPortsItems0) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagMemberPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagMemberPortsItems0) UnmarshalBinary(b []byte) error {
	var res PortLagMemberPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagMemberPortsItems0Links port lag member ports items0 links
//
// swagger:model PortLagMemberPortsItems0Links
type PortLagMemberPortsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port lag member ports items0 links
func (m *PortLagMemberPortsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port lag member ports items0 links based on the context it is used
func (m *PortLagMemberPortsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLagMemberPortsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Links) UnmarshalBinary(b []byte) error {
	var res PortLagMemberPortsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLagMemberPortsItems0Node port lag member ports items0 node
//
// swagger:model PortLagMemberPortsItems0Node
type PortLagMemberPortsItems0Node struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this port lag member ports items0 node
func (m *PortLagMemberPortsItems0Node) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port lag member ports items0 node based on context it is used
func (m *PortLagMemberPortsItems0Node) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLagMemberPortsItems0Node) UnmarshalBinary(b []byte) error {
	var res PortLagMemberPortsItems0Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortLinks port links
//
// swagger:model PortLinks
type PortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port links
func (m *PortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port links based on the context it is used
func (m *PortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortLinks) UnmarshalBinary(b []byte) error {
	var res PortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortNode port node
//
// swagger:model PortNode
type PortNode struct {

	// links
	Links *PortNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port node
func (m *PortNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port node based on the context it is used
func (m *PortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortNode) UnmarshalBinary(b []byte) error {
	var res PortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortNodeLinks port node links
//
// swagger:model PortNodeLinks
type PortNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port node links
func (m *PortNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port node links based on the context it is used
func (m *PortNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortNodeLinks) UnmarshalBinary(b []byte) error {
	var res PortNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlan port vlan
//
// swagger:model PortVlan
type PortVlan struct {

	// base port
	BasePort *PortVlanBasePort `json:"base_port,omitempty"`

	// VLAN ID
	// Example: 100
	// Maximum: 4095
	// Minimum: 0
	Tag *int64 `json:"tag,omitempty"`
}

// Validate validates this port vlan
func (m *PortVlan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBasePort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTag(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlan) validateBasePort(formats strfmt.Registry) error {
	if swag.IsZero(m.BasePort) { // not required
		return nil
	}

	if m.BasePort != nil {
		if err := m.BasePort.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port")
			}
			return err
		}
	}

	return nil
}

func (m *PortVlan) validateTag(formats strfmt.Registry) error {
	if swag.IsZero(m.Tag) { // not required
		return nil
	}

	if err := validate.MinimumInt("vlan"+"."+"tag", "body", *m.Tag, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vlan"+"."+"tag", "body", *m.Tag, 4095, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this port vlan based on the context it is used
func (m *PortVlan) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBasePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlan) contextValidateBasePort(ctx context.Context, formats strfmt.Registry) error {

	if m.BasePort != nil {
		if err := m.BasePort.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortVlan) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlan) UnmarshalBinary(b []byte) error {
	var res PortVlan
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlanBasePort Port UUID along with readable names. Either the UUID or both names may be supplied on input.
//
// swagger:model PortVlanBasePort
type PortVlanBasePort struct {

	// links
	Links *PortVlanBasePortLinks `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *PortVlanBasePortNode `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this port vlan base port
func (m *PortVlanBasePort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortVlanBasePort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port vlan base port based on the context it is used
func (m *PortVlanBasePort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PortVlanBasePort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortVlanBasePort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlanBasePort) UnmarshalBinary(b []byte) error {
	var res PortVlanBasePort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlanBasePortLinks port vlan base port links
//
// swagger:model PortVlanBasePortLinks
type PortVlanBasePortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this port vlan base port links
func (m *PortVlanBasePortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this port vlan base port links based on the context it is used
func (m *PortVlanBasePortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PortVlanBasePortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlan" + "." + "base_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PortVlanBasePortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlanBasePortLinks) UnmarshalBinary(b []byte) error {
	var res PortVlanBasePortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PortVlanBasePortNode port vlan base port node
//
// swagger:model PortVlanBasePortNode
type PortVlanBasePortNode struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this port vlan base port node
func (m *PortVlanBasePortNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this port vlan base port node based on context it is used
func (m *PortVlanBasePortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PortVlanBasePortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PortVlanBasePortNode) UnmarshalBinary(b []byte) error {
	var res PortVlanBasePortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Svm svm
//
// swagger:model svm
type Svm struct {

	// links
	Links *SvmLinks `json:"_links,omitempty"`

	// List of allowed aggregates for SVM volumes. An administrator is allowed to create volumes on these aggregates.
	Aggregates []*SvmAggregatesItems0 `json:"aggregates,omitempty"`

	// This property is true when the administrator has delegated the aggregates for the SVM volumes.
	// Read Only: true
	AggregatesDelegated *bool `json:"aggregates_delegated,omitempty"`

	// certificate
	Certificate *SvmCertificate `json:"certificate,omitempty"`

	// cifs
	Cifs *SvmCifs `json:"cifs,omitempty"`

	// Comment
	// Max Length: 255
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// dns
	DNS *SvmDNS `json:"dns,omitempty"`

	// FC Interface for the SVM
	FcInterfaces []*FcInterfaceSvm `json:"fc_interfaces,omitempty"`

	// fcp
	Fcp *SvmFcp `json:"fcp,omitempty"`

	// IP interfaces for the SVM
	IPInterfaces []*IPInterfaceSvm `json:"ip_interfaces,omitempty"`

	// ipspace
	Ipspace *SvmIpspace `json:"ipspace,omitempty"`

	// iscsi
	Iscsi *SvmIscsi `json:"iscsi,omitempty"`

	// Default volume language code. UTF-8 encoded languages are valid in POST or PATCH. Non UTF-8 language encodings are for backward compatibility and are not valid input for POST and PATCH requests.
	// Example: c.utf_8
	// Enum: [c da de en en_us es fi fr he it ja ja_jp.pck ko no nl pt sv zh zh.gbk zh_tw zh_tw.big5 c.utf_8 ar ar.utf_8 cs cs.utf_8 da.utf_8 de.utf_8 en.utf_8 en_us.utf_8 es.utf_8 fi.utf_8 fr.utf_8 he.utf_8 hr hr.utf_8 hu hu.utf_8 it.utf_8 ja.utf_8 ja_v1 ja_v1.utf_8 ja_jp.pck.utf_8 ja_jp.932 ja_jp.932.utf_8 ja_jp.pck_v2 ja_jp.pck_v2.utf_8 ko.utf_8 no.utf_8 nl.utf_8 pl pl.utf_8 pt.utf_8 ro ro.utf_8 ru ru.utf_8 sk sk.utf_8 sl sl.utf_8 sv.utf_8 tr tr.utf_8 zh.utf_8 zh.gbk.utf_8 zh_tw.utf_8 zh_tw.big5.utf_8 utf8mb4]
	Language string `json:"language,omitempty"`

	// ldap
	Ldap *SvmLdap `json:"ldap,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// nfs
	Nfs *SvmNfs `json:"nfs,omitempty"`

	// nis
	Nis *SvmNis `json:"nis,omitempty"`

	// nsswitch
	Nsswitch *SvmNsswitch `json:"nsswitch,omitempty"`

	// nvme
	Nvme *SvmNvme `json:"nvme,omitempty"`

	// Optional array of routes for the SVM
	Routes []*NetworkRouteForSvm `json:"routes,omitempty"`

	// s3
	S3 *SvmS3 `json:"s3,omitempty"`

	// snapmirror
	Snapmirror *SvmSnapmirror `json:"snapmirror,omitempty"`

	// snapshot policy
	SnapshotPolicy *SvmSnapshotPolicy `json:"snapshot_policy,omitempty"`

	// SVM State
	// Example: running
	// Enum: [starting running stopping stopped deleting]
	State string `json:"state,omitempty"`

	// SVM subtype. The SVM subtype sync_destination is created automatically when an SVM of subtype sync_source is created on the source MetroCluster cluster. A POST request with sync_destination as SVM subtype is invalid.
	// Enum: [default dp_destination sync_source sync_destination]
	Subtype string `json:"subtype,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm
func (m *Svm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCifs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFcInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFcp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIscsi(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLdap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNis(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNsswitch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNvme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapmirror(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubtype(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Svm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregates) { // not required
		return nil
	}

	for i := 0; i < len(m.Aggregates); i++ {
		if swag.IsZero(m.Aggregates[i]) { // not required
			continue
		}

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) validateCertificate(formats strfmt.Registry) error {
	if swag.IsZero(m.Certificate) { // not required
		return nil
	}

	if m.Certificate != nil {
		if err := m.Certificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateCifs(formats strfmt.Registry) error {
	if swag.IsZero(m.Cifs) { // not required
		return nil
	}

	if m.Cifs != nil {
		if err := m.Cifs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 255); err != nil {
		return err
	}

	return nil
}

func (m *Svm) validateDNS(formats strfmt.Registry) error {
	if swag.IsZero(m.DNS) { // not required
		return nil
	}

	if m.DNS != nil {
		if err := m.DNS.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateFcInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.FcInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.FcInterfaces); i++ {
		if swag.IsZero(m.FcInterfaces[i]) { // not required
			continue
		}

		if m.FcInterfaces[i] != nil {
			if err := m.FcInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fc_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) validateFcp(formats strfmt.Registry) error {
	if swag.IsZero(m.Fcp) { // not required
		return nil
	}

	if m.Fcp != nil {
		if err := m.Fcp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateIPInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.IPInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.IPInterfaces); i++ {
		if swag.IsZero(m.IPInterfaces[i]) { // not required
			continue
		}

		if m.IPInterfaces[i] != nil {
			if err := m.IPInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ip_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateIscsi(formats strfmt.Registry) error {
	if swag.IsZero(m.Iscsi) { // not required
		return nil
	}

	if m.Iscsi != nil {
		if err := m.Iscsi.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi")
			}
			return err
		}
	}

	return nil
}

var svmTypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["c","da","de","en","en_us","es","fi","fr","he","it","ja","ja_jp.pck","ko","no","nl","pt","sv","zh","zh.gbk","zh_tw","zh_tw.big5","c.utf_8","ar","ar.utf_8","cs","cs.utf_8","da.utf_8","de.utf_8","en.utf_8","en_us.utf_8","es.utf_8","fi.utf_8","fr.utf_8","he.utf_8","hr","hr.utf_8","hu","hu.utf_8","it.utf_8","ja.utf_8","ja_v1","ja_v1.utf_8","ja_jp.pck.utf_8","ja_jp.932","ja_jp.932.utf_8","ja_jp.pck_v2","ja_jp.pck_v2.utf_8","ko.utf_8","no.utf_8","nl.utf_8","pl","pl.utf_8","pt.utf_8","ro","ro.utf_8","ru","ru.utf_8","sk","sk.utf_8","sl","sl.utf_8","sv.utf_8","tr","tr.utf_8","zh.utf_8","zh.gbk.utf_8","zh_tw.utf_8","zh_tw.big5.utf_8","utf8mb4"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		svmTypeLanguagePropEnum = append(svmTypeLanguagePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// c
	// END RIPPY DEBUGGING
	// SvmLanguageC captures enum value "c"
	SvmLanguageC string = "c"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// da
	// END RIPPY DEBUGGING
	// SvmLanguageDa captures enum value "da"
	SvmLanguageDa string = "da"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// de
	// END RIPPY DEBUGGING
	// SvmLanguageDe captures enum value "de"
	SvmLanguageDe string = "de"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en
	// END RIPPY DEBUGGING
	// SvmLanguageEn captures enum value "en"
	SvmLanguageEn string = "en"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en_us
	// END RIPPY DEBUGGING
	// SvmLanguageEnUs captures enum value "en_us"
	SvmLanguageEnUs string = "en_us"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// es
	// END RIPPY DEBUGGING
	// SvmLanguageEs captures enum value "es"
	SvmLanguageEs string = "es"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fi
	// END RIPPY DEBUGGING
	// SvmLanguageFi captures enum value "fi"
	SvmLanguageFi string = "fi"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fr
	// END RIPPY DEBUGGING
	// SvmLanguageFr captures enum value "fr"
	SvmLanguageFr string = "fr"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// he
	// END RIPPY DEBUGGING
	// SvmLanguageHe captures enum value "he"
	SvmLanguageHe string = "he"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// it
	// END RIPPY DEBUGGING
	// SvmLanguageIt captures enum value "it"
	SvmLanguageIt string = "it"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja
	// END RIPPY DEBUGGING
	// SvmLanguageJa captures enum value "ja"
	SvmLanguageJa string = "ja"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck
	// END RIPPY DEBUGGING
	// SvmLanguageJaJpDotPck captures enum value "ja_jp.pck"
	SvmLanguageJaJpDotPck string = "ja_jp.pck"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ko
	// END RIPPY DEBUGGING
	// SvmLanguageKo captures enum value "ko"
	SvmLanguageKo string = "ko"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// no
	// END RIPPY DEBUGGING
	// SvmLanguageNo captures enum value "no"
	SvmLanguageNo string = "no"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// nl
	// END RIPPY DEBUGGING
	// SvmLanguageNl captures enum value "nl"
	SvmLanguageNl string = "nl"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pt
	// END RIPPY DEBUGGING
	// SvmLanguagePt captures enum value "pt"
	SvmLanguagePt string = "pt"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sv
	// END RIPPY DEBUGGING
	// SvmLanguageSv captures enum value "sv"
	SvmLanguageSv string = "sv"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh
	// END RIPPY DEBUGGING
	// SvmLanguageZh captures enum value "zh"
	SvmLanguageZh string = "zh"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh.gbk
	// END RIPPY DEBUGGING
	// SvmLanguageZhDotGbk captures enum value "zh.gbk"
	SvmLanguageZhDotGbk string = "zh.gbk"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw
	// END RIPPY DEBUGGING
	// SvmLanguageZhTw captures enum value "zh_tw"
	SvmLanguageZhTw string = "zh_tw"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw.big5
	// END RIPPY DEBUGGING
	// SvmLanguageZhTwDotBig5 captures enum value "zh_tw.big5"
	SvmLanguageZhTwDotBig5 string = "zh_tw.big5"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// c.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageCDotUTF8 captures enum value "c.utf_8"
	SvmLanguageCDotUTF8 string = "c.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ar
	// END RIPPY DEBUGGING
	// SvmLanguageAr captures enum value "ar"
	SvmLanguageAr string = "ar"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ar.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageArDotUTF8 captures enum value "ar.utf_8"
	SvmLanguageArDotUTF8 string = "ar.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// cs
	// END RIPPY DEBUGGING
	// SvmLanguageCs captures enum value "cs"
	SvmLanguageCs string = "cs"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// cs.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageCsDotUTF8 captures enum value "cs.utf_8"
	SvmLanguageCsDotUTF8 string = "cs.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// da.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageDaDotUTF8 captures enum value "da.utf_8"
	SvmLanguageDaDotUTF8 string = "da.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// de.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageDeDotUTF8 captures enum value "de.utf_8"
	SvmLanguageDeDotUTF8 string = "de.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageEnDotUTF8 captures enum value "en.utf_8"
	SvmLanguageEnDotUTF8 string = "en.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en_us.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageEnUsDotUTF8 captures enum value "en_us.utf_8"
	SvmLanguageEnUsDotUTF8 string = "en_us.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// es.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageEsDotUTF8 captures enum value "es.utf_8"
	SvmLanguageEsDotUTF8 string = "es.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fi.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageFiDotUTF8 captures enum value "fi.utf_8"
	SvmLanguageFiDotUTF8 string = "fi.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fr.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageFrDotUTF8 captures enum value "fr.utf_8"
	SvmLanguageFrDotUTF8 string = "fr.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// he.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageHeDotUTF8 captures enum value "he.utf_8"
	SvmLanguageHeDotUTF8 string = "he.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hr
	// END RIPPY DEBUGGING
	// SvmLanguageHr captures enum value "hr"
	SvmLanguageHr string = "hr"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hr.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageHrDotUTF8 captures enum value "hr.utf_8"
	SvmLanguageHrDotUTF8 string = "hr.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hu
	// END RIPPY DEBUGGING
	// SvmLanguageHu captures enum value "hu"
	SvmLanguageHu string = "hu"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hu.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageHuDotUTF8 captures enum value "hu.utf_8"
	SvmLanguageHuDotUTF8 string = "hu.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// it.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageItDotUTF8 captures enum value "it.utf_8"
	SvmLanguageItDotUTF8 string = "it.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageJaDotUTF8 captures enum value "ja.utf_8"
	SvmLanguageJaDotUTF8 string = "ja.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_v1
	// END RIPPY DEBUGGING
	// SvmLanguageJaV1 captures enum value "ja_v1"
	SvmLanguageJaV1 string = "ja_v1"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_v1.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageJaV1DotUTF8 captures enum value "ja_v1.utf_8"
	SvmLanguageJaV1DotUTF8 string = "ja_v1.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageJaJpDotPckDotUTF8 captures enum value "ja_jp.pck.utf_8"
	SvmLanguageJaJpDotPckDotUTF8 string = "ja_jp.pck.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.932
	// END RIPPY DEBUGGING
	// SvmLanguageJaJpDot932 captures enum value "ja_jp.932"
	SvmLanguageJaJpDot932 string = "ja_jp.932"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.932.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageJaJpDot932DotUTF8 captures enum value "ja_jp.932.utf_8"
	SvmLanguageJaJpDot932DotUTF8 string = "ja_jp.932.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck_v2
	// END RIPPY DEBUGGING
	// SvmLanguageJaJpDotPckV2 captures enum value "ja_jp.pck_v2"
	SvmLanguageJaJpDotPckV2 string = "ja_jp.pck_v2"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck_v2.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageJaJpDotPckV2DotUTF8 captures enum value "ja_jp.pck_v2.utf_8"
	SvmLanguageJaJpDotPckV2DotUTF8 string = "ja_jp.pck_v2.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ko.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageKoDotUTF8 captures enum value "ko.utf_8"
	SvmLanguageKoDotUTF8 string = "ko.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// no.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageNoDotUTF8 captures enum value "no.utf_8"
	SvmLanguageNoDotUTF8 string = "no.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// nl.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageNlDotUTF8 captures enum value "nl.utf_8"
	SvmLanguageNlDotUTF8 string = "nl.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pl
	// END RIPPY DEBUGGING
	// SvmLanguagePl captures enum value "pl"
	SvmLanguagePl string = "pl"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pl.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguagePlDotUTF8 captures enum value "pl.utf_8"
	SvmLanguagePlDotUTF8 string = "pl.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pt.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguagePtDotUTF8 captures enum value "pt.utf_8"
	SvmLanguagePtDotUTF8 string = "pt.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ro
	// END RIPPY DEBUGGING
	// SvmLanguageRo captures enum value "ro"
	SvmLanguageRo string = "ro"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ro.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageRoDotUTF8 captures enum value "ro.utf_8"
	SvmLanguageRoDotUTF8 string = "ro.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ru
	// END RIPPY DEBUGGING
	// SvmLanguageRu captures enum value "ru"
	SvmLanguageRu string = "ru"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ru.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageRuDotUTF8 captures enum value "ru.utf_8"
	SvmLanguageRuDotUTF8 string = "ru.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sk
	// END RIPPY DEBUGGING
	// SvmLanguageSk captures enum value "sk"
	SvmLanguageSk string = "sk"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sk.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageSkDotUTF8 captures enum value "sk.utf_8"
	SvmLanguageSkDotUTF8 string = "sk.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sl
	// END RIPPY DEBUGGING
	// SvmLanguageSl captures enum value "sl"
	SvmLanguageSl string = "sl"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sl.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageSlDotUTF8 captures enum value "sl.utf_8"
	SvmLanguageSlDotUTF8 string = "sl.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sv.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageSvDotUTF8 captures enum value "sv.utf_8"
	SvmLanguageSvDotUTF8 string = "sv.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// tr
	// END RIPPY DEBUGGING
	// SvmLanguageTr captures enum value "tr"
	SvmLanguageTr string = "tr"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// tr.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageTrDotUTF8 captures enum value "tr.utf_8"
	SvmLanguageTrDotUTF8 string = "tr.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageZhDotUTF8 captures enum value "zh.utf_8"
	SvmLanguageZhDotUTF8 string = "zh.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh.gbk.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageZhDotGbkDotUTF8 captures enum value "zh.gbk.utf_8"
	SvmLanguageZhDotGbkDotUTF8 string = "zh.gbk.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageZhTwDotUTF8 captures enum value "zh_tw.utf_8"
	SvmLanguageZhTwDotUTF8 string = "zh_tw.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw.big5.utf_8
	// END RIPPY DEBUGGING
	// SvmLanguageZhTwDotBig5DotUTF8 captures enum value "zh_tw.big5.utf_8"
	SvmLanguageZhTwDotBig5DotUTF8 string = "zh_tw.big5.utf_8"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// utf8mb4
	// END RIPPY DEBUGGING
	// SvmLanguageUtf8mb4 captures enum value "utf8mb4"
	SvmLanguageUtf8mb4 string = "utf8mb4"
)

// prop value enum
func (m *Svm) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, svmTypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Svm) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(m.Language) { // not required
		return nil
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", m.Language); err != nil {
		return err
	}

	return nil
}

func (m *Svm) validateLdap(formats strfmt.Registry) error {
	if swag.IsZero(m.Ldap) { // not required
		return nil
	}

	if m.Ldap != nil {
		if err := m.Ldap.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ldap")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNfs(formats strfmt.Registry) error {
	if swag.IsZero(m.Nfs) { // not required
		return nil
	}

	if m.Nfs != nil {
		if err := m.Nfs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNis(formats strfmt.Registry) error {
	if swag.IsZero(m.Nis) { // not required
		return nil
	}

	if m.Nis != nil {
		if err := m.Nis.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNsswitch(formats strfmt.Registry) error {
	if swag.IsZero(m.Nsswitch) { // not required
		return nil
	}

	if m.Nsswitch != nil {
		if err := m.Nsswitch.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNvme(formats strfmt.Registry) error {
	if swag.IsZero(m.Nvme) { // not required
		return nil
	}

	if m.Nvme != nil {
		if err := m.Nvme.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateRoutes(formats strfmt.Registry) error {
	if swag.IsZero(m.Routes) { // not required
		return nil
	}

	for i := 0; i < len(m.Routes); i++ {
		if swag.IsZero(m.Routes[i]) { // not required
			continue
		}

		if m.Routes[i] != nil {
			if err := m.Routes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("routes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) validateS3(formats strfmt.Registry) error {
	if swag.IsZero(m.S3) { // not required
		return nil
	}

	if m.S3 != nil {
		if err := m.S3.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateSnapmirror(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapmirror) { // not required
		return nil
	}

	if m.Snapmirror != nil {
		if err := m.Snapmirror.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

var svmTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["starting","running","stopping","stopped","deleting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		svmTypeStatePropEnum = append(svmTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// state
	// State
	// starting
	// END RIPPY DEBUGGING
	// SvmStateStarting captures enum value "starting"
	SvmStateStarting string = "starting"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// state
	// State
	// running
	// END RIPPY DEBUGGING
	// SvmStateRunning captures enum value "running"
	SvmStateRunning string = "running"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// state
	// State
	// stopping
	// END RIPPY DEBUGGING
	// SvmStateStopping captures enum value "stopping"
	SvmStateStopping string = "stopping"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// state
	// State
	// stopped
	// END RIPPY DEBUGGING
	// SvmStateStopped captures enum value "stopped"
	SvmStateStopped string = "stopped"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// state
	// State
	// deleting
	// END RIPPY DEBUGGING
	// SvmStateDeleting captures enum value "deleting"
	SvmStateDeleting string = "deleting"
)

// prop value enum
func (m *Svm) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, svmTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Svm) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var svmTypeSubtypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","dp_destination","sync_source","sync_destination"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		svmTypeSubtypePropEnum = append(svmTypeSubtypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// default
	// END RIPPY DEBUGGING
	// SvmSubtypeDefault captures enum value "default"
	SvmSubtypeDefault string = "default"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// dp_destination
	// END RIPPY DEBUGGING
	// SvmSubtypeDpDestination captures enum value "dp_destination"
	SvmSubtypeDpDestination string = "dp_destination"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// sync_source
	// END RIPPY DEBUGGING
	// SvmSubtypeSyncSource captures enum value "sync_source"
	SvmSubtypeSyncSource string = "sync_source"

	// BEGIN RIPPY DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// sync_destination
	// END RIPPY DEBUGGING
	// SvmSubtypeSyncDestination captures enum value "sync_destination"
	SvmSubtypeSyncDestination string = "sync_destination"
)

// prop value enum
func (m *Svm) validateSubtypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, svmTypeSubtypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Svm) validateSubtype(formats strfmt.Registry) error {
	if swag.IsZero(m.Subtype) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubtypeEnum("subtype", "body", m.Subtype); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this svm based on the context it is used
func (m *Svm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAggregatesDelegated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCifs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDNS(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFcInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFcp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIscsi(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLdap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNsswitch(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNvme(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRoutes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapmirror(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Svm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateAggregates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Aggregates); i++ {

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateAggregatesDelegated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregates_delegated", "body", m.AggregatesDelegated); err != nil {
		return err
	}

	return nil
}

func (m *Svm) contextValidateCertificate(ctx context.Context, formats strfmt.Registry) error {

	if m.Certificate != nil {
		if err := m.Certificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateCifs(ctx context.Context, formats strfmt.Registry) error {

	if m.Cifs != nil {
		if err := m.Cifs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateDNS(ctx context.Context, formats strfmt.Registry) error {

	if m.DNS != nil {
		if err := m.DNS.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateFcInterfaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FcInterfaces); i++ {

		if m.FcInterfaces[i] != nil {
			if err := m.FcInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fc_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateFcp(ctx context.Context, formats strfmt.Registry) error {

	if m.Fcp != nil {
		if err := m.Fcp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateIPInterfaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IPInterfaces); i++ {

		if m.IPInterfaces[i] != nil {
			if err := m.IPInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ip_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateIscsi(ctx context.Context, formats strfmt.Registry) error {

	if m.Iscsi != nil {
		if err := m.Iscsi.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateLdap(ctx context.Context, formats strfmt.Registry) error {

	if m.Ldap != nil {
		if err := m.Ldap.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ldap")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNfs(ctx context.Context, formats strfmt.Registry) error {

	if m.Nfs != nil {
		if err := m.Nfs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNis(ctx context.Context, formats strfmt.Registry) error {

	if m.Nis != nil {
		if err := m.Nis.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNsswitch(ctx context.Context, formats strfmt.Registry) error {

	if m.Nsswitch != nil {
		if err := m.Nsswitch.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNvme(ctx context.Context, formats strfmt.Registry) error {

	if m.Nvme != nil {
		if err := m.Nvme.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateRoutes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Routes); i++ {

		if m.Routes[i] != nil {
			if err := m.Routes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("routes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateS3(ctx context.Context, formats strfmt.Registry) error {

	if m.S3 != nil {
		if err := m.S3.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateSnapmirror(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapmirror != nil {
		if err := m.Snapmirror.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Svm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Svm) UnmarshalBinary(b []byte) error {
	var res Svm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmAggregatesItems0 Aggregate
//
// swagger:model SvmAggregatesItems0
type SvmAggregatesItems0 struct {

	// links
	Links *SvmAggregatesItems0Links `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm aggregates items0
func (m *SvmAggregatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm aggregates items0 based on the context it is used
func (m *SvmAggregatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmAggregatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmAggregatesItems0) UnmarshalBinary(b []byte) error {
	var res SvmAggregatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmAggregatesItems0Links svm aggregates items0 links
//
// swagger:model SvmAggregatesItems0Links
type SvmAggregatesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm aggregates items0 links
func (m *SvmAggregatesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm aggregates items0 links based on the context it is used
func (m *SvmAggregatesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmAggregatesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmAggregatesItems0Links) UnmarshalBinary(b []byte) error {
	var res SvmAggregatesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCertificate Certificate for incoming TLS connection requests.
//
// swagger:model SvmCertificate
type SvmCertificate struct {

	// links
	Links *SvmCertificateLinks `json:"_links,omitempty"`

	// Certificate UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm certificate
func (m *SvmCertificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm certificate based on the context it is used
func (m *SvmCertificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCertificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCertificate) UnmarshalBinary(b []byte) error {
	var res SvmCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCertificateLinks svm certificate links
//
// swagger:model SvmCertificateLinks
type SvmCertificateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm certificate links
func (m *SvmCertificateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm certificate links based on the context it is used
func (m *SvmCertificateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCertificateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCertificateLinks) UnmarshalBinary(b []byte) error {
	var res SvmCertificateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCifs svm cifs
//
// swagger:model SvmCifs
type SvmCifs struct {

	// links
	Links *SvmCifsLinks `json:"_links,omitempty"`

	// ad domain
	AdDomain *SvmCifsAdDomain `json:"ad_domain,omitempty"`

	// Specifies whether or not the CIFS service is administratively enabled.
	//
	Enabled bool `json:"enabled,omitempty"`

	// The NetBIOS name of the CIFS server.
	// Example: CIFS1
	// Max Length: 15
	// Min Length: 1
	Name string `json:"name,omitempty"`
}

// Validate validates this svm cifs
func (m *SvmCifs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifs) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmCifs) validateAdDomain(formats strfmt.Registry) error {
	if swag.IsZero(m.AdDomain) { // not required
		return nil
	}

	if m.AdDomain != nil {
		if err := m.AdDomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "ad_domain")
			}
			return err
		}
	}

	return nil
}

func (m *SvmCifs) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("cifs"+"."+"name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("cifs"+"."+"name", "body", m.Name, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this svm cifs based on the context it is used
func (m *SvmCifs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifs) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmCifs) contextValidateAdDomain(ctx context.Context, formats strfmt.Registry) error {

	if m.AdDomain != nil {
		if err := m.AdDomain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "ad_domain")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCifs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCifs) UnmarshalBinary(b []byte) error {
	var res SvmCifs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCifsAdDomain svm cifs ad domain
//
// swagger:model SvmCifsAdDomain
type SvmCifsAdDomain struct {

	// The fully qualified domain name of the Windows Active Directory to which this CIFS server belongs. A CIFS server appears as a member of Windows server object in the Active Directory store.
	//
	// Example: example.com
	Fqdn string `json:"fqdn,omitempty"`

	// Specifies the organizational unit within the Active Directory domain to associate with the CIFS server.
	//
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`

	// The account password used to add this CIFS server to the Active Directory. This is not audited. Valid in POST only.
	//
	Password string `json:"password,omitempty"`

	// The user account used to add this CIFS server to the Active Directory. Valid in POST only.
	//
	User string `json:"user,omitempty"`
}

// Validate validates this svm cifs ad domain
func (m *SvmCifsAdDomain) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this svm cifs ad domain based on context it is used
func (m *SvmCifsAdDomain) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SvmCifsAdDomain) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCifsAdDomain) UnmarshalBinary(b []byte) error {
	var res SvmCifsAdDomain
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCifsLinks svm cifs links
//
// swagger:model SvmCifsLinks
type SvmCifsLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm cifs links
func (m *SvmCifsLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifsLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm cifs links based on the context it is used
func (m *SvmCifsLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifsLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCifsLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCifsLinks) UnmarshalBinary(b []byte) error {
	var res SvmCifsLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmDNS svm DNS
//
// swagger:model SvmDNS
type SvmDNS struct {

	// links
	Links *SvmDNSLinks `json:"_links,omitempty"`

	// domains
	Domains DNSDomains `json:"domains,omitempty"`

	// servers
	Servers NameServers `json:"servers,omitempty"`
}

// Validate validates this svm DNS
func (m *SvmDNS) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomains(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNS) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmDNS) validateDomains(formats strfmt.Registry) error {
	if swag.IsZero(m.Domains) { // not required
		return nil
	}

	if err := m.Domains.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "domains")
		}
		return err
	}

	return nil
}

func (m *SvmDNS) validateServers(formats strfmt.Registry) error {
	if swag.IsZero(m.Servers) { // not required
		return nil
	}

	if err := m.Servers.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "servers")
		}
		return err
	}

	return nil
}

// ContextValidate validate this svm DNS based on the context it is used
func (m *SvmDNS) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDomains(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNS) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmDNS) contextValidateDomains(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Domains.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "domains")
		}
		return err
	}

	return nil
}

func (m *SvmDNS) contextValidateServers(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Servers.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "servers")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmDNS) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmDNS) UnmarshalBinary(b []byte) error {
	var res SvmDNS
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmDNSLinks svm DNS links
//
// swagger:model SvmDNSLinks
type SvmDNSLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm DNS links
func (m *SvmDNSLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNSLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm DNS links based on the context it is used
func (m *SvmDNSLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNSLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmDNSLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmDNSLinks) UnmarshalBinary(b []byte) error {
	var res SvmDNSLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmFcp svm fcp
//
// swagger:model SvmFcp
type SvmFcp struct {

	// links
	Links *SvmFcpLinks `json:"_links,omitempty"`

	// Enable Fiber Channel Protocol (FCP)? Setting to true creates a service if not already created.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this svm fcp
func (m *SvmFcp) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcp) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm fcp based on the context it is used
func (m *SvmFcp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcp) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmFcp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmFcp) UnmarshalBinary(b []byte) error {
	var res SvmFcp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmFcpLinks svm fcp links
//
// swagger:model SvmFcpLinks
type SvmFcpLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm fcp links
func (m *SvmFcpLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcpLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm fcp links based on the context it is used
func (m *SvmFcpLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcpLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmFcpLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmFcpLinks) UnmarshalBinary(b []byte) error {
	var res SvmFcpLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIpspace Either the UUID or name may be supplied on input.
//
// swagger:model SvmIpspace
type SvmIpspace struct {

	// links
	Links *SvmIpspaceLinks `json:"_links,omitempty"`

	// IPspace name
	// Example: exchange
	Name string `json:"name,omitempty"`

	// IPspace UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm ipspace
func (m *SvmIpspace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspace) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm ipspace based on the context it is used
func (m *SvmIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspace) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIpspace) UnmarshalBinary(b []byte) error {
	var res SvmIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIpspaceLinks svm ipspace links
//
// swagger:model SvmIpspaceLinks
type SvmIpspaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm ipspace links
func (m *SvmIpspaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm ipspace links based on the context it is used
func (m *SvmIpspaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIpspaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIpspaceLinks) UnmarshalBinary(b []byte) error {
	var res SvmIpspaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIscsi svm iscsi
//
// swagger:model SvmIscsi
type SvmIscsi struct {

	// links
	Links *SvmIscsiLinks `json:"_links,omitempty"`

	// Enable iSCSI? Setting to true creates a service if not already created.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this svm iscsi
func (m *SvmIscsi) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsi) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm iscsi based on the context it is used
func (m *SvmIscsi) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsi) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIscsi) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIscsi) UnmarshalBinary(b []byte) error {
	var res SvmIscsi
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIscsiLinks svm iscsi links
//
// swagger:model SvmIscsiLinks
type SvmIscsiLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm iscsi links
func (m *SvmIscsiLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsiLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm iscsi links based on the context it is used
func (m *SvmIscsiLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsiLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIscsiLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIscsiLinks) UnmarshalBinary(b []byte) error {
	var res SvmIscsiLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmLdap svm ldap
//
// swagger:model SvmLdap
type SvmLdap struct {

	// This parameter specifies the name of the Active Directory domain
	// used to discover LDAP servers for use by this client.
	// This is mutually exclusive with `servers` during POST.
	//
	AdDomain string `json:"ad_domain,omitempty"`

	// Specifies the default base DN for all searches.
	BaseDn string `json:"base_dn,omitempty"`

	// Specifies the user that binds to the LDAP servers. SVM API supports anonymous binding. For Simple and SASL LDAP binding, use the LDAP API endpoint.
	BindDn string `json:"bind_dn,omitempty"`

	// Enable LDAP? Setting to true creates a configuration if not already created.
	Enabled bool `json:"enabled,omitempty"`

	// servers
	Servers []string `json:"servers,omitempty"`
}

// Validate validates this svm ldap
func (m *SvmLdap) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this svm ldap based on context it is used
func (m *SvmLdap) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SvmLdap) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmLdap) UnmarshalBinary(b []byte) error {
	var res SvmLdap
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmLinks svm links
//
// swagger:model SvmLinks
type SvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm links
func (m *SvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm links based on the context it is used
func (m *SvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmLinks) UnmarshalBinary(b []byte) error {
	var res SvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNfs svm nfs
//
// swagger:model SvmNfs
type SvmNfs struct {

	// links
	Links *SvmNfsLinks `json:"_links,omitempty"`

	// Enable NFS? Setting to true creates a service if not already created.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this svm nfs
func (m *SvmNfs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfs) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nfs based on the context it is used
func (m *SvmNfs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfs) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNfs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNfs) UnmarshalBinary(b []byte) error {
	var res SvmNfs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNfsLinks svm nfs links
//
// swagger:model SvmNfsLinks
type SvmNfsLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm nfs links
func (m *SvmNfsLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfsLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nfs links based on the context it is used
func (m *SvmNfsLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfsLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNfsLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNfsLinks) UnmarshalBinary(b []byte) error {
	var res SvmNfsLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNis svm nis
//
// swagger:model SvmNis
type SvmNis struct {

	// links
	Links *SvmNisLinks `json:"_links,omitempty"`

	// domain
	Domain NisDomain `json:"domain,omitempty"`

	// Enable NIS? Setting to true creates a configuration if not already created.
	Enabled bool `json:"enabled,omitempty"`

	// servers
	Servers NisServers `json:"servers,omitempty"`
}

// Validate validates this svm nis
func (m *SvmNis) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNis) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmNis) validateDomain(formats strfmt.Registry) error {
	if swag.IsZero(m.Domain) { // not required
		return nil
	}

	if err := m.Domain.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "domain")
		}
		return err
	}

	return nil
}

func (m *SvmNis) validateServers(formats strfmt.Registry) error {
	if swag.IsZero(m.Servers) { // not required
		return nil
	}

	if err := m.Servers.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "servers")
		}
		return err
	}

	return nil
}

// ContextValidate validate this svm nis based on the context it is used
func (m *SvmNis) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNis) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmNis) contextValidateDomain(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Domain.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "domain")
		}
		return err
	}

	return nil
}

func (m *SvmNis) contextValidateServers(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Servers.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "servers")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNis) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNis) UnmarshalBinary(b []byte) error {
	var res SvmNis
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNisLinks svm nis links
//
// swagger:model SvmNisLinks
type SvmNisLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm nis links
func (m *SvmNisLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNisLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nis links based on the context it is used
func (m *SvmNisLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNisLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNisLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNisLinks) UnmarshalBinary(b []byte) error {
	var res SvmNisLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNsswitch Name service switch configuration
//
// swagger:model SvmNsswitch
type SvmNsswitch struct {

	// Group sources
	Group []NsswitchSource `json:"group,omitempty"`

	// Host sources
	Hosts []NsswitchSource `json:"hosts,omitempty"`

	// NameMap sources
	Namemap []NsswitchSource `json:"namemap,omitempty"`

	// NetGroup sources
	Netgroup []NsswitchSource `json:"netgroup,omitempty"`

	// Password sources
	Passwd []NsswitchSource `json:"passwd,omitempty"`
}

// Validate validates this svm nsswitch
func (m *SvmNsswitch) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHosts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamemap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetgroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePasswd(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNsswitch) validateGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Group) { // not required
		return nil
	}

	for i := 0; i < len(m.Group); i++ {

		if err := m.Group[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "group" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validateHosts(formats strfmt.Registry) error {
	if swag.IsZero(m.Hosts) { // not required
		return nil
	}

	for i := 0; i < len(m.Hosts); i++ {

		if err := m.Hosts[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "hosts" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validateNamemap(formats strfmt.Registry) error {
	if swag.IsZero(m.Namemap) { // not required
		return nil
	}

	for i := 0; i < len(m.Namemap); i++ {

		if err := m.Namemap[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "namemap" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validateNetgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Netgroup) { // not required
		return nil
	}

	for i := 0; i < len(m.Netgroup); i++ {

		if err := m.Netgroup[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "netgroup" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validatePasswd(formats strfmt.Registry) error {
	if swag.IsZero(m.Passwd) { // not required
		return nil
	}

	for i := 0; i < len(m.Passwd); i++ {

		if err := m.Passwd[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "passwd" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this svm nsswitch based on the context it is used
func (m *SvmNsswitch) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHosts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNamemap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePasswd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNsswitch) contextValidateGroup(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Group); i++ {

		if err := m.Group[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "group" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidateHosts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Hosts); i++ {

		if err := m.Hosts[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "hosts" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidateNamemap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Namemap); i++ {

		if err := m.Namemap[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "namemap" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidateNetgroup(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Netgroup); i++ {

		if err := m.Netgroup[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "netgroup" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidatePasswd(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Passwd); i++ {

		if err := m.Passwd[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "passwd" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNsswitch) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNsswitch) UnmarshalBinary(b []byte) error {
	var res SvmNsswitch
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNvme svm nvme
//
// swagger:model SvmNvme
type SvmNvme struct {

	// links
	Links *SvmNvmeLinks `json:"_links,omitempty"`

	// Enable NVMe? Setting to true creates a service if not already created.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this svm nvme
func (m *SvmNvme) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvme) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nvme based on the context it is used
func (m *SvmNvme) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvme) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNvme) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNvme) UnmarshalBinary(b []byte) error {
	var res SvmNvme
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNvmeLinks svm nvme links
//
// swagger:model SvmNvmeLinks
type SvmNvmeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm nvme links
func (m *SvmNvmeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvmeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nvme links based on the context it is used
func (m *SvmNvmeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvmeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNvmeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNvmeLinks) UnmarshalBinary(b []byte) error {
	var res SvmNvmeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmS3 svm s3
//
// swagger:model SvmS3
type SvmS3 struct {

	// links
	Links *SvmS3Links `json:"_links,omitempty"`

	// Specifies whether or not to enable S3. Setting this value to true creates a service if one is not yet created.
	Enabled bool `json:"enabled,omitempty"`

	// Specifies the name of the S3 server. A server name length can range from 1 to 15 characters and can only contain the following combination of characters 0-9, A-Z, a-z, ".", and "-".
	// Example: s3-server-1
	// Max Length: 15
	// Min Length: 1
	Name string `json:"name,omitempty"`
}

// Validate validates this svm s3
func (m *SvmS3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmS3) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("s3"+"."+"name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("s3"+"."+"name", "body", m.Name, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this svm s3 based on the context it is used
func (m *SvmS3) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmS3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmS3) UnmarshalBinary(b []byte) error {
	var res SvmS3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmS3Links svm s3 links
//
// swagger:model SvmS3Links
type SvmS3Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm s3 links
func (m *SvmS3Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm s3 links based on the context it is used
func (m *SvmS3Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmS3Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmS3Links) UnmarshalBinary(b []byte) error {
	var res SvmS3Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmSnapmirror Specifies attributes for SVM DR protection.
//
// swagger:model SvmSnapmirror
type SvmSnapmirror struct {

	// Specifies whether the SVM is a SnapMirror source SVM, using SnapMirror to protect its data.
	// Read Only: true
	IsProtected *bool `json:"is_protected,omitempty"`

	// Specifies the number of SVM DR protected volumes in the SVM.
	// Read Only: true
	ProtectedVolumesCount int64 `json:"protected_volumes_count,omitempty"`
}

// Validate validates this svm snapmirror
func (m *SvmSnapmirror) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this svm snapmirror based on the context it is used
func (m *SvmSnapmirror) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIsProtected(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectedVolumesCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapmirror) contextValidateIsProtected(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapmirror"+"."+"is_protected", "body", m.IsProtected); err != nil {
		return err
	}

	return nil
}

func (m *SvmSnapmirror) contextValidateProtectedVolumesCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapmirror"+"."+"protected_volumes_count", "body", int64(m.ProtectedVolumesCount)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmSnapmirror) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmSnapmirror) UnmarshalBinary(b []byte) error {
	var res SvmSnapmirror
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmSnapshotPolicy This is a reference to the Snapshot copy policy.
//
// swagger:model SvmSnapshotPolicy
type SvmSnapshotPolicy struct {

	// links
	Links *SvmSnapshotPolicyLinks `json:"_links,omitempty"`

	// name
	// Example: default
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm snapshot policy
func (m *SvmSnapshotPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm snapshot policy based on the context it is used
func (m *SvmSnapshotPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmSnapshotPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmSnapshotPolicy) UnmarshalBinary(b []byte) error {
	var res SvmSnapshotPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmSnapshotPolicyLinks svm snapshot policy links
//
// swagger:model SvmSnapshotPolicyLinks
type SvmSnapshotPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm snapshot policy links
func (m *SvmSnapshotPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm snapshot policy links based on the context it is used
func (m *SvmSnapshotPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmSnapshotPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmSnapshotPolicyLinks) UnmarshalBinary(b []byte) error {
	var res SvmSnapshotPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Svm svm
//
// swagger:model svm
type Svm struct {

	// links
	Links *SvmLinks `json:"_links,omitempty"`

	// List of allowed aggregates for SVM volumes. An administrator is allowed to create volumes on these aggregates.
	Aggregates []*SvmAggregatesItems0 `json:"aggregates,omitempty"`

	// This property is true when the administrator has delegated the aggregates for the SVM volumes.
	// Read Only: true
	AggregatesDelegated *bool `json:"aggregates_delegated,omitempty"`

	// Specifies the default Anti-ransomware state of the volumes in the SVM. Default "anti_ransomware_default_volume_state" property is disabled for POST operation. If this value is "disabled", Anti-ransomware protection is disabled by default on the new volumes that are created in the SVM. If this value is "dry_run", Anti-ransomware protection is in learning mode by default on the new volumes that are created in the SVM.  When the Anti-ransomware license is not present, this property is ignored and volumes will be created with the "disabled" state.
	// Enum: [disabled dry_run]
	AntiRansomwareDefaultVolumeState string `json:"anti_ransomware_default_volume_state,omitempty"`

	// certificate
	Certificate *SvmCertificate `json:"certificate,omitempty"`

	// cifs
	Cifs *SvmCifs `json:"cifs,omitempty"`

	// Comment
	// Max Length: 255
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// dns
	DNS *SvmDNS `json:"dns,omitempty"`

	// FC Interface for the SVM
	FcInterfaces []*FcInterfaceSvm `json:"fc_interfaces,omitempty"`

	// fcp
	Fcp *SvmFcp `json:"fcp,omitempty"`

	// IP interfaces for the SVM
	IPInterfaces []*IPInterfaceSvm `json:"ip_interfaces,omitempty"`

	// ipspace
	Ipspace *SvmIpspace `json:"ipspace,omitempty"`

	// Indicates whether logical space enforcement for the SVM is enabled.
	IsSpaceEnforcementLogical *bool `json:"is_space_enforcement_logical,omitempty"`

	// Indicates whether logical space reporting for the SVM is enabled.
	IsSpaceReportingLogical *bool `json:"is_space_reporting_logical,omitempty"`

	// iscsi
	Iscsi *SvmIscsi `json:"iscsi,omitempty"`

	// Default volume language code. UTF-8 encoded languages are valid in POST or PATCH. Non UTF-8 language encodings are for backward compatibility and are not valid input for POST and PATCH requests.
	// Example: c.utf_8
	// Enum: [c da de en en_us es fi fr he it ja ja_jp.pck ko no nl pt sv zh zh.gbk zh_tw zh_tw.big5 c.utf_8 ar ar.utf_8 cs cs.utf_8 da.utf_8 de.utf_8 en.utf_8 en_us.utf_8 es.utf_8 fi.utf_8 fr.utf_8 he.utf_8 hr hr.utf_8 hu hu.utf_8 it.utf_8 ja.utf_8 ja_v1 ja_v1.utf_8 ja_jp.pck.utf_8 ja_jp.932 ja_jp.932.utf_8 ja_jp.pck_v2 ja_jp.pck_v2.utf_8 ko.utf_8 no.utf_8 nl.utf_8 pl pl.utf_8 pt.utf_8 ro ro.utf_8 ru ru.utf_8 sk sk.utf_8 sl sl.utf_8 sv.utf_8 tr tr.utf_8 zh.utf_8 zh.gbk.utf_8 zh_tw.utf_8 zh_tw.big5.utf_8 utf8mb4]
	Language string `json:"language,omitempty"`

	// ldap
	Ldap *SvmLdap `json:"ldap,omitempty"`

	// This property is used by cluster administrator to specify the limit on maximum number of volumes allowed in the SVM. The value can be either the string "unlimited" or a number.
	MaxVolumes *string `json:"max_volumes,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// ndmp
	Ndmp *SvmNdmp `json:"ndmp,omitempty"`

	// nfs
	Nfs *SvmNfs `json:"nfs,omitempty"`

	// nis
	Nis *SvmNis `json:"nis,omitempty"`

	// nsswitch
	Nsswitch *SvmNsswitch `json:"nsswitch,omitempty"`

	// nvme
	Nvme *SvmNvme `json:"nvme,omitempty"`

	// qos policy
	QosPolicy *SvmQosPolicy `json:"qos_policy,omitempty"`

	// Optional array of routes for the SVM
	Routes []*NetworkRouteForSvm `json:"routes,omitempty"`

	// s3
	S3 *SvmS3 `json:"s3,omitempty"`

	// snapmirror
	Snapmirror *SvmSnapmirror `json:"snapmirror,omitempty"`

	// snapshot policy
	SnapshotPolicy *SvmSnapshotPolicy `json:"snapshot_policy,omitempty"`

	// SVM State
	// Example: running
	// Enum: [starting running stopping stopped deleting]
	State string `json:"state,omitempty"`

	// SVM subtype. The SVM subtype sync_destination is created automatically when an SVM of subtype sync_source is created on the source MetroCluster cluster. A POST request with sync_destination as SVM subtype is invalid.
	// Enum: [default dp_destination sync_source sync_destination]
	Subtype string `json:"subtype,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm
func (m *Svm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAntiRansomwareDefaultVolumeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCifs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFcInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFcp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIscsi(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLdap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNdmp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNis(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNsswitch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNvme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQosPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapmirror(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubtype(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Svm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregates) { // not required
		return nil
	}

	for i := 0; i < len(m.Aggregates); i++ {
		if swag.IsZero(m.Aggregates[i]) { // not required
			continue
		}

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var svmTypeAntiRansomwareDefaultVolumeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["disabled","dry_run"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		svmTypeAntiRansomwareDefaultVolumeStatePropEnum = append(svmTypeAntiRansomwareDefaultVolumeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// svm
	// Svm
	// anti_ransomware_default_volume_state
	// AntiRansomwareDefaultVolumeState
	// disabled
	// END DEBUGGING
	// SvmAntiRansomwareDefaultVolumeStateDisabled captures enum value "disabled"
	SvmAntiRansomwareDefaultVolumeStateDisabled string = "disabled"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// anti_ransomware_default_volume_state
	// AntiRansomwareDefaultVolumeState
	// dry_run
	// END DEBUGGING
	// SvmAntiRansomwareDefaultVolumeStateDryRun captures enum value "dry_run"
	SvmAntiRansomwareDefaultVolumeStateDryRun string = "dry_run"
)

// prop value enum
func (m *Svm) validateAntiRansomwareDefaultVolumeStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, svmTypeAntiRansomwareDefaultVolumeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Svm) validateAntiRansomwareDefaultVolumeState(formats strfmt.Registry) error {
	if swag.IsZero(m.AntiRansomwareDefaultVolumeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAntiRansomwareDefaultVolumeStateEnum("anti_ransomware_default_volume_state", "body", m.AntiRansomwareDefaultVolumeState); err != nil {
		return err
	}

	return nil
}

func (m *Svm) validateCertificate(formats strfmt.Registry) error {
	if swag.IsZero(m.Certificate) { // not required
		return nil
	}

	if m.Certificate != nil {
		if err := m.Certificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateCifs(formats strfmt.Registry) error {
	if swag.IsZero(m.Cifs) { // not required
		return nil
	}

	if m.Cifs != nil {
		if err := m.Cifs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 255); err != nil {
		return err
	}

	return nil
}

func (m *Svm) validateDNS(formats strfmt.Registry) error {
	if swag.IsZero(m.DNS) { // not required
		return nil
	}

	if m.DNS != nil {
		if err := m.DNS.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateFcInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.FcInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.FcInterfaces); i++ {
		if swag.IsZero(m.FcInterfaces[i]) { // not required
			continue
		}

		if m.FcInterfaces[i] != nil {
			if err := m.FcInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fc_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) validateFcp(formats strfmt.Registry) error {
	if swag.IsZero(m.Fcp) { // not required
		return nil
	}

	if m.Fcp != nil {
		if err := m.Fcp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateIPInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.IPInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.IPInterfaces); i++ {
		if swag.IsZero(m.IPInterfaces[i]) { // not required
			continue
		}

		if m.IPInterfaces[i] != nil {
			if err := m.IPInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ip_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateIscsi(formats strfmt.Registry) error {
	if swag.IsZero(m.Iscsi) { // not required
		return nil
	}

	if m.Iscsi != nil {
		if err := m.Iscsi.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi")
			}
			return err
		}
	}

	return nil
}

var svmTypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["c","da","de","en","en_us","es","fi","fr","he","it","ja","ja_jp.pck","ko","no","nl","pt","sv","zh","zh.gbk","zh_tw","zh_tw.big5","c.utf_8","ar","ar.utf_8","cs","cs.utf_8","da.utf_8","de.utf_8","en.utf_8","en_us.utf_8","es.utf_8","fi.utf_8","fr.utf_8","he.utf_8","hr","hr.utf_8","hu","hu.utf_8","it.utf_8","ja.utf_8","ja_v1","ja_v1.utf_8","ja_jp.pck.utf_8","ja_jp.932","ja_jp.932.utf_8","ja_jp.pck_v2","ja_jp.pck_v2.utf_8","ko.utf_8","no.utf_8","nl.utf_8","pl","pl.utf_8","pt.utf_8","ro","ro.utf_8","ru","ru.utf_8","sk","sk.utf_8","sl","sl.utf_8","sv.utf_8","tr","tr.utf_8","zh.utf_8","zh.gbk.utf_8","zh_tw.utf_8","zh_tw.big5.utf_8","utf8mb4"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		svmTypeLanguagePropEnum = append(svmTypeLanguagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// c
	// END DEBUGGING
	// SvmLanguageC captures enum value "c"
	SvmLanguageC string = "c"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// da
	// END DEBUGGING
	// SvmLanguageDa captures enum value "da"
	SvmLanguageDa string = "da"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// de
	// END DEBUGGING
	// SvmLanguageDe captures enum value "de"
	SvmLanguageDe string = "de"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en
	// END DEBUGGING
	// SvmLanguageEn captures enum value "en"
	SvmLanguageEn string = "en"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en_us
	// END DEBUGGING
	// SvmLanguageEnUs captures enum value "en_us"
	SvmLanguageEnUs string = "en_us"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// es
	// END DEBUGGING
	// SvmLanguageEs captures enum value "es"
	SvmLanguageEs string = "es"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fi
	// END DEBUGGING
	// SvmLanguageFi captures enum value "fi"
	SvmLanguageFi string = "fi"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fr
	// END DEBUGGING
	// SvmLanguageFr captures enum value "fr"
	SvmLanguageFr string = "fr"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// he
	// END DEBUGGING
	// SvmLanguageHe captures enum value "he"
	SvmLanguageHe string = "he"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// it
	// END DEBUGGING
	// SvmLanguageIt captures enum value "it"
	SvmLanguageIt string = "it"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja
	// END DEBUGGING
	// SvmLanguageJa captures enum value "ja"
	SvmLanguageJa string = "ja"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck
	// END DEBUGGING
	// SvmLanguageJaJpDotPck captures enum value "ja_jp.pck"
	SvmLanguageJaJpDotPck string = "ja_jp.pck"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ko
	// END DEBUGGING
	// SvmLanguageKo captures enum value "ko"
	SvmLanguageKo string = "ko"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// no
	// END DEBUGGING
	// SvmLanguageNo captures enum value "no"
	SvmLanguageNo string = "no"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// nl
	// END DEBUGGING
	// SvmLanguageNl captures enum value "nl"
	SvmLanguageNl string = "nl"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pt
	// END DEBUGGING
	// SvmLanguagePt captures enum value "pt"
	SvmLanguagePt string = "pt"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sv
	// END DEBUGGING
	// SvmLanguageSv captures enum value "sv"
	SvmLanguageSv string = "sv"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh
	// END DEBUGGING
	// SvmLanguageZh captures enum value "zh"
	SvmLanguageZh string = "zh"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh.gbk
	// END DEBUGGING
	// SvmLanguageZhDotGbk captures enum value "zh.gbk"
	SvmLanguageZhDotGbk string = "zh.gbk"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw
	// END DEBUGGING
	// SvmLanguageZhTw captures enum value "zh_tw"
	SvmLanguageZhTw string = "zh_tw"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw.big5
	// END DEBUGGING
	// SvmLanguageZhTwDotBig5 captures enum value "zh_tw.big5"
	SvmLanguageZhTwDotBig5 string = "zh_tw.big5"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// c.utf_8
	// END DEBUGGING
	// SvmLanguageCDotUTF8 captures enum value "c.utf_8"
	SvmLanguageCDotUTF8 string = "c.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ar
	// END DEBUGGING
	// SvmLanguageAr captures enum value "ar"
	SvmLanguageAr string = "ar"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ar.utf_8
	// END DEBUGGING
	// SvmLanguageArDotUTF8 captures enum value "ar.utf_8"
	SvmLanguageArDotUTF8 string = "ar.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// cs
	// END DEBUGGING
	// SvmLanguageCs captures enum value "cs"
	SvmLanguageCs string = "cs"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// cs.utf_8
	// END DEBUGGING
	// SvmLanguageCsDotUTF8 captures enum value "cs.utf_8"
	SvmLanguageCsDotUTF8 string = "cs.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// da.utf_8
	// END DEBUGGING
	// SvmLanguageDaDotUTF8 captures enum value "da.utf_8"
	SvmLanguageDaDotUTF8 string = "da.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// de.utf_8
	// END DEBUGGING
	// SvmLanguageDeDotUTF8 captures enum value "de.utf_8"
	SvmLanguageDeDotUTF8 string = "de.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en.utf_8
	// END DEBUGGING
	// SvmLanguageEnDotUTF8 captures enum value "en.utf_8"
	SvmLanguageEnDotUTF8 string = "en.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// en_us.utf_8
	// END DEBUGGING
	// SvmLanguageEnUsDotUTF8 captures enum value "en_us.utf_8"
	SvmLanguageEnUsDotUTF8 string = "en_us.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// es.utf_8
	// END DEBUGGING
	// SvmLanguageEsDotUTF8 captures enum value "es.utf_8"
	SvmLanguageEsDotUTF8 string = "es.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fi.utf_8
	// END DEBUGGING
	// SvmLanguageFiDotUTF8 captures enum value "fi.utf_8"
	SvmLanguageFiDotUTF8 string = "fi.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// fr.utf_8
	// END DEBUGGING
	// SvmLanguageFrDotUTF8 captures enum value "fr.utf_8"
	SvmLanguageFrDotUTF8 string = "fr.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// he.utf_8
	// END DEBUGGING
	// SvmLanguageHeDotUTF8 captures enum value "he.utf_8"
	SvmLanguageHeDotUTF8 string = "he.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hr
	// END DEBUGGING
	// SvmLanguageHr captures enum value "hr"
	SvmLanguageHr string = "hr"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hr.utf_8
	// END DEBUGGING
	// SvmLanguageHrDotUTF8 captures enum value "hr.utf_8"
	SvmLanguageHrDotUTF8 string = "hr.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hu
	// END DEBUGGING
	// SvmLanguageHu captures enum value "hu"
	SvmLanguageHu string = "hu"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// hu.utf_8
	// END DEBUGGING
	// SvmLanguageHuDotUTF8 captures enum value "hu.utf_8"
	SvmLanguageHuDotUTF8 string = "hu.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// it.utf_8
	// END DEBUGGING
	// SvmLanguageItDotUTF8 captures enum value "it.utf_8"
	SvmLanguageItDotUTF8 string = "it.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja.utf_8
	// END DEBUGGING
	// SvmLanguageJaDotUTF8 captures enum value "ja.utf_8"
	SvmLanguageJaDotUTF8 string = "ja.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_v1
	// END DEBUGGING
	// SvmLanguageJaV1 captures enum value "ja_v1"
	SvmLanguageJaV1 string = "ja_v1"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_v1.utf_8
	// END DEBUGGING
	// SvmLanguageJaV1DotUTF8 captures enum value "ja_v1.utf_8"
	SvmLanguageJaV1DotUTF8 string = "ja_v1.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck.utf_8
	// END DEBUGGING
	// SvmLanguageJaJpDotPckDotUTF8 captures enum value "ja_jp.pck.utf_8"
	SvmLanguageJaJpDotPckDotUTF8 string = "ja_jp.pck.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.932
	// END DEBUGGING
	// SvmLanguageJaJpDot932 captures enum value "ja_jp.932"
	SvmLanguageJaJpDot932 string = "ja_jp.932"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.932.utf_8
	// END DEBUGGING
	// SvmLanguageJaJpDot932DotUTF8 captures enum value "ja_jp.932.utf_8"
	SvmLanguageJaJpDot932DotUTF8 string = "ja_jp.932.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck_v2
	// END DEBUGGING
	// SvmLanguageJaJpDotPckV2 captures enum value "ja_jp.pck_v2"
	SvmLanguageJaJpDotPckV2 string = "ja_jp.pck_v2"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ja_jp.pck_v2.utf_8
	// END DEBUGGING
	// SvmLanguageJaJpDotPckV2DotUTF8 captures enum value "ja_jp.pck_v2.utf_8"
	SvmLanguageJaJpDotPckV2DotUTF8 string = "ja_jp.pck_v2.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ko.utf_8
	// END DEBUGGING
	// SvmLanguageKoDotUTF8 captures enum value "ko.utf_8"
	SvmLanguageKoDotUTF8 string = "ko.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// no.utf_8
	// END DEBUGGING
	// SvmLanguageNoDotUTF8 captures enum value "no.utf_8"
	SvmLanguageNoDotUTF8 string = "no.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// nl.utf_8
	// END DEBUGGING
	// SvmLanguageNlDotUTF8 captures enum value "nl.utf_8"
	SvmLanguageNlDotUTF8 string = "nl.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pl
	// END DEBUGGING
	// SvmLanguagePl captures enum value "pl"
	SvmLanguagePl string = "pl"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pl.utf_8
	// END DEBUGGING
	// SvmLanguagePlDotUTF8 captures enum value "pl.utf_8"
	SvmLanguagePlDotUTF8 string = "pl.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// pt.utf_8
	// END DEBUGGING
	// SvmLanguagePtDotUTF8 captures enum value "pt.utf_8"
	SvmLanguagePtDotUTF8 string = "pt.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ro
	// END DEBUGGING
	// SvmLanguageRo captures enum value "ro"
	SvmLanguageRo string = "ro"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ro.utf_8
	// END DEBUGGING
	// SvmLanguageRoDotUTF8 captures enum value "ro.utf_8"
	SvmLanguageRoDotUTF8 string = "ro.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ru
	// END DEBUGGING
	// SvmLanguageRu captures enum value "ru"
	SvmLanguageRu string = "ru"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// ru.utf_8
	// END DEBUGGING
	// SvmLanguageRuDotUTF8 captures enum value "ru.utf_8"
	SvmLanguageRuDotUTF8 string = "ru.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sk
	// END DEBUGGING
	// SvmLanguageSk captures enum value "sk"
	SvmLanguageSk string = "sk"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sk.utf_8
	// END DEBUGGING
	// SvmLanguageSkDotUTF8 captures enum value "sk.utf_8"
	SvmLanguageSkDotUTF8 string = "sk.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sl
	// END DEBUGGING
	// SvmLanguageSl captures enum value "sl"
	SvmLanguageSl string = "sl"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sl.utf_8
	// END DEBUGGING
	// SvmLanguageSlDotUTF8 captures enum value "sl.utf_8"
	SvmLanguageSlDotUTF8 string = "sl.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// sv.utf_8
	// END DEBUGGING
	// SvmLanguageSvDotUTF8 captures enum value "sv.utf_8"
	SvmLanguageSvDotUTF8 string = "sv.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// tr
	// END DEBUGGING
	// SvmLanguageTr captures enum value "tr"
	SvmLanguageTr string = "tr"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// tr.utf_8
	// END DEBUGGING
	// SvmLanguageTrDotUTF8 captures enum value "tr.utf_8"
	SvmLanguageTrDotUTF8 string = "tr.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh.utf_8
	// END DEBUGGING
	// SvmLanguageZhDotUTF8 captures enum value "zh.utf_8"
	SvmLanguageZhDotUTF8 string = "zh.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh.gbk.utf_8
	// END DEBUGGING
	// SvmLanguageZhDotGbkDotUTF8 captures enum value "zh.gbk.utf_8"
	SvmLanguageZhDotGbkDotUTF8 string = "zh.gbk.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw.utf_8
	// END DEBUGGING
	// SvmLanguageZhTwDotUTF8 captures enum value "zh_tw.utf_8"
	SvmLanguageZhTwDotUTF8 string = "zh_tw.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// zh_tw.big5.utf_8
	// END DEBUGGING
	// SvmLanguageZhTwDotBig5DotUTF8 captures enum value "zh_tw.big5.utf_8"
	SvmLanguageZhTwDotBig5DotUTF8 string = "zh_tw.big5.utf_8"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// language
	// Language
	// utf8mb4
	// END DEBUGGING
	// SvmLanguageUtf8mb4 captures enum value "utf8mb4"
	SvmLanguageUtf8mb4 string = "utf8mb4"
)

// prop value enum
func (m *Svm) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, svmTypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Svm) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(m.Language) { // not required
		return nil
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", m.Language); err != nil {
		return err
	}

	return nil
}

func (m *Svm) validateLdap(formats strfmt.Registry) error {
	if swag.IsZero(m.Ldap) { // not required
		return nil
	}

	if m.Ldap != nil {
		if err := m.Ldap.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ldap")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNdmp(formats strfmt.Registry) error {
	if swag.IsZero(m.Ndmp) { // not required
		return nil
	}

	if m.Ndmp != nil {
		if err := m.Ndmp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ndmp")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNfs(formats strfmt.Registry) error {
	if swag.IsZero(m.Nfs) { // not required
		return nil
	}

	if m.Nfs != nil {
		if err := m.Nfs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNis(formats strfmt.Registry) error {
	if swag.IsZero(m.Nis) { // not required
		return nil
	}

	if m.Nis != nil {
		if err := m.Nis.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNsswitch(formats strfmt.Registry) error {
	if swag.IsZero(m.Nsswitch) { // not required
		return nil
	}

	if m.Nsswitch != nil {
		if err := m.Nsswitch.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateNvme(formats strfmt.Registry) error {
	if swag.IsZero(m.Nvme) { // not required
		return nil
	}

	if m.Nvme != nil {
		if err := m.Nvme.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateQosPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.QosPolicy) { // not required
		return nil
	}

	if m.QosPolicy != nil {
		if err := m.QosPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateRoutes(formats strfmt.Registry) error {
	if swag.IsZero(m.Routes) { // not required
		return nil
	}

	for i := 0; i < len(m.Routes); i++ {
		if swag.IsZero(m.Routes[i]) { // not required
			continue
		}

		if m.Routes[i] != nil {
			if err := m.Routes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("routes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) validateS3(formats strfmt.Registry) error {
	if swag.IsZero(m.S3) { // not required
		return nil
	}

	if m.S3 != nil {
		if err := m.S3.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateSnapmirror(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapmirror) { // not required
		return nil
	}

	if m.Snapmirror != nil {
		if err := m.Snapmirror.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

var svmTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["starting","running","stopping","stopped","deleting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		svmTypeStatePropEnum = append(svmTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// svm
	// Svm
	// state
	// State
	// starting
	// END DEBUGGING
	// SvmStateStarting captures enum value "starting"
	SvmStateStarting string = "starting"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// state
	// State
	// running
	// END DEBUGGING
	// SvmStateRunning captures enum value "running"
	SvmStateRunning string = "running"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// state
	// State
	// stopping
	// END DEBUGGING
	// SvmStateStopping captures enum value "stopping"
	SvmStateStopping string = "stopping"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// state
	// State
	// stopped
	// END DEBUGGING
	// SvmStateStopped captures enum value "stopped"
	SvmStateStopped string = "stopped"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// state
	// State
	// deleting
	// END DEBUGGING
	// SvmStateDeleting captures enum value "deleting"
	SvmStateDeleting string = "deleting"
)

// prop value enum
func (m *Svm) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, svmTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Svm) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var svmTypeSubtypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","dp_destination","sync_source","sync_destination"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		svmTypeSubtypePropEnum = append(svmTypeSubtypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// default
	// END DEBUGGING
	// SvmSubtypeDefault captures enum value "default"
	SvmSubtypeDefault string = "default"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// dp_destination
	// END DEBUGGING
	// SvmSubtypeDpDestination captures enum value "dp_destination"
	SvmSubtypeDpDestination string = "dp_destination"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// sync_source
	// END DEBUGGING
	// SvmSubtypeSyncSource captures enum value "sync_source"
	SvmSubtypeSyncSource string = "sync_source"

	// BEGIN DEBUGGING
	// svm
	// Svm
	// subtype
	// Subtype
	// sync_destination
	// END DEBUGGING
	// SvmSubtypeSyncDestination captures enum value "sync_destination"
	SvmSubtypeSyncDestination string = "sync_destination"
)

// prop value enum
func (m *Svm) validateSubtypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, svmTypeSubtypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Svm) validateSubtype(formats strfmt.Registry) error {
	if swag.IsZero(m.Subtype) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubtypeEnum("subtype", "body", m.Subtype); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this svm based on the context it is used
func (m *Svm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAggregatesDelegated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCifs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDNS(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFcInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFcp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIscsi(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLdap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNdmp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNsswitch(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNvme(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQosPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRoutes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapmirror(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Svm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateAggregates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Aggregates); i++ {

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateAggregatesDelegated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregates_delegated", "body", m.AggregatesDelegated); err != nil {
		return err
	}

	return nil
}

func (m *Svm) contextValidateCertificate(ctx context.Context, formats strfmt.Registry) error {

	if m.Certificate != nil {
		if err := m.Certificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateCifs(ctx context.Context, formats strfmt.Registry) error {

	if m.Cifs != nil {
		if err := m.Cifs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateDNS(ctx context.Context, formats strfmt.Registry) error {

	if m.DNS != nil {
		if err := m.DNS.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateFcInterfaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FcInterfaces); i++ {

		if m.FcInterfaces[i] != nil {
			if err := m.FcInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fc_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateFcp(ctx context.Context, formats strfmt.Registry) error {

	if m.Fcp != nil {
		if err := m.Fcp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateIPInterfaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IPInterfaces); i++ {

		if m.IPInterfaces[i] != nil {
			if err := m.IPInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ip_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateIscsi(ctx context.Context, formats strfmt.Registry) error {

	if m.Iscsi != nil {
		if err := m.Iscsi.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateLdap(ctx context.Context, formats strfmt.Registry) error {

	if m.Ldap != nil {
		if err := m.Ldap.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ldap")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNdmp(ctx context.Context, formats strfmt.Registry) error {

	if m.Ndmp != nil {
		if err := m.Ndmp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ndmp")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNfs(ctx context.Context, formats strfmt.Registry) error {

	if m.Nfs != nil {
		if err := m.Nfs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNis(ctx context.Context, formats strfmt.Registry) error {

	if m.Nis != nil {
		if err := m.Nis.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNsswitch(ctx context.Context, formats strfmt.Registry) error {

	if m.Nsswitch != nil {
		if err := m.Nsswitch.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateNvme(ctx context.Context, formats strfmt.Registry) error {

	if m.Nvme != nil {
		if err := m.Nvme.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateQosPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.QosPolicy != nil {
		if err := m.QosPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateRoutes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Routes); i++ {

		if m.Routes[i] != nil {
			if err := m.Routes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("routes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Svm) contextValidateS3(ctx context.Context, formats strfmt.Registry) error {

	if m.S3 != nil {
		if err := m.S3.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateSnapmirror(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapmirror != nil {
		if err := m.Snapmirror.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Svm) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Svm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Svm) UnmarshalBinary(b []byte) error {
	var res Svm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmAggregatesItems0 svm aggregates items0
//
// swagger:model SvmAggregatesItems0
type SvmAggregatesItems0 struct {

	// links
	Links *SvmAggregatesItems0Links `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm aggregates items0
func (m *SvmAggregatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm aggregates items0 based on the context it is used
func (m *SvmAggregatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmAggregatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmAggregatesItems0) UnmarshalBinary(b []byte) error {
	var res SvmAggregatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmAggregatesItems0Links svm aggregates items0 links
//
// swagger:model SvmAggregatesItems0Links
type SvmAggregatesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm aggregates items0 links
func (m *SvmAggregatesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm aggregates items0 links based on the context it is used
func (m *SvmAggregatesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmAggregatesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmAggregatesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmAggregatesItems0Links) UnmarshalBinary(b []byte) error {
	var res SvmAggregatesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCertificate Support for this field will be removed in a future release. Please use /svm/svms/{svm.uuid}/web for this field. Certificate for incoming TLS connection requests.
//
// swagger:model SvmCertificate
type SvmCertificate struct {

	// links
	Links *SvmCertificateLinks `json:"_links,omitempty"`

	// Certificate name
	// Example: cert1
	Name string `json:"name,omitempty"`

	// Certificate UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm certificate
func (m *SvmCertificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm certificate based on the context it is used
func (m *SvmCertificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCertificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCertificate) UnmarshalBinary(b []byte) error {
	var res SvmCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCertificateLinks svm certificate links
//
// swagger:model SvmCertificateLinks
type SvmCertificateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm certificate links
func (m *SvmCertificateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm certificate links based on the context it is used
func (m *SvmCertificateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCertificateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCertificateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCertificateLinks) UnmarshalBinary(b []byte) error {
	var res SvmCertificateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCifs svm cifs
//
// swagger:model SvmCifs
type SvmCifs struct {

	// links
	Links *SvmCifsLinks `json:"_links,omitempty"`

	// ad domain
	AdDomain *SvmCifsAdDomain `json:"ad_domain,omitempty"`

	// If this is set to true, an SVM administrator can manage the CIFS service. If it is false, only the cluster administrator can manage the service.
	Allowed *bool `json:"allowed,omitempty"`

	// If allowed, setting to true enables the CIFS service.
	Enabled *bool `json:"enabled,omitempty"`

	// The NetBIOS name of the CIFS server.
	// Example: CIFS1
	// Max Length: 15
	// Min Length: 1
	Name string `json:"name,omitempty"`
}

// Validate validates this svm cifs
func (m *SvmCifs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifs) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmCifs) validateAdDomain(formats strfmt.Registry) error {
	if swag.IsZero(m.AdDomain) { // not required
		return nil
	}

	if m.AdDomain != nil {
		if err := m.AdDomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "ad_domain")
			}
			return err
		}
	}

	return nil
}

func (m *SvmCifs) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("cifs"+"."+"name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("cifs"+"."+"name", "body", m.Name, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this svm cifs based on the context it is used
func (m *SvmCifs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifs) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmCifs) contextValidateAdDomain(ctx context.Context, formats strfmt.Registry) error {

	if m.AdDomain != nil {
		if err := m.AdDomain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "ad_domain")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCifs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCifs) UnmarshalBinary(b []byte) error {
	var res SvmCifs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCifsAdDomain svm cifs ad domain
//
// swagger:model SvmCifsAdDomain
type SvmCifsAdDomain struct {

	// The fully qualified domain name of the Windows Active Directory to which this CIFS server belongs. A CIFS server appears as a member of Windows server object in the Active Directory store.
	//
	// Example: example.com
	Fqdn string `json:"fqdn,omitempty"`

	// Specifies the organizational unit within the Active Directory domain to associate with the CIFS server.
	//
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`

	// The account password used to add this CIFS server to the Active Directory. This is not audited. Valid in POST only.
	//
	Password string `json:"password,omitempty"`

	// The user account used to add this CIFS server to the Active Directory. Valid in POST only.
	//
	User string `json:"user,omitempty"`
}

// Validate validates this svm cifs ad domain
func (m *SvmCifsAdDomain) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this svm cifs ad domain based on context it is used
func (m *SvmCifsAdDomain) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SvmCifsAdDomain) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCifsAdDomain) UnmarshalBinary(b []byte) error {
	var res SvmCifsAdDomain
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmCifsLinks svm cifs links
//
// swagger:model SvmCifsLinks
type SvmCifsLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm cifs links
func (m *SvmCifsLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifsLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm cifs links based on the context it is used
func (m *SvmCifsLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmCifsLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cifs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmCifsLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmCifsLinks) UnmarshalBinary(b []byte) error {
	var res SvmCifsLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmDNS svm DNS
//
// swagger:model SvmDNS
type SvmDNS struct {

	// links
	Links *SvmDNSLinks `json:"_links,omitempty"`

	// domains
	Domains DNSDomains `json:"domains,omitempty"`

	// servers
	Servers NameServers `json:"servers,omitempty"`
}

// Validate validates this svm DNS
func (m *SvmDNS) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomains(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNS) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmDNS) validateDomains(formats strfmt.Registry) error {
	if swag.IsZero(m.Domains) { // not required
		return nil
	}

	if err := m.Domains.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "domains")
		}
		return err
	}

	return nil
}

func (m *SvmDNS) validateServers(formats strfmt.Registry) error {
	if swag.IsZero(m.Servers) { // not required
		return nil
	}

	if err := m.Servers.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "servers")
		}
		return err
	}

	return nil
}

// ContextValidate validate this svm DNS based on the context it is used
func (m *SvmDNS) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDomains(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNS) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmDNS) contextValidateDomains(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Domains.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "domains")
		}
		return err
	}

	return nil
}

func (m *SvmDNS) contextValidateServers(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Servers.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dns" + "." + "servers")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmDNS) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmDNS) UnmarshalBinary(b []byte) error {
	var res SvmDNS
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmDNSLinks svm DNS links
//
// swagger:model SvmDNSLinks
type SvmDNSLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm DNS links
func (m *SvmDNSLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNSLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm DNS links based on the context it is used
func (m *SvmDNSLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmDNSLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dns" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmDNSLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmDNSLinks) UnmarshalBinary(b []byte) error {
	var res SvmDNSLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmFcp svm fcp
//
// swagger:model SvmFcp
type SvmFcp struct {

	// links
	Links *SvmFcpLinks `json:"_links,omitempty"`

	// If this is set to true, an SVM administrator can manage the FCP service. If it is false, only the cluster administrator can manage the service.
	Allowed *bool `json:"allowed,omitempty"`

	// If allowed, setting to true enables the FCP service.
	Enabled *bool `json:"enabled,omitempty"`
}

// Validate validates this svm fcp
func (m *SvmFcp) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcp) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm fcp based on the context it is used
func (m *SvmFcp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcp) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmFcp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmFcp) UnmarshalBinary(b []byte) error {
	var res SvmFcp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmFcpLinks svm fcp links
//
// swagger:model SvmFcpLinks
type SvmFcpLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm fcp links
func (m *SvmFcpLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcpLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm fcp links based on the context it is used
func (m *SvmFcpLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmFcpLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fcp" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmFcpLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmFcpLinks) UnmarshalBinary(b []byte) error {
	var res SvmFcpLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIpspace Either the UUID or name may be supplied on input.
//
// swagger:model SvmIpspace
type SvmIpspace struct {

	// links
	Links *SvmIpspaceLinks `json:"_links,omitempty"`

	// IPspace name
	// Example: exchange
	Name string `json:"name,omitempty"`

	// IPspace UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm ipspace
func (m *SvmIpspace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspace) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm ipspace based on the context it is used
func (m *SvmIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspace) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIpspace) UnmarshalBinary(b []byte) error {
	var res SvmIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIpspaceLinks svm ipspace links
//
// swagger:model SvmIpspaceLinks
type SvmIpspaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm ipspace links
func (m *SvmIpspaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm ipspace links based on the context it is used
func (m *SvmIpspaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIpspaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIpspaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIpspaceLinks) UnmarshalBinary(b []byte) error {
	var res SvmIpspaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIscsi svm iscsi
//
// swagger:model SvmIscsi
type SvmIscsi struct {

	// links
	Links *SvmIscsiLinks `json:"_links,omitempty"`

	// If this is set to true, an SVM administrator can manage the iSCSI service. If it is false, only the cluster administrator can manage the service.
	Allowed *bool `json:"allowed,omitempty"`

	// If allowed, setting to true enables the ISCSI service.
	Enabled *bool `json:"enabled,omitempty"`
}

// Validate validates this svm iscsi
func (m *SvmIscsi) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsi) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm iscsi based on the context it is used
func (m *SvmIscsi) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsi) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIscsi) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIscsi) UnmarshalBinary(b []byte) error {
	var res SvmIscsi
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmIscsiLinks svm iscsi links
//
// swagger:model SvmIscsiLinks
type SvmIscsiLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm iscsi links
func (m *SvmIscsiLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsiLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm iscsi links based on the context it is used
func (m *SvmIscsiLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmIscsiLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmIscsiLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmIscsiLinks) UnmarshalBinary(b []byte) error {
	var res SvmIscsiLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmLdap svm ldap
//
// swagger:model SvmLdap
type SvmLdap struct {

	// This parameter specifies the name of the Active Directory domain
	// used to discover LDAP servers for use by this client.
	// This is mutually exclusive with `servers` during POST.
	//
	AdDomain string `json:"ad_domain,omitempty"`

	// Specifies the default base DN for all searches.
	BaseDn string `json:"base_dn,omitempty"`

	// Specifies the user that binds to the LDAP servers. SVM API supports anonymous binding. For Simple and SASL LDAP binding, use the LDAP API endpoint.
	BindDn string `json:"bind_dn,omitempty"`

	// Enable LDAP? Setting to true creates a configuration if not already created.
	Enabled bool `json:"enabled,omitempty"`

	// servers
	Servers []string `json:"servers,omitempty"`
}

// Validate validates this svm ldap
func (m *SvmLdap) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this svm ldap based on context it is used
func (m *SvmLdap) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SvmLdap) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmLdap) UnmarshalBinary(b []byte) error {
	var res SvmLdap
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmLinks svm links
//
// swagger:model SvmLinks
type SvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm links
func (m *SvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm links based on the context it is used
func (m *SvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmLinks) UnmarshalBinary(b []byte) error {
	var res SvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNdmp svm ndmp
//
// swagger:model SvmNdmp
type SvmNdmp struct {

	// If this is set to true, an SVM administrator can manage the NDMP service. If it is false, only the cluster administrator can manage the service.
	Allowed *bool `json:"allowed,omitempty"`
}

// Validate validates this svm ndmp
func (m *SvmNdmp) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this svm ndmp based on context it is used
func (m *SvmNdmp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SvmNdmp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNdmp) UnmarshalBinary(b []byte) error {
	var res SvmNdmp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNfs svm nfs
//
// swagger:model SvmNfs
type SvmNfs struct {

	// links
	Links *SvmNfsLinks `json:"_links,omitempty"`

	// If this is set to true, an SVM administrator can manage the NFS service. If it is false, only the cluster administrator can manage the service.
	Allowed *bool `json:"allowed,omitempty"`

	// If allowed, setting to true enables the NFS service.
	Enabled *bool `json:"enabled,omitempty"`
}

// Validate validates this svm nfs
func (m *SvmNfs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfs) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nfs based on the context it is used
func (m *SvmNfs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfs) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNfs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNfs) UnmarshalBinary(b []byte) error {
	var res SvmNfs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNfsLinks svm nfs links
//
// swagger:model SvmNfsLinks
type SvmNfsLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm nfs links
func (m *SvmNfsLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfsLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nfs links based on the context it is used
func (m *SvmNfsLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNfsLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNfsLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNfsLinks) UnmarshalBinary(b []byte) error {
	var res SvmNfsLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNis svm nis
//
// swagger:model SvmNis
type SvmNis struct {

	// links
	Links *SvmNisLinks `json:"_links,omitempty"`

	// domain
	Domain NisDomain `json:"domain,omitempty"`

	// Enable NIS? Setting to true creates a configuration if not already created.
	Enabled bool `json:"enabled,omitempty"`

	// servers
	Servers NisServers `json:"servers,omitempty"`
}

// Validate validates this svm nis
func (m *SvmNis) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNis) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmNis) validateDomain(formats strfmt.Registry) error {
	if swag.IsZero(m.Domain) { // not required
		return nil
	}

	if err := m.Domain.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "domain")
		}
		return err
	}

	return nil
}

func (m *SvmNis) validateServers(formats strfmt.Registry) error {
	if swag.IsZero(m.Servers) { // not required
		return nil
	}

	if err := m.Servers.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "servers")
		}
		return err
	}

	return nil
}

// ContextValidate validate this svm nis based on the context it is used
func (m *SvmNis) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNis) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmNis) contextValidateDomain(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Domain.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "domain")
		}
		return err
	}

	return nil
}

func (m *SvmNis) contextValidateServers(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Servers.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("nis" + "." + "servers")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNis) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNis) UnmarshalBinary(b []byte) error {
	var res SvmNis
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNisLinks svm nis links
//
// swagger:model SvmNisLinks
type SvmNisLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm nis links
func (m *SvmNisLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNisLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nis links based on the context it is used
func (m *SvmNisLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNisLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nis" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNisLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNisLinks) UnmarshalBinary(b []byte) error {
	var res SvmNisLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNsswitch Name service switch configuration
//
// swagger:model SvmNsswitch
type SvmNsswitch struct {

	// Group sources
	Group []NsswitchSource `json:"group,omitempty"`

	// Host sources
	Hosts []NsswitchSource `json:"hosts,omitempty"`

	// NameMap sources
	Namemap []NsswitchSource `json:"namemap,omitempty"`

	// NetGroup sources
	Netgroup []NsswitchSource `json:"netgroup,omitempty"`

	// Password sources
	Passwd []NsswitchSource `json:"passwd,omitempty"`
}

// Validate validates this svm nsswitch
func (m *SvmNsswitch) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHosts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamemap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetgroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePasswd(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNsswitch) validateGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Group) { // not required
		return nil
	}

	for i := 0; i < len(m.Group); i++ {

		if err := m.Group[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "group" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validateHosts(formats strfmt.Registry) error {
	if swag.IsZero(m.Hosts) { // not required
		return nil
	}

	for i := 0; i < len(m.Hosts); i++ {

		if err := m.Hosts[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "hosts" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validateNamemap(formats strfmt.Registry) error {
	if swag.IsZero(m.Namemap) { // not required
		return nil
	}

	for i := 0; i < len(m.Namemap); i++ {

		if err := m.Namemap[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "namemap" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validateNetgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Netgroup) { // not required
		return nil
	}

	for i := 0; i < len(m.Netgroup); i++ {

		if err := m.Netgroup[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "netgroup" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) validatePasswd(formats strfmt.Registry) error {
	if swag.IsZero(m.Passwd) { // not required
		return nil
	}

	for i := 0; i < len(m.Passwd); i++ {

		if err := m.Passwd[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "passwd" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this svm nsswitch based on the context it is used
func (m *SvmNsswitch) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHosts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNamemap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePasswd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNsswitch) contextValidateGroup(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Group); i++ {

		if err := m.Group[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "group" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidateHosts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Hosts); i++ {

		if err := m.Hosts[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "hosts" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidateNamemap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Namemap); i++ {

		if err := m.Namemap[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "namemap" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidateNetgroup(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Netgroup); i++ {

		if err := m.Netgroup[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "netgroup" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *SvmNsswitch) contextValidatePasswd(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Passwd); i++ {

		if err := m.Passwd[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nsswitch" + "." + "passwd" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNsswitch) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNsswitch) UnmarshalBinary(b []byte) error {
	var res SvmNsswitch
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNvme svm nvme
//
// swagger:model SvmNvme
type SvmNvme struct {

	// links
	Links *SvmNvmeLinks `json:"_links,omitempty"`

	// If this is set to true, an SVM administrator can manage the NVMe service. If it is false, only the cluster administrator can manage the service.
	Allowed *bool `json:"allowed,omitempty"`

	// If allowed, setting to true enables the NVMe service.
	Enabled *bool `json:"enabled,omitempty"`
}

// Validate validates this svm nvme
func (m *SvmNvme) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvme) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nvme based on the context it is used
func (m *SvmNvme) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvme) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNvme) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNvme) UnmarshalBinary(b []byte) error {
	var res SvmNvme
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmNvmeLinks svm nvme links
//
// swagger:model SvmNvmeLinks
type SvmNvmeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm nvme links
func (m *SvmNvmeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvmeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm nvme links based on the context it is used
func (m *SvmNvmeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmNvmeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvme" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmNvmeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmNvmeLinks) UnmarshalBinary(b []byte) error {
	var res SvmNvmeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmQosPolicy This optionally specifies which QoS policy group to apply to the Vserver. This policy group defines measurable service level objectives (SLOs) that apply to the storage objects with which the policy group is associated.
//
// swagger:model SvmQosPolicy
type SvmQosPolicy struct {

	// links
	Links *SvmQosPolicyLinks `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm qos policy
func (m *SvmQosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmQosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm qos policy based on the context it is used
func (m *SvmQosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmQosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmQosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmQosPolicy) UnmarshalBinary(b []byte) error {
	var res SvmQosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmQosPolicyLinks svm qos policy links
//
// swagger:model SvmQosPolicyLinks
type SvmQosPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm qos policy links
func (m *SvmQosPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmQosPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm qos policy links based on the context it is used
func (m *SvmQosPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmQosPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmQosPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmQosPolicyLinks) UnmarshalBinary(b []byte) error {
	var res SvmQosPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmS3 svm s3
//
// swagger:model SvmS3
type SvmS3 struct {

	// links
	Links *SvmS3Links `json:"_links,omitempty"`

	// certificate
	Certificate *SvmS3Certificate `json:"certificate,omitempty"`

	// Specifies whether or not to enable S3. Setting this value to true creates a service if one is not yet created.
	Enabled bool `json:"enabled,omitempty"`

	// Specifies whether HTTP is enabled on the S3 server. By default, HTTP is disabled on the S3 server.
	IsHTTPEnabled *bool `json:"is_http_enabled,omitempty"`

	// Specifies whether HTTPS is enabled on the S3 server. By default, HTTPS is enabled on the S3 server.
	IsHTTPSEnabled *bool `json:"is_https_enabled,omitempty"`

	// Specifies the name of the S3 server. A server name length can range from 1 to 253 characters and can only contain the following combination of characters 0-9, A-Z, a-z, ".", and "-".
	// Example: s3-server-1
	// Max Length: 253
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// Specifies the HTTP listener port for the S3 server. By default, HTTP is enabled on port 80.
	Port *int64 `json:"port,omitempty"`

	// Specifies the HTTPS listener port for the S3 server. By default, HTTPS is enabled on port 443.
	SecurePort *int64 `json:"secure_port,omitempty"`
}

// Validate validates this svm s3
func (m *SvmS3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmS3) validateCertificate(formats strfmt.Registry) error {
	if swag.IsZero(m.Certificate) { // not required
		return nil
	}

	if m.Certificate != nil {
		if err := m.Certificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "certificate")
			}
			return err
		}
	}

	return nil
}

func (m *SvmS3) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("s3"+"."+"name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("s3"+"."+"name", "body", m.Name, 253); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this svm s3 based on the context it is used
func (m *SvmS3) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *SvmS3) contextValidateCertificate(ctx context.Context, formats strfmt.Registry) error {

	if m.Certificate != nil {
		if err := m.Certificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "certificate")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmS3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmS3) UnmarshalBinary(b []byte) error {
	var res SvmS3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmS3Certificate Specifies the certificate that will be used for creating HTTPS connections to the S3 server.
//
// swagger:model SvmS3Certificate
type SvmS3Certificate struct {

	// links
	Links *SvmS3CertificateLinks `json:"_links,omitempty"`

	// Certificate name
	// Example: cert1
	Name string `json:"name,omitempty"`

	// Certificate UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm s3 certificate
func (m *SvmS3Certificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3Certificate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm s3 certificate based on the context it is used
func (m *SvmS3Certificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3Certificate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmS3Certificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmS3Certificate) UnmarshalBinary(b []byte) error {
	var res SvmS3Certificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmS3CertificateLinks svm s3 certificate links
//
// swagger:model SvmS3CertificateLinks
type SvmS3CertificateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm s3 certificate links
func (m *SvmS3CertificateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3CertificateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm s3 certificate links based on the context it is used
func (m *SvmS3CertificateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3CertificateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmS3CertificateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmS3CertificateLinks) UnmarshalBinary(b []byte) error {
	var res SvmS3CertificateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmS3Links svm s3 links
//
// swagger:model SvmS3Links
type SvmS3Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm s3 links
func (m *SvmS3Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm s3 links based on the context it is used
func (m *SvmS3Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmS3Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmS3Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmS3Links) UnmarshalBinary(b []byte) error {
	var res SvmS3Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmSnapmirror Specifies attributes for SVM DR protection.
//
// swagger:model SvmSnapmirror
type SvmSnapmirror struct {

	// Specifies whether the SVM is a SnapMirror source SVM, using SnapMirror to protect its data.
	// Read Only: true
	IsProtected *bool `json:"is_protected,omitempty"`

	// Specifies the number of SVM DR protected volumes in the SVM.
	// Read Only: true
	ProtectedVolumesCount int64 `json:"protected_volumes_count,omitempty"`
}

// Validate validates this svm snapmirror
func (m *SvmSnapmirror) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this svm snapmirror based on the context it is used
func (m *SvmSnapmirror) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIsProtected(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectedVolumesCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapmirror) contextValidateIsProtected(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapmirror"+"."+"is_protected", "body", m.IsProtected); err != nil {
		return err
	}

	return nil
}

func (m *SvmSnapmirror) contextValidateProtectedVolumesCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapmirror"+"."+"protected_volumes_count", "body", int64(m.ProtectedVolumesCount)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmSnapmirror) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmSnapmirror) UnmarshalBinary(b []byte) error {
	var res SvmSnapmirror
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmSnapshotPolicy This is a reference to the Snapshot copy policy.
//
// swagger:model SvmSnapshotPolicy
type SvmSnapshotPolicy struct {

	// links
	Links *SvmSnapshotPolicyLinks `json:"_links,omitempty"`

	// name
	// Example: default
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this svm snapshot policy
func (m *SvmSnapshotPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm snapshot policy based on the context it is used
func (m *SvmSnapshotPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmSnapshotPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmSnapshotPolicy) UnmarshalBinary(b []byte) error {
	var res SvmSnapshotPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SvmSnapshotPolicyLinks svm snapshot policy links
//
// swagger:model SvmSnapshotPolicyLinks
type SvmSnapshotPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this svm snapshot policy links
func (m *SvmSnapshotPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this svm snapshot policy links based on the context it is used
func (m *SvmSnapshotPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SvmSnapshotPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SvmSnapshotPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SvmSnapshotPolicyLinks) UnmarshalBinary(b []byte) error {
	var res SvmSnapshotPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

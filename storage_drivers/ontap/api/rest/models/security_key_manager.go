// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SecurityKeyManager security key manager
//
// swagger:model security_key_manager
type SecurityKeyManager struct {

	// links
	Links *SecurityKeyManagerLinks `json:"_links,omitempty"`

	// external
	External *SecurityKeyManagerExternal `json:"external,omitempty"`

	// Indicates whether default data-at-rest encryption is disabled in the cluster.
	IsDefaultDataAtRestEncryptionDisabled *bool `json:"is_default_data_at_rest_encryption_disabled,omitempty"`

	// onboard
	Onboard *SecurityKeyManagerOnboard `json:"onboard,omitempty"`

	// scope
	Scope NetworkScopeReadonly `json:"scope,omitempty"`

	// status
	Status *SecurityKeyManagerStatus `json:"status,omitempty"`

	// svm
	Svm *SecurityKeyManagerSvm `json:"svm,omitempty"`

	// uuid
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// volume encryption
	VolumeEncryption *SecurityKeyManagerVolumeEncryption `json:"volume_encryption,omitempty"`
}

// Validate validates this security key manager
func (m *SecurityKeyManager) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnboard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeEncryption(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManager) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) validateExternal(formats strfmt.Registry) error {
	if swag.IsZero(m.External) { // not required
		return nil
	}

	if m.External != nil {
		if err := m.External.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) validateOnboard(formats strfmt.Registry) error {
	if swag.IsZero(m.Onboard) { // not required
		return nil
	}

	if m.Onboard != nil {
		if err := m.Onboard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("onboard")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if err := m.Scope.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("scope")
		}
		return err
	}

	return nil
}

func (m *SecurityKeyManager) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) validateVolumeEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeEncryption) { // not required
		return nil
	}

	if m.VolumeEncryption != nil {
		if err := m.VolumeEncryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume_encryption")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager based on the context it is used
func (m *SecurityKeyManager) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOnboard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManager) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) contextValidateExternal(ctx context.Context, formats strfmt.Registry) error {

	if m.External != nil {
		if err := m.External.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) contextValidateOnboard(ctx context.Context, formats strfmt.Registry) error {

	if m.Onboard != nil {
		if err := m.Onboard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("onboard")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Scope.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("scope")
		}
		return err
	}

	return nil
}

func (m *SecurityKeyManager) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManager) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *SecurityKeyManager) contextValidateVolumeEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.VolumeEncryption != nil {
		if err := m.VolumeEncryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume_encryption")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManager) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManager) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManager
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerExternal Configures external key management
//
// swagger:model SecurityKeyManagerExternal
type SecurityKeyManagerExternal struct {

	// client certificate
	ClientCertificate *SecurityKeyManagerExternalClientCertificate `json:"client_certificate,omitempty"`

	// The UUIDs of the server CA certificates already installed in the cluster or SVM. The array of certificates are common for all the keyservers per SVM.
	ServerCaCertificates []*SecurityKeyManagerExternalServerCaCertificatesItems0 `json:"server_ca_certificates,omitempty"`

	// The set of external key servers.
	// Max Items: 4
	Servers []*KeyServerReadcreate `json:"servers,omitempty"`
}

// Validate validates this security key manager external
func (m *SecurityKeyManagerExternal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServerCaCertificates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternal) validateClientCertificate(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientCertificate) { // not required
		return nil
	}

	if m.ClientCertificate != nil {
		if err := m.ClientCertificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external" + "." + "client_certificate")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManagerExternal) validateServerCaCertificates(formats strfmt.Registry) error {
	if swag.IsZero(m.ServerCaCertificates) { // not required
		return nil
	}

	for i := 0; i < len(m.ServerCaCertificates); i++ {
		if swag.IsZero(m.ServerCaCertificates[i]) { // not required
			continue
		}

		if m.ServerCaCertificates[i] != nil {
			if err := m.ServerCaCertificates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("external" + "." + "server_ca_certificates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SecurityKeyManagerExternal) validateServers(formats strfmt.Registry) error {
	if swag.IsZero(m.Servers) { // not required
		return nil
	}

	iServersSize := int64(len(m.Servers))

	if err := validate.MaxItems("external"+"."+"servers", "body", iServersSize, 4); err != nil {
		return err
	}

	for i := 0; i < len(m.Servers); i++ {
		if swag.IsZero(m.Servers[i]) { // not required
			continue
		}

		if m.Servers[i] != nil {
			if err := m.Servers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("external" + "." + "servers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this security key manager external based on the context it is used
func (m *SecurityKeyManagerExternal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClientCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServerCaCertificates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternal) contextValidateClientCertificate(ctx context.Context, formats strfmt.Registry) error {

	if m.ClientCertificate != nil {
		if err := m.ClientCertificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external" + "." + "client_certificate")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityKeyManagerExternal) contextValidateServerCaCertificates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ServerCaCertificates); i++ {

		if m.ServerCaCertificates[i] != nil {
			if err := m.ServerCaCertificates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("external" + "." + "server_ca_certificates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SecurityKeyManagerExternal) contextValidateServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Servers); i++ {

		if m.Servers[i] != nil {
			if err := m.Servers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("external" + "." + "servers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerExternal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerExternal) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerExternal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerExternalClientCertificate Client certificate
//
// swagger:model SecurityKeyManagerExternalClientCertificate
type SecurityKeyManagerExternalClientCertificate struct {

	// links
	Links *SecurityKeyManagerExternalClientCertificateLinks `json:"_links,omitempty"`

	// Certificate UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this security key manager external client certificate
func (m *SecurityKeyManagerExternalClientCertificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalClientCertificate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external" + "." + "client_certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager external client certificate based on the context it is used
func (m *SecurityKeyManagerExternalClientCertificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalClientCertificate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external" + "." + "client_certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerExternalClientCertificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerExternalClientCertificate) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerExternalClientCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerExternalClientCertificateLinks security key manager external client certificate links
//
// swagger:model SecurityKeyManagerExternalClientCertificateLinks
type SecurityKeyManagerExternalClientCertificateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this security key manager external client certificate links
func (m *SecurityKeyManagerExternalClientCertificateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalClientCertificateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external" + "." + "client_certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager external client certificate links based on the context it is used
func (m *SecurityKeyManagerExternalClientCertificateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalClientCertificateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external" + "." + "client_certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerExternalClientCertificateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerExternalClientCertificateLinks) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerExternalClientCertificateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerExternalServerCaCertificatesItems0 security key manager external server ca certificates items0
//
// swagger:model SecurityKeyManagerExternalServerCaCertificatesItems0
type SecurityKeyManagerExternalServerCaCertificatesItems0 struct {

	// links
	Links *SecurityKeyManagerExternalServerCaCertificatesItems0Links `json:"_links,omitempty"`

	// Certificate UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this security key manager external server ca certificates items0
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalServerCaCertificatesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager external server ca certificates items0 based on the context it is used
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalServerCaCertificatesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerExternalServerCaCertificatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerExternalServerCaCertificatesItems0Links security key manager external server ca certificates items0 links
//
// swagger:model SecurityKeyManagerExternalServerCaCertificatesItems0Links
type SecurityKeyManagerExternalServerCaCertificatesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this security key manager external server ca certificates items0 links
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalServerCaCertificatesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager external server ca certificates items0 links based on the context it is used
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerExternalServerCaCertificatesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerExternalServerCaCertificatesItems0Links) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerExternalServerCaCertificatesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerLinks security key manager links
//
// swagger:model SecurityKeyManagerLinks
type SecurityKeyManagerLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this security key manager links
func (m *SecurityKeyManagerLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager links based on the context it is used
func (m *SecurityKeyManagerLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerLinks) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerOnboard Configures onboard key management. After configuring onboard key management, save the encrypted configuration data in a safe location so that you can use it if you need to perform a manual recovery operation.
//
// swagger:model SecurityKeyManagerOnboard
type SecurityKeyManagerOnboard struct {

	// Is the onboard key manager enabled?
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// The cluster-wide passphrase. This is not audited.
	// Example: The cluster password of length 32-256 ASCII characters.
	// Format: password
	ExistingPassphrase strfmt.Password `json:"existing_passphrase,omitempty"`

	// Backup of the onboard key manager's key hierarchy. It is required to save this backup after configuring the onboard key manager to help in the recovery of the cluster in case of catastrophic failures.
	// Example: '--------------------------BEGIN BACKUP-------------------------- TmV0QXBwIEtleSBCbG9iAAEAAAAEAAAAcAEAAAAAAAAxBFWWAAAAACEAAAAAAAAA QAAAAAAAAABzDyyVAAAAALI5Jsjvy6gUxnT78KoDKXHYb6sSeraM00quOULY6BeV n6dMFxuErCD1lbERaOQZSuaYy1p8oQHtTEfGMLZM4TYiAAAAAAAAACgAAAAAAAAA 3WTh7gAAAAAAAAAAAAAAAAIAAAAAAAgAZJEIWvdeHr5RCAvHGclo+wAAAAAAAAAA IgAAAAAAAAAoAAAAAAAAAEOTcR0AAAAAAAAAAAAAAAACAAAAAAAJAGr3tJA/LRzU QRHwv+1aWvAAAAAAAAAAACQAAAAAAAAAgAAAAAAAAADV1Vd/AAAAAMFM9Q229Bhp mDaTSdqku5DCd8wG+fOZSr4bx4JT5WHvV/r5gJnXDQQAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOZXRBcHAgS2V5IEJsb2IA AQAAAAMAAAAYAQAAAAAAALgePkcAAAAAIgAAAAAAAAAoAAAAAAAAAEOTcR0AAAAA AAAAAAAAAAACAAAAAAAJAGr3tJA/LRzUQRHwv+1aWvAAAAAAAAAAACIAAAAAAAAA KAAAAAAAAACIlCHZAAAAAAAAAAAAAAAAAgAAAAAAAQCafcabsxRXMM7gxhLRrzxh AAAAAAAAAAAkAAAAAAAAAIAAAAAAAAAA2JjQBQAAAACt4IqXcNpVggahl0axLsN4 yQjnNVKWY7mANB29O42hI7b70DTGCTaVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAE5ldEFwcCBLZXkgQmxvYgABAAAAAwAAABgBAAAAAAAA 7sbaoQAAAAAiAAAAAAAAACgAAAAAAAAAQ5NxHQAAAAAAAAAAAAAAAAIAAAAAAAkA ave0kD8tHNRBEfC/7Vpa8AAAAAAAAAAAIgAAAAAAAAAoAAAAAAAAALOHfWkAAAAA AAAAAAAAAAACAAAAAAABAMoI9UxrHOGthQm/CB+EHdAAAAAAAAAAACQAAAAAAAAA gAAAAAAAAACnMmUtAAAAAGVk8AtPzENFgsGdsFvnmucmYrlQCsFew0HDSFKaZqK6 W8IEVzBAhPoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ---------------------------END BACKUP---------------------------'
	// Read Only: true
	KeyBackup string `json:"key_backup,omitempty"`

	// The cluster-wide passphrase. This is not audited.
	// Example: The cluster password of length 32-256 ASCII characters.
	// Format: password
	Passphrase strfmt.Password `json:"passphrase,omitempty"`

	// Synchronizes missing onboard keys on any node in the cluster. If a node is added to a cluster that has onboard key management configured, the synchronize operation needs to be performed in a PATCH operation. In a MetroCluster configuration, if onboard key management is enabled on one site, then the synchronize operation needs to be run as a POST operation on the remote site providing the same passphrase.
	Synchronize bool `json:"synchronize,omitempty"`
}

// Validate validates this security key manager onboard
func (m *SecurityKeyManagerOnboard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExistingPassphrase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePassphrase(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerOnboard) validateExistingPassphrase(formats strfmt.Registry) error {
	if swag.IsZero(m.ExistingPassphrase) { // not required
		return nil
	}

	if err := validate.FormatOf("onboard"+"."+"existing_passphrase", "body", "password", m.ExistingPassphrase.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SecurityKeyManagerOnboard) validatePassphrase(formats strfmt.Registry) error {
	if swag.IsZero(m.Passphrase) { // not required
		return nil
	}

	if err := validate.FormatOf("onboard"+"."+"passphrase", "body", "password", m.Passphrase.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this security key manager onboard based on the context it is used
func (m *SecurityKeyManagerOnboard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeyBackup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerOnboard) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "onboard"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *SecurityKeyManagerOnboard) contextValidateKeyBackup(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "onboard"+"."+"key_backup", "body", string(m.KeyBackup)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerOnboard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerOnboard) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerOnboard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerStatus Optional status information on the current state of the key manager indicating if it is fully setup or requires more action.
//
//
// swagger:model SecurityKeyManagerStatus
type SecurityKeyManagerStatus struct {

	// Code corresponding to the status message. Returns 0 if the setup is complete. This is an advanced property; there is an added cost to retrieving its value. The property is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter or GET for all advanced properties is enabled.
	// Example: 346758
	Code int64 `json:"code,omitempty"`

	// Current state of the key manager indicating any additional steps to perform to finish the setup. This is an advanced property; there is an added cost to retrieving its value. The property is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter or GET for all advanced properties is enabled.
	// Example: This cluster is part of a MetroCluster configuration. Use the REST API POST method security/key_managers/ with the synchronize option and the same passphrase on the partner cluster before proceeding with any key manager operations.  Failure to do so could lead to switchover or switchback failure.
	Message string `json:"message,omitempty"`
}

// Validate validates this security key manager status
func (m *SecurityKeyManagerStatus) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this security key manager status based on the context it is used
func (m *SecurityKeyManagerStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerStatus) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerSvm security key manager svm
//
// swagger:model SecurityKeyManagerSvm
type SecurityKeyManagerSvm struct {

	// links
	Links *SecurityKeyManagerSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this security key manager svm
func (m *SecurityKeyManagerSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager svm based on the context it is used
func (m *SecurityKeyManagerSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerSvm) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerSvmLinks security key manager svm links
//
// swagger:model SecurityKeyManagerSvmLinks
type SecurityKeyManagerSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this security key manager svm links
func (m *SecurityKeyManagerSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security key manager svm links based on the context it is used
func (m *SecurityKeyManagerSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityKeyManagerSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerSvmLinks) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityKeyManagerVolumeEncryption Indicates whether volume encryption is supported in the cluster.
//
//
// swagger:model SecurityKeyManagerVolumeEncryption
type SecurityKeyManagerVolumeEncryption struct {

	// Code corresponding to the status message. Returns a 0 if volume encryption is supported in all nodes of the cluster.
	// Example: 346758
	Code int64 `json:"code,omitempty"`

	// Reason for not supporting volume encryption.
	// Example: No platform support for volume encryption in following nodes - node1, node2.
	Message string `json:"message,omitempty"`

	// Set to true when volume encryption support is available on all nodes of the cluster.
	Supported bool `json:"supported,omitempty"`
}

// Validate validates this security key manager volume encryption
func (m *SecurityKeyManagerVolumeEncryption) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this security key manager volume encryption based on the context it is used
func (m *SecurityKeyManagerVolumeEncryption) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *SecurityKeyManagerVolumeEncryption) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityKeyManagerVolumeEncryption) UnmarshalBinary(b []byte) error {
	var res SecurityKeyManagerVolumeEncryption
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

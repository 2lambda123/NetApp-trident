// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterPeer cluster peer
//
// swagger:model cluster_peer
type ClusterPeer struct {

	// links
	Links *ClusterPeerLinks `json:"_links,omitempty"`

	// authentication
	Authentication *ClusterPeerAuthentication `json:"authentication,omitempty"`

	// encryption
	Encryption *ClusterPeerEncryption `json:"encryption,omitempty"`

	// The local SVMs allowed to peer with the peer cluster's SVMs. This list can be modified until the remote cluster accepts this cluster peering relationship.
	InitialAllowedSvms []*ClusterPeerInitialAllowedSvmsItems0 `json:"initial_allowed_svms,omitempty"`

	// ipspace
	Ipspace *ClusterPeerIpspace `json:"ipspace,omitempty"`

	// local network
	LocalNetwork *ClusterPeerLocalNetwork `json:"local_network,omitempty"`

	// Optional name for the cluster peer relationship. By default, it is the name of the remote cluster.
	// Example: cluster2
	Name string `json:"name,omitempty"`

	// Peering applications against which allowed SVMs are configured.
	// Example: ["snapmirror","flexcache"]
	PeerApplications []SvmPeerPermissionApplications `json:"peer_applications,omitempty"`

	// remote
	Remote *ClusterPeerRemote `json:"remote,omitempty"`

	// status
	Status *ClusterPeerStatus `json:"status,omitempty"`

	// UUID of the cluster peer relationship. For anonymous cluster peer offers, the UUID will change when the remote cluster accepts the relationship.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// version
	Version *ClusterPeerVersion `json:"version,omitempty"`
}

// Validate validates this cluster peer
func (m *ClusterPeer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitialAllowedSvms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeerApplications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemote(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeer) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) validateAuthentication(formats strfmt.Registry) error {
	if swag.IsZero(m.Authentication) { // not required
		return nil
	}

	if m.Authentication != nil {
		if err := m.Authentication.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authentication")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) validateEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.Encryption) { // not required
		return nil
	}

	if m.Encryption != nil {
		if err := m.Encryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) validateInitialAllowedSvms(formats strfmt.Registry) error {
	if swag.IsZero(m.InitialAllowedSvms) { // not required
		return nil
	}

	for i := 0; i < len(m.InitialAllowedSvms); i++ {
		if swag.IsZero(m.InitialAllowedSvms[i]) { // not required
			continue
		}

		if m.InitialAllowedSvms[i] != nil {
			if err := m.InitialAllowedSvms[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("initial_allowed_svms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterPeer) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) validateLocalNetwork(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalNetwork) { // not required
		return nil
	}

	if m.LocalNetwork != nil {
		if err := m.LocalNetwork.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local_network")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) validatePeerApplications(formats strfmt.Registry) error {
	if swag.IsZero(m.PeerApplications) { // not required
		return nil
	}

	for i := 0; i < len(m.PeerApplications); i++ {

		if err := m.PeerApplications[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("peer_applications" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *ClusterPeer) validateRemote(formats strfmt.Registry) error {
	if swag.IsZero(m.Remote) { // not required
		return nil
	}

	if m.Remote != nil {
		if err := m.Remote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster peer based on the context it is used
func (m *ClusterPeer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthentication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInitialAllowedSvms(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalNetwork(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeerApplications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemote(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeer) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) contextValidateAuthentication(ctx context.Context, formats strfmt.Registry) error {

	if m.Authentication != nil {
		if err := m.Authentication.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authentication")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) contextValidateEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.Encryption != nil {
		if err := m.Encryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) contextValidateInitialAllowedSvms(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.InitialAllowedSvms); i++ {

		if m.InitialAllowedSvms[i] != nil {
			if err := m.InitialAllowedSvms[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("initial_allowed_svms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterPeer) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) contextValidateLocalNetwork(ctx context.Context, formats strfmt.Registry) error {

	if m.LocalNetwork != nil {
		if err := m.LocalNetwork.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local_network")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) contextValidatePeerApplications(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PeerApplications); i++ {

		if err := m.PeerApplications[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("peer_applications" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *ClusterPeer) contextValidateRemote(ctx context.Context, formats strfmt.Registry) error {

	if m.Remote != nil {
		if err := m.Remote.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeer) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeer) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeer) UnmarshalBinary(b []byte) error {
	var res ClusterPeer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerAuthentication cluster peer authentication
//
// swagger:model ClusterPeerAuthentication
type ClusterPeerAuthentication struct {

	// The time when the passphrase will expire, in ISO 8601 duration format or date and time format.  The default is 1 hour.
	// Example: P1DT2H3M4S or '2017-01-25T11:20:13Z'
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Auto generate a passphrase when true.
	GeneratePassphrase *bool `json:"generate_passphrase,omitempty"`

	// in use
	// Enum: [ok absent revoked]
	InUse *string `json:"in_use,omitempty"`

	// A password to authenticate the cluster peer relationship.
	Passphrase string `json:"passphrase,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok absent pending problem]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster peer authentication
func (m *ClusterPeerAuthentication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInUse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterPeerAuthenticationTypeInUsePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","absent","revoked"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterPeerAuthenticationTypeInUsePropEnum = append(clusterPeerAuthenticationTypeInUsePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerAuthentication
	// ClusterPeerAuthentication
	// in_use
	// InUse
	// ok
	// END RIPPY DEBUGGING
	// ClusterPeerAuthenticationInUseOk captures enum value "ok"
	ClusterPeerAuthenticationInUseOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerAuthentication
	// ClusterPeerAuthentication
	// in_use
	// InUse
	// absent
	// END RIPPY DEBUGGING
	// ClusterPeerAuthenticationInUseAbsent captures enum value "absent"
	ClusterPeerAuthenticationInUseAbsent string = "absent"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerAuthentication
	// ClusterPeerAuthentication
	// in_use
	// InUse
	// revoked
	// END RIPPY DEBUGGING
	// ClusterPeerAuthenticationInUseRevoked captures enum value "revoked"
	ClusterPeerAuthenticationInUseRevoked string = "revoked"
)

// prop value enum
func (m *ClusterPeerAuthentication) validateInUseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterPeerAuthenticationTypeInUsePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterPeerAuthentication) validateInUse(formats strfmt.Registry) error {
	if swag.IsZero(m.InUse) { // not required
		return nil
	}

	// value enum
	if err := m.validateInUseEnum("authentication"+"."+"in_use", "body", *m.InUse); err != nil {
		return err
	}

	return nil
}

var clusterPeerAuthenticationTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","absent","pending","problem"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterPeerAuthenticationTypeStatePropEnum = append(clusterPeerAuthenticationTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerAuthentication
	// ClusterPeerAuthentication
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// ClusterPeerAuthenticationStateOk captures enum value "ok"
	ClusterPeerAuthenticationStateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerAuthentication
	// ClusterPeerAuthentication
	// state
	// State
	// absent
	// END RIPPY DEBUGGING
	// ClusterPeerAuthenticationStateAbsent captures enum value "absent"
	ClusterPeerAuthenticationStateAbsent string = "absent"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerAuthentication
	// ClusterPeerAuthentication
	// state
	// State
	// pending
	// END RIPPY DEBUGGING
	// ClusterPeerAuthenticationStatePending captures enum value "pending"
	ClusterPeerAuthenticationStatePending string = "pending"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerAuthentication
	// ClusterPeerAuthentication
	// state
	// State
	// problem
	// END RIPPY DEBUGGING
	// ClusterPeerAuthenticationStateProblem captures enum value "problem"
	ClusterPeerAuthenticationStateProblem string = "problem"
)

// prop value enum
func (m *ClusterPeerAuthentication) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterPeerAuthenticationTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterPeerAuthentication) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("authentication"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster peer authentication based on the context it is used
func (m *ClusterPeerAuthentication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerAuthentication) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "authentication"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerAuthentication) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerAuthentication) UnmarshalBinary(b []byte) error {
	var res ClusterPeerAuthentication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerEncryption cluster peer encryption
//
// swagger:model ClusterPeerEncryption
type ClusterPeerEncryption struct {

	// proposed
	// Enum: [none tls_psk]
	Proposed *string `json:"proposed,omitempty"`

	// state
	// Read Only: true
	// Enum: [none tls_psk]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster peer encryption
func (m *ClusterPeerEncryption) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProposed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterPeerEncryptionTypeProposedPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","tls_psk"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterPeerEncryptionTypeProposedPropEnum = append(clusterPeerEncryptionTypeProposedPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerEncryption
	// ClusterPeerEncryption
	// proposed
	// Proposed
	// none
	// END RIPPY DEBUGGING
	// ClusterPeerEncryptionProposedNone captures enum value "none"
	ClusterPeerEncryptionProposedNone string = "none"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerEncryption
	// ClusterPeerEncryption
	// proposed
	// Proposed
	// tls_psk
	// END RIPPY DEBUGGING
	// ClusterPeerEncryptionProposedTLSPsk captures enum value "tls_psk"
	ClusterPeerEncryptionProposedTLSPsk string = "tls_psk"
)

// prop value enum
func (m *ClusterPeerEncryption) validateProposedEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterPeerEncryptionTypeProposedPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterPeerEncryption) validateProposed(formats strfmt.Registry) error {
	if swag.IsZero(m.Proposed) { // not required
		return nil
	}

	// value enum
	if err := m.validateProposedEnum("encryption"+"."+"proposed", "body", *m.Proposed); err != nil {
		return err
	}

	return nil
}

var clusterPeerEncryptionTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","tls_psk"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterPeerEncryptionTypeStatePropEnum = append(clusterPeerEncryptionTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerEncryption
	// ClusterPeerEncryption
	// state
	// State
	// none
	// END RIPPY DEBUGGING
	// ClusterPeerEncryptionStateNone captures enum value "none"
	ClusterPeerEncryptionStateNone string = "none"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerEncryption
	// ClusterPeerEncryption
	// state
	// State
	// tls_psk
	// END RIPPY DEBUGGING
	// ClusterPeerEncryptionStateTLSPsk captures enum value "tls_psk"
	ClusterPeerEncryptionStateTLSPsk string = "tls_psk"
)

// prop value enum
func (m *ClusterPeerEncryption) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterPeerEncryptionTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterPeerEncryption) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("encryption"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster peer encryption based on the context it is used
func (m *ClusterPeerEncryption) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerEncryption) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "encryption"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerEncryption) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerEncryption) UnmarshalBinary(b []byte) error {
	var res ClusterPeerEncryption
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerInitialAllowedSvmsItems0 cluster peer initial allowed svms items0
//
// swagger:model ClusterPeerInitialAllowedSvmsItems0
type ClusterPeerInitialAllowedSvmsItems0 struct {

	// links
	Links *ClusterPeerInitialAllowedSvmsItems0Links `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster peer initial allowed svms items0
func (m *ClusterPeerInitialAllowedSvmsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerInitialAllowedSvmsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster peer initial allowed svms items0 based on the context it is used
func (m *ClusterPeerInitialAllowedSvmsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerInitialAllowedSvmsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerInitialAllowedSvmsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerInitialAllowedSvmsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterPeerInitialAllowedSvmsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerInitialAllowedSvmsItems0Links cluster peer initial allowed svms items0 links
//
// swagger:model ClusterPeerInitialAllowedSvmsItems0Links
type ClusterPeerInitialAllowedSvmsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster peer initial allowed svms items0 links
func (m *ClusterPeerInitialAllowedSvmsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerInitialAllowedSvmsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster peer initial allowed svms items0 links based on the context it is used
func (m *ClusterPeerInitialAllowedSvmsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerInitialAllowedSvmsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerInitialAllowedSvmsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerInitialAllowedSvmsItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterPeerInitialAllowedSvmsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerIpspace The IPspace of the local intercluster LIFs.
//
// swagger:model ClusterPeerIpspace
type ClusterPeerIpspace struct {

	// links
	Links *ClusterPeerIpspaceLinks `json:"_links,omitempty"`

	// IPspace name
	// Example: exchange
	Name string `json:"name,omitempty"`

	// IPspace UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster peer ipspace
func (m *ClusterPeerIpspace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerIpspace) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster peer ipspace based on the context it is used
func (m *ClusterPeerIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerIpspace) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerIpspace) UnmarshalBinary(b []byte) error {
	var res ClusterPeerIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerIpspaceLinks cluster peer ipspace links
//
// swagger:model ClusterPeerIpspaceLinks
type ClusterPeerIpspaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster peer ipspace links
func (m *ClusterPeerIpspaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerIpspaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster peer ipspace links based on the context it is used
func (m *ClusterPeerIpspaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerIpspaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerIpspaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerIpspaceLinks) UnmarshalBinary(b []byte) error {
	var res ClusterPeerIpspaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerLinks cluster peer links
//
// swagger:model ClusterPeerLinks
type ClusterPeerLinks struct {

	// interfaces
	Interfaces *Href `json:"interfaces,omitempty"`

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster peer links
func (m *ClusterPeerLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerLinks) validateInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.Interfaces) { // not required
		return nil
	}

	if m.Interfaces != nil {
		if err := m.Interfaces.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "interfaces")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeerLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster peer links based on the context it is used
func (m *ClusterPeerLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerLinks) contextValidateInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if m.Interfaces != nil {
		if err := m.Interfaces.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "interfaces")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterPeerLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerLinks) UnmarshalBinary(b []byte) error {
	var res ClusterPeerLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerLocalNetwork Cluster peering requires an intercluster LIF on each local node. These can be optionally created by specifying a list of IP addresses corresponding to each node.
//
// swagger:model ClusterPeerLocalNetwork
type ClusterPeerLocalNetwork struct {

	// Broadcast domain that is in use within the IPspace.
	// Example: bd1
	BroadcastDomain string `json:"broadcast_domain,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// interfaces
	Interfaces []*ClusterPeerLocalNetworkInterfacesItems0 `json:"interfaces,omitempty"`

	// IPv4 mask or netmask length.
	// Example: 255.255.0.0
	Netmask string `json:"netmask,omitempty"`
}

// Validate validates this cluster peer local network
func (m *ClusterPeerLocalNetwork) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerLocalNetwork) validateInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.Interfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.Interfaces); i++ {
		if swag.IsZero(m.Interfaces[i]) { // not required
			continue
		}

		if m.Interfaces[i] != nil {
			if err := m.Interfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("local_network" + "." + "interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster peer local network based on the context it is used
func (m *ClusterPeerLocalNetwork) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerLocalNetwork) contextValidateInterfaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Interfaces); i++ {

		if m.Interfaces[i] != nil {
			if err := m.Interfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("local_network" + "." + "interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerLocalNetwork) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerLocalNetwork) UnmarshalBinary(b []byte) error {
	var res ClusterPeerLocalNetwork
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerLocalNetworkInterfacesItems0 cluster peer local network interfaces items0
//
// swagger:model ClusterPeerLocalNetworkInterfacesItems0
type ClusterPeerLocalNetworkInterfacesItems0 struct {

	// List of local intercluster IP addresses.
	IPAddress IPAddress `json:"ip_address,omitempty"`
}

// Validate validates this cluster peer local network interfaces items0
func (m *ClusterPeerLocalNetworkInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerLocalNetworkInterfacesItems0) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.IPAddress) { // not required
		return nil
	}

	if err := m.IPAddress.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip_address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster peer local network interfaces items0 based on the context it is used
func (m *ClusterPeerLocalNetworkInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIPAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerLocalNetworkInterfacesItems0) contextValidateIPAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.IPAddress.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip_address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerLocalNetworkInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerLocalNetworkInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterPeerLocalNetworkInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerRemote cluster peer remote
//
// swagger:model ClusterPeerRemote
type ClusterPeerRemote struct {

	// The IPv4 addresses, IPv6 addresses, or hostnames of the peers.
	IPAddresses []IPAddress `json:"ip_addresses,omitempty"`

	// The name of the remote cluster.
	// Example: cluster2
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The serial number of the remote cluster.
	// Example: 4048820-60-9
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`
}

// Validate validates this cluster peer remote
func (m *ClusterPeerRemote) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIPAddresses(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerRemote) validateIPAddresses(formats strfmt.Registry) error {
	if swag.IsZero(m.IPAddresses) { // not required
		return nil
	}

	for i := 0; i < len(m.IPAddresses); i++ {

		if err := m.IPAddresses[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "ip_addresses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this cluster peer remote based on the context it is used
func (m *ClusterPeerRemote) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIPAddresses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerRemote) contextValidateIPAddresses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IPAddresses); i++ {

		if err := m.IPAddresses[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "ip_addresses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *ClusterPeerRemote) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "remote"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeerRemote) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "remote"+"."+"serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerRemote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerRemote) UnmarshalBinary(b []byte) error {
	var res ClusterPeerRemote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerStatus cluster peer status
//
// swagger:model ClusterPeerStatus
type ClusterPeerStatus struct {

	// state
	// Example: available
	// Read Only: true
	// Enum: [available partial unavailable pending unidentified]
	State string `json:"state,omitempty"`

	// The last time the state was updated.
	// Example: 2017-01-25 11:20:13
	// Read Only: true
	// Format: date-time
	UpdateTime *strfmt.DateTime `json:"update_time,omitempty"`
}

// Validate validates this cluster peer status
func (m *ClusterPeerStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterPeerStatusTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["available","partial","unavailable","pending","unidentified"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterPeerStatusTypeStatePropEnum = append(clusterPeerStatusTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerStatus
	// ClusterPeerStatus
	// state
	// State
	// available
	// END RIPPY DEBUGGING
	// ClusterPeerStatusStateAvailable captures enum value "available"
	ClusterPeerStatusStateAvailable string = "available"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerStatus
	// ClusterPeerStatus
	// state
	// State
	// partial
	// END RIPPY DEBUGGING
	// ClusterPeerStatusStatePartial captures enum value "partial"
	ClusterPeerStatusStatePartial string = "partial"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerStatus
	// ClusterPeerStatus
	// state
	// State
	// unavailable
	// END RIPPY DEBUGGING
	// ClusterPeerStatusStateUnavailable captures enum value "unavailable"
	ClusterPeerStatusStateUnavailable string = "unavailable"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerStatus
	// ClusterPeerStatus
	// state
	// State
	// pending
	// END RIPPY DEBUGGING
	// ClusterPeerStatusStatePending captures enum value "pending"
	ClusterPeerStatusStatePending string = "pending"

	// BEGIN RIPPY DEBUGGING
	// ClusterPeerStatus
	// ClusterPeerStatus
	// state
	// State
	// unidentified
	// END RIPPY DEBUGGING
	// ClusterPeerStatusStateUnidentified captures enum value "unidentified"
	ClusterPeerStatusStateUnidentified string = "unidentified"
)

// prop value enum
func (m *ClusterPeerStatus) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterPeerStatusTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterPeerStatus) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("status"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeerStatus) validateUpdateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("status"+"."+"update_time", "body", "date-time", m.UpdateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster peer status based on the context it is used
func (m *ClusterPeerStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerStatus) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeerStatus) contextValidateUpdateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"update_time", "body", m.UpdateTime); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerStatus) UnmarshalBinary(b []byte) error {
	var res ClusterPeerStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeerVersion This returns the cluster version information.  When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.
//
// swagger:model ClusterPeerVersion
type ClusterPeerVersion struct {

	// The full cluster version string.
	// Example: NetApp Release 9.4.0: Sun Nov 05 18:20:57 UTC 2017
	// Read Only: true
	Full string `json:"full,omitempty"`

	// The generation portion of the version.
	// Example: 9
	// Read Only: true
	Generation int64 `json:"generation,omitempty"`

	// The major portion of the version.
	// Example: 4
	// Read Only: true
	Major int64 `json:"major,omitempty"`

	// The minor portion of the version.
	// Example: 0
	// Read Only: true
	Minor int64 `json:"minor,omitempty"`
}

// Validate validates this cluster peer version
func (m *ClusterPeerVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster peer version based on the context it is used
func (m *ClusterPeerVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMajor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeerVersion) contextValidateFull(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"full", "body", string(m.Full)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeerVersion) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeerVersion) contextValidateMajor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"major", "body", int64(m.Major)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeerVersion) contextValidateMinor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"minor", "body", int64(m.Minor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeerVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeerVersion) UnmarshalBinary(b []byte) error {
	var res ClusterPeerVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

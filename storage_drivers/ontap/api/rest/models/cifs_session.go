// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CifsSession cifs session
//
// swagger:model cifs_session
type CifsSession struct {

	// links
	Links *CifsSessionLinks `json:"_links,omitempty"`

	// SMB authentication over which the client accesses the share. The following values are supported:
	// * none - No authentication
	// * ntlmv1 - Ntlm version 1 mechanism
	// * ntlmv2 - Ntlm version 2 mechanism
	// * kerberos - Kerberos authentication
	// * anonymous - Anonymous mechanism
	//
	// Example: ntlmv2
	// Read Only: true
	// Enum: [none ntlmv1 ntlmv2 kerberos anonymous]
	Authentication string `json:"authentication,omitempty"`

	// Specifies IP address of the client.
	//
	// Example: 10.74.7.182
	// Read Only: true
	ClientIP string `json:"client_ip,omitempty"`

	// Specifies an ISO-8601 format of date and time used to retrieve the connected time duration in hours, minutes, and seconds format.
	//
	// Example: P4DT84H30M5S
	// Read Only: true
	ConnectedDuration string `json:"connected_duration,omitempty"`

	// A counter used to track requests that are sent to the volumes to the node.
	//
	// Example: 0
	// Read Only: true
	ConnectionCount int64 `json:"connection_count,omitempty"`

	// A unique 32-bit unsigned number used to represent each SMB session's connection ID.
	//
	// Example: 22802
	// Read Only: true
	ConnectionID int64 `json:"connection_id,omitempty"`

	// The level of continuous availabilty protection provided to the SMB sessions and/or files.
	// * unavailable - Open file is not continuously available. For sessions, it contains one or more open files but none of them are continuously available.
	// * available - open file is continuously available. For sessions, it contains one or more open files and all of them are continuously available.
	// * partial - Sessions only. Contains at least one continuously available open file with other files open but not continuously available.
	//
	// Example: unavailable
	// Read Only: true
	// Enum: [unavailable available partial]
	ContinuousAvailability string `json:"continuous_availability,omitempty"`

	// A unique 64-bit unsigned number used to represent each SMB session's identifier.
	//
	// Example: 4622663542519103000
	// Read Only: true
	Identifier int64 `json:"identifier,omitempty"`

	// Specifies an ISO-8601 format of date and time used to retrieve the idle time duration in hours, minutes, and seconds format.
	//
	// Example: P4DT84H30M5S
	// Read Only: true
	IdleDuration string `json:"idle_duration,omitempty"`

	// Specifies whether the large MTU is enabled or not for an SMB session.
	//
	// Example: true
	// Read Only: true
	LargeMtu *bool `json:"large_mtu,omitempty"`

	// Indicated that a mapped UNIX user has logged in.
	//
	// Example: root
	// Read Only: true
	MappedUnixUser string `json:"mapped_unix_user,omitempty"`

	// node
	Node *CifsSessionNode `json:"node,omitempty"`

	// Number of files the SMB session has opened.
	//
	// Read Only: true
	OpenFiles int64 `json:"open_files,omitempty"`

	// Number of other files the SMB session has opened.
	//
	// Read Only: true
	OpenOther int64 `json:"open_other,omitempty"`

	// Number of shares the SMB session has opened.
	//
	// Read Only: true
	OpenShares int64 `json:"open_shares,omitempty"`

	// The SMB protocol version over which the client accesses the volumes. The following values are supported:
	// * smb1 - SMB version 1
	// * smb2 - SMB version 2
	// * smb2_1 - SMB version 2 minor version 1
	// * smb3 - SMB version 3
	// * smb3_1 - SMB version 3 minor version 1
	//
	// Example: smb3_1
	// Read Only: true
	// Enum: [smb1 smb2 smb2_1 smb3 smb3_1]
	Protocol string `json:"protocol,omitempty"`

	// Specifies the IP address of the SVM.
	//
	// Example: 10.140.78.248
	// Read Only: true
	ServerIP string `json:"server_ip,omitempty"`

	// Indicates an SMB encryption state. The following values are supported:
	// * unencrypted - SMB session is not encrypted
	// * encrypted - SMB session is fully encrypted. SVM level encryption is enabled and encryption occurs for the entire session.
	// * partially_encrypted - SMB session is partially encrypted. Share level encryption is enabled and encryption is initiated when the tree-connect occurs.
	//
	// Example: unencrypted
	// Read Only: true
	// Enum: [unencrypted encrypted partially_encrypted]
	SmbEncryption string `json:"smb_encryption,omitempty"`

	// Specifies whether or not SMB signing is enabled.
	// Example: false
	// Read Only: true
	SmbSigning *bool `json:"smb_signing,omitempty"`

	// svm
	Svm *CifsSessionSvm `json:"svm,omitempty"`

	// Indicates that a Windows user has logged in.
	//
	// Example: NBCIFSQA2\\administrator
	// Read Only: true
	User string `json:"user,omitempty"`

	// A group of volumes, the client is accessing.
	Volumes []*CifsSessionVolumesItems0 `json:"volumes,omitempty"`
}

// Validate validates this cifs session
func (m *CifsSession) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContinuousAvailability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSmbEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSession) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

var cifsSessionTypeAuthenticationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","ntlmv1","ntlmv2","kerberos","anonymous"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsSessionTypeAuthenticationPropEnum = append(cifsSessionTypeAuthenticationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// authentication
	// Authentication
	// none
	// END DEBUGGING
	// CifsSessionAuthenticationNone captures enum value "none"
	CifsSessionAuthenticationNone string = "none"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// authentication
	// Authentication
	// ntlmv1
	// END DEBUGGING
	// CifsSessionAuthenticationNtlmv1 captures enum value "ntlmv1"
	CifsSessionAuthenticationNtlmv1 string = "ntlmv1"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// authentication
	// Authentication
	// ntlmv2
	// END DEBUGGING
	// CifsSessionAuthenticationNtlmv2 captures enum value "ntlmv2"
	CifsSessionAuthenticationNtlmv2 string = "ntlmv2"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// authentication
	// Authentication
	// kerberos
	// END DEBUGGING
	// CifsSessionAuthenticationKerberos captures enum value "kerberos"
	CifsSessionAuthenticationKerberos string = "kerberos"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// authentication
	// Authentication
	// anonymous
	// END DEBUGGING
	// CifsSessionAuthenticationAnonymous captures enum value "anonymous"
	CifsSessionAuthenticationAnonymous string = "anonymous"
)

// prop value enum
func (m *CifsSession) validateAuthenticationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsSessionTypeAuthenticationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsSession) validateAuthentication(formats strfmt.Registry) error {
	if swag.IsZero(m.Authentication) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthenticationEnum("authentication", "body", m.Authentication); err != nil {
		return err
	}

	return nil
}

var cifsSessionTypeContinuousAvailabilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unavailable","available","partial"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsSessionTypeContinuousAvailabilityPropEnum = append(cifsSessionTypeContinuousAvailabilityPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// continuous_availability
	// ContinuousAvailability
	// unavailable
	// END DEBUGGING
	// CifsSessionContinuousAvailabilityUnavailable captures enum value "unavailable"
	CifsSessionContinuousAvailabilityUnavailable string = "unavailable"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// continuous_availability
	// ContinuousAvailability
	// available
	// END DEBUGGING
	// CifsSessionContinuousAvailabilityAvailable captures enum value "available"
	CifsSessionContinuousAvailabilityAvailable string = "available"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// continuous_availability
	// ContinuousAvailability
	// partial
	// END DEBUGGING
	// CifsSessionContinuousAvailabilityPartial captures enum value "partial"
	CifsSessionContinuousAvailabilityPartial string = "partial"
)

// prop value enum
func (m *CifsSession) validateContinuousAvailabilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsSessionTypeContinuousAvailabilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsSession) validateContinuousAvailability(formats strfmt.Registry) error {
	if swag.IsZero(m.ContinuousAvailability) { // not required
		return nil
	}

	// value enum
	if err := m.validateContinuousAvailabilityEnum("continuous_availability", "body", m.ContinuousAvailability); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

var cifsSessionTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["smb1","smb2","smb2_1","smb3","smb3_1"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsSessionTypeProtocolPropEnum = append(cifsSessionTypeProtocolPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// protocol
	// Protocol
	// smb1
	// END DEBUGGING
	// CifsSessionProtocolSmb1 captures enum value "smb1"
	CifsSessionProtocolSmb1 string = "smb1"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// protocol
	// Protocol
	// smb2
	// END DEBUGGING
	// CifsSessionProtocolSmb2 captures enum value "smb2"
	CifsSessionProtocolSmb2 string = "smb2"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// protocol
	// Protocol
	// smb2_1
	// END DEBUGGING
	// CifsSessionProtocolSmb21 captures enum value "smb2_1"
	CifsSessionProtocolSmb21 string = "smb2_1"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// protocol
	// Protocol
	// smb3
	// END DEBUGGING
	// CifsSessionProtocolSmb3 captures enum value "smb3"
	CifsSessionProtocolSmb3 string = "smb3"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// protocol
	// Protocol
	// smb3_1
	// END DEBUGGING
	// CifsSessionProtocolSmb31 captures enum value "smb3_1"
	CifsSessionProtocolSmb31 string = "smb3_1"
)

// prop value enum
func (m *CifsSession) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsSessionTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsSession) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", m.Protocol); err != nil {
		return err
	}

	return nil
}

var cifsSessionTypeSmbEncryptionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unencrypted","encrypted","partially_encrypted"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsSessionTypeSmbEncryptionPropEnum = append(cifsSessionTypeSmbEncryptionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// smb_encryption
	// SmbEncryption
	// unencrypted
	// END DEBUGGING
	// CifsSessionSmbEncryptionUnencrypted captures enum value "unencrypted"
	CifsSessionSmbEncryptionUnencrypted string = "unencrypted"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// smb_encryption
	// SmbEncryption
	// encrypted
	// END DEBUGGING
	// CifsSessionSmbEncryptionEncrypted captures enum value "encrypted"
	CifsSessionSmbEncryptionEncrypted string = "encrypted"

	// BEGIN DEBUGGING
	// cifs_session
	// CifsSession
	// smb_encryption
	// SmbEncryption
	// partially_encrypted
	// END DEBUGGING
	// CifsSessionSmbEncryptionPartiallyEncrypted captures enum value "partially_encrypted"
	CifsSessionSmbEncryptionPartiallyEncrypted string = "partially_encrypted"
)

// prop value enum
func (m *CifsSession) validateSmbEncryptionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsSessionTypeSmbEncryptionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsSession) validateSmbEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.SmbEncryption) { // not required
		return nil
	}

	// value enum
	if err := m.validateSmbEncryptionEnum("smb_encryption", "body", m.SmbEncryption); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *CifsSession) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cifs session based on the context it is used
func (m *CifsSession) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthentication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClientIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectedDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectionCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectionID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContinuousAvailability(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIdleDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLargeMtu(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMappedUnixUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpenFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpenOther(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpenShares(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtocol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServerIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSmbEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSmbSigning(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSession) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *CifsSession) contextValidateAuthentication(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "authentication", "body", string(m.Authentication)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateClientIP(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "client_ip", "body", string(m.ClientIP)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateConnectedDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connected_duration", "body", string(m.ConnectedDuration)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateConnectionCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connection_count", "body", int64(m.ConnectionCount)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateConnectionID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connection_id", "body", int64(m.ConnectionID)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateContinuousAvailability(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "continuous_availability", "body", string(m.ContinuousAvailability)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "identifier", "body", int64(m.Identifier)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateIdleDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "idle_duration", "body", string(m.IdleDuration)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateLargeMtu(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "large_mtu", "body", m.LargeMtu); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateMappedUnixUser(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mapped_unix_user", "body", string(m.MappedUnixUser)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *CifsSession) contextValidateOpenFiles(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "open_files", "body", int64(m.OpenFiles)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateOpenOther(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "open_other", "body", int64(m.OpenOther)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateOpenShares(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "open_shares", "body", int64(m.OpenShares)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateProtocol(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "protocol", "body", string(m.Protocol)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateServerIP(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "server_ip", "body", string(m.ServerIP)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateSmbEncryption(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "smb_encryption", "body", string(m.SmbEncryption)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateSmbSigning(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "smb_signing", "body", m.SmbSigning); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *CifsSession) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "user", "body", string(m.User)); err != nil {
		return err
	}

	return nil
}

func (m *CifsSession) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSession) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSession) UnmarshalBinary(b []byte) error {
	var res CifsSession
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsSessionLinks cifs session links
//
// swagger:model CifsSessionLinks
type CifsSessionLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cifs session links
func (m *CifsSessionLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs session links based on the context it is used
func (m *CifsSessionLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSessionLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSessionLinks) UnmarshalBinary(b []byte) error {
	var res CifsSessionLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsSessionNode cifs session node
//
// swagger:model CifsSessionNode
type CifsSessionNode struct {

	// links
	Links *CifsSessionNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cifs session node
func (m *CifsSessionNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs session node based on the context it is used
func (m *CifsSessionNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSessionNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSessionNode) UnmarshalBinary(b []byte) error {
	var res CifsSessionNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsSessionNodeLinks cifs session node links
//
// swagger:model CifsSessionNodeLinks
type CifsSessionNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cifs session node links
func (m *CifsSessionNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs session node links based on the context it is used
func (m *CifsSessionNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSessionNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSessionNodeLinks) UnmarshalBinary(b []byte) error {
	var res CifsSessionNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsSessionSvm cifs session svm
//
// swagger:model CifsSessionSvm
type CifsSessionSvm struct {

	// links
	Links *CifsSessionSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cifs session svm
func (m *CifsSessionSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs session svm based on the context it is used
func (m *CifsSessionSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSessionSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSessionSvm) UnmarshalBinary(b []byte) error {
	var res CifsSessionSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsSessionSvmLinks cifs session svm links
//
// swagger:model CifsSessionSvmLinks
type CifsSessionSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cifs session svm links
func (m *CifsSessionSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs session svm links based on the context it is used
func (m *CifsSessionSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSessionSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSessionSvmLinks) UnmarshalBinary(b []byte) error {
	var res CifsSessionSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsSessionVolumesItems0 cifs session volumes items0
//
// swagger:model CifsSessionVolumesItems0
type CifsSessionVolumesItems0 struct {

	// links
	Links *CifsSessionVolumesItems0Links `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cifs session volumes items0
func (m *CifsSessionVolumesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionVolumesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs session volumes items0 based on the context it is used
func (m *CifsSessionVolumesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionVolumesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSessionVolumesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSessionVolumesItems0) UnmarshalBinary(b []byte) error {
	var res CifsSessionVolumesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsSessionVolumesItems0Links cifs session volumes items0 links
//
// swagger:model CifsSessionVolumesItems0Links
type CifsSessionVolumesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cifs session volumes items0 links
func (m *CifsSessionVolumesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionVolumesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs session volumes items0 links based on the context it is used
func (m *CifsSessionVolumesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsSessionVolumesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsSessionVolumesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsSessionVolumesItems0Links) UnmarshalBinary(b []byte) error {
	var res CifsSessionVolumesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

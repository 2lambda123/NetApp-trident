// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FcInterface A Fibre Channel (FC) interface is the logical endpoint for FC network connections to an SVM. An FC interface provides FC access to storage within the interface SVM using either Fibre Channel Protocol or NVMe over Fibre Channel (NVMe/FC).<br/>
// An FC interface is created on an FC port which is located on a cluster node. The FC port must be specified to identify the location of the interface for a POST or PATCH operation that relocates an interface. You can identify the port by supplying either the cluster node and port names or the port UUID.
//
// swagger:model fc_interface
type FcInterface struct {

	// links
	Links *FcInterfaceLinks `json:"_links,omitempty"`

	// A user configurable comment. Optional in POST; valid in PATCH. To clear a prior comment, set the property to an empty string in PATCH.
	//
	Comment string `json:"comment,omitempty"`

	// The data protocol for which the FC interface is configured. Required in POST.
	//
	// Enum: [fcp fc_nvme]
	DataProtocol string `json:"data_protocol,omitempty"`

	// The administrative state of the FC interface. The FC interface can be disabled to block all FC communication with the SVM through this interface. Optional in POST and PATCH; defaults to _true_ (enabled) in POST.
	//
	Enabled *bool `json:"enabled,omitempty"`

	// location
	Location *FcInterfaceLocation `json:"location,omitempty"`

	// metric
	Metric *FcInterfaceMetric `json:"metric,omitempty"`

	// The name of the FC interface. Required in POST; optional in PATCH.
	//
	// Example: fc_lif1
	Name string `json:"name,omitempty"`

	// The port address of the FC interface. Each FC port in an FC switched fabric has its own unique FC port address for routing purposes. The FC port address is assigned by a switch in the fabric when that port logs in to the fabric. This property refers to the address given by a switch to the FC interface when the SVM performs a port login (PLOGI).<br/>
	// This is useful for obtaining statistics and diagnostic information from FC switches.<br/>
	// This is a hexadecimal encoded numeric value.
	//
	// Example: 5060F
	// Read Only: true
	PortAddress string `json:"port_address,omitempty"`

	// The current operational state of the FC interface. The state is set to _down_ if the interface is not enabled.<br/>
	// If the cluster node hosting the port is down or unavailable, no state value is returned.
	//
	// Read Only: true
	// Enum: [up down]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *FcInterfaceStatistics `json:"statistics,omitempty"`

	// svm
	Svm *FcInterfaceSvmType `json:"svm,omitempty"`

	// The unique identifier of the FC interface. Required in the URL.
	//
	// Example: bce9827d-4d8f-60af-c771-6e8e9af2c6f0
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// The world wide node name (WWNN) of the FC interface SVM. The WWNN is generated by ONTAP when Fibre Channel Protocol or the NVMe service is created for the FC interface SVM.
	//
	// Example: 20:00:00:50:56:b4:13:01
	// Read Only: true
	Wwnn string `json:"wwnn,omitempty"`

	// The world wide port name (WWPN) of the FC interface. The WWPN is generated by ONTAP when the FC interface is created.
	//
	// Example: 20:00:00:50:56:b4:13:a8
	// Read Only: true
	Wwpn string `json:"wwpn,omitempty"`
}

// Validate validates this fc interface
func (m *FcInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterface) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

var fcInterfaceTypeDataProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fcp","fc_nvme"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcInterfaceTypeDataProtocolPropEnum = append(fcInterfaceTypeDataProtocolPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// fc_interface
	// FcInterface
	// data_protocol
	// DataProtocol
	// fcp
	// END DEBUGGING
	// FcInterfaceDataProtocolFcp captures enum value "fcp"
	FcInterfaceDataProtocolFcp string = "fcp"

	// BEGIN DEBUGGING
	// fc_interface
	// FcInterface
	// data_protocol
	// DataProtocol
	// fc_nvme
	// END DEBUGGING
	// FcInterfaceDataProtocolFcNvme captures enum value "fc_nvme"
	FcInterfaceDataProtocolFcNvme string = "fc_nvme"
)

// prop value enum
func (m *FcInterface) validateDataProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcInterfaceTypeDataProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcInterface) validateDataProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.DataProtocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataProtocolEnum("data_protocol", "body", m.DataProtocol); err != nil {
		return err
	}

	return nil
}

func (m *FcInterface) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.Location) { // not required
		return nil
	}

	if m.Location != nil {
		if err := m.Location.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterface) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

var fcInterfaceTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcInterfaceTypeStatePropEnum = append(fcInterfaceTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// fc_interface
	// FcInterface
	// state
	// State
	// up
	// END DEBUGGING
	// FcInterfaceStateUp captures enum value "up"
	FcInterfaceStateUp string = "up"

	// BEGIN DEBUGGING
	// fc_interface
	// FcInterface
	// state
	// State
	// down
	// END DEBUGGING
	// FcInterfaceStateDown captures enum value "down"
	FcInterfaceStateDown string = "down"
)

// prop value enum
func (m *FcInterface) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcInterfaceTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcInterface) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *FcInterface) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterface) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface based on the context it is used
func (m *FcInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePortAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWwnn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWwpn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterface) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterface) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.Location != nil {
		if err := m.Location.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterface) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterface) contextValidatePortAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "port_address", "body", string(m.PortAddress)); err != nil {
		return err
	}

	return nil
}

func (m *FcInterface) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *FcInterface) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterface) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterface) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *FcInterface) contextValidateWwnn(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "wwnn", "body", string(m.Wwnn)); err != nil {
		return err
	}

	return nil
}

func (m *FcInterface) contextValidateWwpn(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "wwpn", "body", string(m.Wwpn)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterface) UnmarshalBinary(b []byte) error {
	var res FcInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLinks fc interface links
//
// swagger:model FcInterfaceLinks
type FcInterfaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc interface links
func (m *FcInterfaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface links based on the context it is used
func (m *FcInterfaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLinks) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocation The location of the FC interface is defined by the location of its port. An FC port is identified by its UUID, or a combination of its cluster node name and port name. Either the UUID or the cluster node name and port name are required for POST. To move an interface, supply either the UUID or the cluster node name and port name in a PATCH.<br/>
// The location of an FC interface can be set using "location.home_node" and "location.home_port" during a POST or PATCH. "location.node" and "location.port" refer to the current location of the FC interface. This can be different from "location.home_node" and "location.home_port" in instances where the FC interface failed over due to an offline node.
//
//
// swagger:model FcInterfaceLocation
type FcInterfaceLocation struct {

	// home node
	HomeNode *FcInterfaceLocationHomeNode `json:"home_node,omitempty"`

	// home port
	HomePort *FcInterfaceLocationHomePort `json:"home_port,omitempty"`

	// Indicates whether or not the FC interface currently resides on the home node.
	// Read Only: true
	IsHome *bool `json:"is_home,omitempty"`

	// node
	Node *FcInterfaceLocationNode `json:"node,omitempty"`

	// port
	Port *FcInterfaceLocationPort `json:"port,omitempty"`
}

// Validate validates this fc interface location
func (m *FcInterfaceLocation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHomeNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomePort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocation) validateHomeNode(formats strfmt.Registry) error {
	if swag.IsZero(m.HomeNode) { // not required
		return nil
	}

	if m.HomeNode != nil {
		if err := m.HomeNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocation) validateHomePort(formats strfmt.Registry) error {
	if swag.IsZero(m.HomePort) { // not required
		return nil
	}

	if m.HomePort != nil {
		if err := m.HomePort.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocation) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocation) validatePort(formats strfmt.Registry) error {
	if swag.IsZero(m.Port) { // not required
		return nil
	}

	if m.Port != nil {
		if err := m.Port.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location based on the context it is used
func (m *FcInterfaceLocation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHomeNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHomePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsHome(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocation) contextValidateHomeNode(ctx context.Context, formats strfmt.Registry) error {

	if m.HomeNode != nil {
		if err := m.HomeNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocation) contextValidateHomePort(ctx context.Context, formats strfmt.Registry) error {

	if m.HomePort != nil {
		if err := m.HomePort.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocation) contextValidateIsHome(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location"+"."+"is_home", "body", m.IsHome); err != nil {
		return err
	}

	return nil
}

func (m *FcInterfaceLocation) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocation) contextValidatePort(ctx context.Context, formats strfmt.Registry) error {

	if m.Port != nil {
		if err := m.Port.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocation) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationHomeNode fc interface location home node
//
// swagger:model FcInterfaceLocationHomeNode
type FcInterfaceLocationHomeNode struct {

	// links
	Links *FcInterfaceLocationHomeNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this fc interface location home node
func (m *FcInterfaceLocationHomeNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomeNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location home node based on the context it is used
func (m *FcInterfaceLocationHomeNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomeNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationHomeNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationHomeNode) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationHomeNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationHomeNodeLinks fc interface location home node links
//
// swagger:model FcInterfaceLocationHomeNodeLinks
type FcInterfaceLocationHomeNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc interface location home node links
func (m *FcInterfaceLocationHomeNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomeNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location home node links based on the context it is used
func (m *FcInterfaceLocationHomeNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomeNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationHomeNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationHomeNodeLinks) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationHomeNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationHomePort An FC port is the physical port of an FC adapter on a cluster node that can be connected to an FC network.
//
//
// swagger:model FcInterfaceLocationHomePort
type FcInterfaceLocationHomePort struct {

	// links
	Links *FcInterfaceLocationHomePortLinks `json:"_links,omitempty"`

	// The name of the FC port.
	//
	// Example: 0a
	Name string `json:"name,omitempty"`

	// node
	Node *FcInterfaceLocationHomePortNode `json:"node,omitempty"`

	// The unique identifier of the FC port.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this fc interface location home port
func (m *FcInterfaceLocationHomePort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomePort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocationHomePort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location home port based on the context it is used
func (m *FcInterfaceLocationHomePort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomePort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocationHomePort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationHomePort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationHomePort) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationHomePort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationHomePortLinks fc interface location home port links
//
// swagger:model FcInterfaceLocationHomePortLinks
type FcInterfaceLocationHomePortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc interface location home port links
func (m *FcInterfaceLocationHomePortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomePortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location home port links based on the context it is used
func (m *FcInterfaceLocationHomePortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationHomePortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationHomePortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationHomePortLinks) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationHomePortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationHomePortNode The node on which the FC port is located.
//
//
// swagger:model FcInterfaceLocationHomePortNode
type FcInterfaceLocationHomePortNode struct {

	// The name of the node on which the FC port is located.
	//
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this fc interface location home port node
func (m *FcInterfaceLocationHomePortNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this fc interface location home port node based on context it is used
func (m *FcInterfaceLocationHomePortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationHomePortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationHomePortNode) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationHomePortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationNode fc interface location node
//
// swagger:model FcInterfaceLocationNode
type FcInterfaceLocationNode struct {

	// links
	Links *FcInterfaceLocationNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this fc interface location node
func (m *FcInterfaceLocationNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location node based on the context it is used
func (m *FcInterfaceLocationNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationNode) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationNodeLinks fc interface location node links
//
// swagger:model FcInterfaceLocationNodeLinks
type FcInterfaceLocationNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc interface location node links
func (m *FcInterfaceLocationNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location node links based on the context it is used
func (m *FcInterfaceLocationNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationNodeLinks) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationPort An FC port is the physical port of an FC adapter on a cluster node that can be connected to an FC network.
//
//
// swagger:model FcInterfaceLocationPort
type FcInterfaceLocationPort struct {

	// links
	Links *FcInterfaceLocationPortLinks `json:"_links,omitempty"`

	// The name of the FC port.
	//
	// Example: 0a
	Name string `json:"name,omitempty"`

	// node
	Node *FcInterfaceLocationPortNode `json:"node,omitempty"`

	// The unique identifier of the FC port.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this fc interface location port
func (m *FcInterfaceLocationPort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationPort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocationPort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location port based on the context it is used
func (m *FcInterfaceLocationPort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationPort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceLocationPort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationPort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationPort) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationPort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationPortLinks fc interface location port links
//
// swagger:model FcInterfaceLocationPortLinks
type FcInterfaceLocationPortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc interface location port links
func (m *FcInterfaceLocationPortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationPortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface location port links based on the context it is used
func (m *FcInterfaceLocationPortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceLocationPortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationPortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationPortLinks) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationPortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceLocationPortNode The node on which the FC port is located.
//
//
// swagger:model FcInterfaceLocationPortNode
type FcInterfaceLocationPortNode struct {

	// The name of the node on which the FC port is located.
	//
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this fc interface location port node
func (m *FcInterfaceLocationPortNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this fc interface location port node based on context it is used
func (m *FcInterfaceLocationPortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceLocationPortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceLocationPortNode) UnmarshalBinary(b []byte) error {
	var res FcInterfaceLocationPortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceMetric Performance numbers, such as IOPS latency and throughput
//
// swagger:model FcInterfaceMetric
type FcInterfaceMetric struct {

	// links
	Links *FcInterfaceMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *FcInterfaceMetricIops `json:"iops,omitempty"`

	// latency
	Latency *FcInterfaceMetricLatency `json:"latency,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *FcInterfaceMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this fc interface metric
func (m *FcInterfaceMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var fcInterfaceMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcInterfaceMetricTypeDurationPropEnum = append(fcInterfaceMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// FcInterfaceMetricDurationPT15S captures enum value "PT15S"
	FcInterfaceMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// FcInterfaceMetricDurationPT4M captures enum value "PT4M"
	FcInterfaceMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// FcInterfaceMetricDurationPT30M captures enum value "PT30M"
	FcInterfaceMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// FcInterfaceMetricDurationPT2H captures enum value "PT2H"
	FcInterfaceMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// FcInterfaceMetricDurationP1D captures enum value "P1D"
	FcInterfaceMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// FcInterfaceMetricDurationPT5M captures enum value "PT5M"
	FcInterfaceMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *FcInterfaceMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcInterfaceMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcInterfaceMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *FcInterfaceMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var fcInterfaceMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcInterfaceMetricTypeStatusPropEnum = append(fcInterfaceMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// FcInterfaceMetricStatusOk captures enum value "ok"
	FcInterfaceMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// FcInterfaceMetricStatusError captures enum value "error"
	FcInterfaceMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// FcInterfaceMetricStatusPartialNoData captures enum value "partial_no_data"
	FcInterfaceMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// FcInterfaceMetricStatusPartialNoResponse captures enum value "partial_no_response"
	FcInterfaceMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// FcInterfaceMetricStatusPartialOtherError captures enum value "partial_other_error"
	FcInterfaceMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// FcInterfaceMetricStatusNegativeDelta captures enum value "negative_delta"
	FcInterfaceMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// not_found
	// END DEBUGGING
	// FcInterfaceMetricStatusNotFound captures enum value "not_found"
	FcInterfaceMetricStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// FcInterfaceMetricStatusBackfilledData captures enum value "backfilled_data"
	FcInterfaceMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// FcInterfaceMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	FcInterfaceMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// FcInterfaceMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	FcInterfaceMetricStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// FcInterfaceMetric
	// FcInterfaceMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// FcInterfaceMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	FcInterfaceMetricStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *FcInterfaceMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcInterfaceMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcInterfaceMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *FcInterfaceMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc interface metric based on the context it is used
func (m *FcInterfaceMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *FcInterfaceMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *FcInterfaceMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceMetric) UnmarshalBinary(b []byte) error {
	var res FcInterfaceMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model FcInterfaceMetricIops
type FcInterfaceMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc interface metric iops
func (m *FcInterfaceMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc interface metric iops based on the context it is used
func (m *FcInterfaceMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceMetricIops) UnmarshalBinary(b []byte) error {
	var res FcInterfaceMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model FcInterfaceMetricLatency
type FcInterfaceMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc interface metric latency
func (m *FcInterfaceMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc interface metric latency based on the context it is used
func (m *FcInterfaceMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceMetricLatency) UnmarshalBinary(b []byte) error {
	var res FcInterfaceMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceMetricLinks fc interface metric links
//
// swagger:model FcInterfaceMetricLinks
type FcInterfaceMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc interface metric links
func (m *FcInterfaceMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface metric links based on the context it is used
func (m *FcInterfaceMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceMetricLinks) UnmarshalBinary(b []byte) error {
	var res FcInterfaceMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model FcInterfaceMetricThroughput
type FcInterfaceMetricThroughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc interface metric throughput
func (m *FcInterfaceMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc interface metric throughput based on the context it is used
func (m *FcInterfaceMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceMetricThroughput) UnmarshalBinary(b []byte) error {
	var res FcInterfaceMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceStatistics These are raw performance numbers, such as IOPS latency and throughput. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster.
//
// swagger:model FcInterfaceStatistics
type FcInterfaceStatistics struct {

	// iops raw
	IopsRaw *FcInterfaceStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *FcInterfaceStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *FcInterfaceStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this fc interface statistics
func (m *FcInterfaceStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var fcInterfaceStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcInterfaceStatisticsTypeStatusPropEnum = append(fcInterfaceStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// FcInterfaceStatisticsStatusOk captures enum value "ok"
	FcInterfaceStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// FcInterfaceStatisticsStatusError captures enum value "error"
	FcInterfaceStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// FcInterfaceStatisticsStatusPartialNoData captures enum value "partial_no_data"
	FcInterfaceStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// FcInterfaceStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	FcInterfaceStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// FcInterfaceStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	FcInterfaceStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// FcInterfaceStatisticsStatusNegativeDelta captures enum value "negative_delta"
	FcInterfaceStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// not_found
	// END DEBUGGING
	// FcInterfaceStatisticsStatusNotFound captures enum value "not_found"
	FcInterfaceStatisticsStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// FcInterfaceStatisticsStatusBackfilledData captures enum value "backfilled_data"
	FcInterfaceStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// FcInterfaceStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	FcInterfaceStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// FcInterfaceStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	FcInterfaceStatisticsStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// FcInterfaceStatistics
	// FcInterfaceStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// FcInterfaceStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	FcInterfaceStatisticsStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *FcInterfaceStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcInterfaceStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcInterfaceStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *FcInterfaceStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc interface statistics based on the context it is used
func (m *FcInterfaceStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *FcInterfaceStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcInterfaceStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceStatistics) UnmarshalBinary(b []byte) error {
	var res FcInterfaceStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceStatisticsIopsRaw The number of I/O operations observed at the storage object. This should be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model FcInterfaceStatisticsIopsRaw
type FcInterfaceStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc interface statistics iops raw
func (m *FcInterfaceStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc interface statistics iops raw based on the context it is used
func (m *FcInterfaceStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res FcInterfaceStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This should be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model FcInterfaceStatisticsLatencyRaw
type FcInterfaceStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc interface statistics latency raw
func (m *FcInterfaceStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc interface statistics latency raw based on the context it is used
func (m *FcInterfaceStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res FcInterfaceStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceStatisticsThroughputRaw Throughput bytes observed at the storage object. This should be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model FcInterfaceStatisticsThroughputRaw
type FcInterfaceStatisticsThroughputRaw struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc interface statistics throughput raw
func (m *FcInterfaceStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc interface statistics throughput raw based on the context it is used
func (m *FcInterfaceStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res FcInterfaceStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceSvmType fc interface svm type
//
// swagger:model FcInterfaceSvmType
type FcInterfaceSvmType struct {

	// links
	Links *FcInterfaceSvmLinksType `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this fc interface svm type
func (m *FcInterfaceSvmType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceSvmType) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface svm type based on the context it is used
func (m *FcInterfaceSvmType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceSvmType) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceSvmType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceSvmType) UnmarshalBinary(b []byte) error {
	var res FcInterfaceSvmType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcInterfaceSvmLinksType fc interface svm links type
//
// swagger:model FcInterfaceSvmLinksType
type FcInterfaceSvmLinksType struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc interface svm links type
func (m *FcInterfaceSvmLinksType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceSvmLinksType) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc interface svm links type based on the context it is used
func (m *FcInterfaceSvmLinksType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcInterfaceSvmLinksType) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcInterfaceSvmLinksType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcInterfaceSvmLinksType) UnmarshalBinary(b []byte) error {
	var res FcInterfaceSvmLinksType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

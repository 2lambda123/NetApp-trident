// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ConsistencyGroupVolume consistency group volume
//
// swagger:model consistency_group_volume
type ConsistencyGroupVolume struct {

	// A comment for the volume. Valid in POST or PATCH.
	// Max Length: 1023
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Language encoding setting for volume. If no language is specified, the volume inherits its SVM language encoding setting.
	// Enum: [ar ar.utf_8 c c.utf_8 cs cs.utf_8 da da.utf_8 de de.utf_8 en en.utf_8 en_us en_us.utf_8 es es.utf_8 fi fi.utf_8 fr fr.utf_8 he he.utf_8 hr hr.utf_8 hu hu.utf_8 it it.utf_8 ja ja.utf_8 ja_jp.932 ja_jp.932.utf_8 ja_jp.pck ja_jp.pck.utf_8 ja_jp.pck_v2 ja_jp.pck_v2.utf_8 ja_v1 ja_v1.utf_8 ko ko.utf_8 nl nl.utf_8 no no.utf_8 pl pl.utf_8 pt pt.utf_8 ro ro.utf_8 ru ru.utf_8 sk sk.utf_8 sl sl.utf_8 sv sv.utf_8 tr tr.utf_8 utf8mb4 zh zh.gbk zh.gbk.utf_8 zh.utf_8 zh_tw zh_tw.big5 zh_tw.big5.utf_8 zh_tw.utf_8]
	Language string `json:"language,omitempty"`

	// Volume name. The name of volume must start with an alphabetic character (a to z or A to Z) or an underscore (_). The name must be 197 or fewer characters in length for FlexGroups, and 203 or fewer characters in length for all other types of volumes. Volume names must be unique within an SVM. Required on POST.
	// Example: vol_cs_dept
	// Max Length: 203
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupVolumeProvisioningOptions `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupVolumeQos `json:"qos,omitempty"`

	// The Snapshot copy policy for this volume.
	//
	SnapshotPolicy *SnapshotPolicyReference `json:"snapshot_policy,omitempty"`

	// space
	Space *ConsistencyGroupVolumeSpaceType `json:"space,omitempty"`

	// tiering
	Tiering *ConsistencyGroupVolumeTiering `json:"tiering,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volume
func (m *ConsistencyGroupVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolume) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 1023); err != nil {
		return err
	}

	return nil
}

var consistencyGroupVolumeTypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","ar.utf_8","c","c.utf_8","cs","cs.utf_8","da","da.utf_8","de","de.utf_8","en","en.utf_8","en_us","en_us.utf_8","es","es.utf_8","fi","fi.utf_8","fr","fr.utf_8","he","he.utf_8","hr","hr.utf_8","hu","hu.utf_8","it","it.utf_8","ja","ja.utf_8","ja_jp.932","ja_jp.932.utf_8","ja_jp.pck","ja_jp.pck.utf_8","ja_jp.pck_v2","ja_jp.pck_v2.utf_8","ja_v1","ja_v1.utf_8","ko","ko.utf_8","nl","nl.utf_8","no","no.utf_8","pl","pl.utf_8","pt","pt.utf_8","ro","ro.utf_8","ru","ru.utf_8","sk","sk.utf_8","sl","sl.utf_8","sv","sv.utf_8","tr","tr.utf_8","utf8mb4","zh","zh.gbk","zh.gbk.utf_8","zh.utf_8","zh_tw","zh_tw.big5","zh_tw.big5.utf_8","zh_tw.utf_8"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeTypeLanguagePropEnum = append(consistencyGroupVolumeTypeLanguagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ar
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageAr captures enum value "ar"
	ConsistencyGroupVolumeLanguageAr string = "ar"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ar.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageArDotUTF8 captures enum value "ar.utf_8"
	ConsistencyGroupVolumeLanguageArDotUTF8 string = "ar.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// c
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageC captures enum value "c"
	ConsistencyGroupVolumeLanguageC string = "c"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// c.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageCDotUTF8 captures enum value "c.utf_8"
	ConsistencyGroupVolumeLanguageCDotUTF8 string = "c.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// cs
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageCs captures enum value "cs"
	ConsistencyGroupVolumeLanguageCs string = "cs"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// cs.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageCsDotUTF8 captures enum value "cs.utf_8"
	ConsistencyGroupVolumeLanguageCsDotUTF8 string = "cs.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// da
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDa captures enum value "da"
	ConsistencyGroupVolumeLanguageDa string = "da"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// da.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDaDotUTF8 captures enum value "da.utf_8"
	ConsistencyGroupVolumeLanguageDaDotUTF8 string = "da.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// de
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDe captures enum value "de"
	ConsistencyGroupVolumeLanguageDe string = "de"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// de.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageDeDotUTF8 captures enum value "de.utf_8"
	ConsistencyGroupVolumeLanguageDeDotUTF8 string = "de.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEn captures enum value "en"
	ConsistencyGroupVolumeLanguageEn string = "en"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEnDotUTF8 captures enum value "en.utf_8"
	ConsistencyGroupVolumeLanguageEnDotUTF8 string = "en.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en_us
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEnUs captures enum value "en_us"
	ConsistencyGroupVolumeLanguageEnUs string = "en_us"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// en_us.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEnUsDotUTF8 captures enum value "en_us.utf_8"
	ConsistencyGroupVolumeLanguageEnUsDotUTF8 string = "en_us.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// es
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEs captures enum value "es"
	ConsistencyGroupVolumeLanguageEs string = "es"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// es.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageEsDotUTF8 captures enum value "es.utf_8"
	ConsistencyGroupVolumeLanguageEsDotUTF8 string = "es.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fi
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFi captures enum value "fi"
	ConsistencyGroupVolumeLanguageFi string = "fi"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fi.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFiDotUTF8 captures enum value "fi.utf_8"
	ConsistencyGroupVolumeLanguageFiDotUTF8 string = "fi.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fr
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFr captures enum value "fr"
	ConsistencyGroupVolumeLanguageFr string = "fr"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// fr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageFrDotUTF8 captures enum value "fr.utf_8"
	ConsistencyGroupVolumeLanguageFrDotUTF8 string = "fr.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// he
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHe captures enum value "he"
	ConsistencyGroupVolumeLanguageHe string = "he"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// he.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHeDotUTF8 captures enum value "he.utf_8"
	ConsistencyGroupVolumeLanguageHeDotUTF8 string = "he.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hr
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHr captures enum value "hr"
	ConsistencyGroupVolumeLanguageHr string = "hr"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHrDotUTF8 captures enum value "hr.utf_8"
	ConsistencyGroupVolumeLanguageHrDotUTF8 string = "hr.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hu
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHu captures enum value "hu"
	ConsistencyGroupVolumeLanguageHu string = "hu"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// hu.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageHuDotUTF8 captures enum value "hu.utf_8"
	ConsistencyGroupVolumeLanguageHuDotUTF8 string = "hu.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// it
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageIt captures enum value "it"
	ConsistencyGroupVolumeLanguageIt string = "it"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// it.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageItDotUTF8 captures enum value "it.utf_8"
	ConsistencyGroupVolumeLanguageItDotUTF8 string = "it.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJa captures enum value "ja"
	ConsistencyGroupVolumeLanguageJa string = "ja"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaDotUTF8 captures enum value "ja.utf_8"
	ConsistencyGroupVolumeLanguageJaDotUTF8 string = "ja.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.932
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDot932 captures enum value "ja_jp.932"
	ConsistencyGroupVolumeLanguageJaJpDot932 string = "ja_jp.932"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.932.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDot932DotUTF8 captures enum value "ja_jp.932.utf_8"
	ConsistencyGroupVolumeLanguageJaJpDot932DotUTF8 string = "ja_jp.932.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPck captures enum value "ja_jp.pck"
	ConsistencyGroupVolumeLanguageJaJpDotPck string = "ja_jp.pck"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPckDotUTF8 captures enum value "ja_jp.pck.utf_8"
	ConsistencyGroupVolumeLanguageJaJpDotPckDotUTF8 string = "ja_jp.pck.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck_v2
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPckV2 captures enum value "ja_jp.pck_v2"
	ConsistencyGroupVolumeLanguageJaJpDotPckV2 string = "ja_jp.pck_v2"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_jp.pck_v2.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaJpDotPckV2DotUTF8 captures enum value "ja_jp.pck_v2.utf_8"
	ConsistencyGroupVolumeLanguageJaJpDotPckV2DotUTF8 string = "ja_jp.pck_v2.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_v1
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaV1 captures enum value "ja_v1"
	ConsistencyGroupVolumeLanguageJaV1 string = "ja_v1"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ja_v1.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageJaV1DotUTF8 captures enum value "ja_v1.utf_8"
	ConsistencyGroupVolumeLanguageJaV1DotUTF8 string = "ja_v1.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ko
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageKo captures enum value "ko"
	ConsistencyGroupVolumeLanguageKo string = "ko"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ko.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageKoDotUTF8 captures enum value "ko.utf_8"
	ConsistencyGroupVolumeLanguageKoDotUTF8 string = "ko.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// nl
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNl captures enum value "nl"
	ConsistencyGroupVolumeLanguageNl string = "nl"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// nl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNlDotUTF8 captures enum value "nl.utf_8"
	ConsistencyGroupVolumeLanguageNlDotUTF8 string = "nl.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// no
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNo captures enum value "no"
	ConsistencyGroupVolumeLanguageNo string = "no"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// no.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageNoDotUTF8 captures enum value "no.utf_8"
	ConsistencyGroupVolumeLanguageNoDotUTF8 string = "no.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pl
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePl captures enum value "pl"
	ConsistencyGroupVolumeLanguagePl string = "pl"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePlDotUTF8 captures enum value "pl.utf_8"
	ConsistencyGroupVolumeLanguagePlDotUTF8 string = "pl.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pt
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePt captures enum value "pt"
	ConsistencyGroupVolumeLanguagePt string = "pt"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// pt.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguagePtDotUTF8 captures enum value "pt.utf_8"
	ConsistencyGroupVolumeLanguagePtDotUTF8 string = "pt.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ro
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRo captures enum value "ro"
	ConsistencyGroupVolumeLanguageRo string = "ro"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ro.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRoDotUTF8 captures enum value "ro.utf_8"
	ConsistencyGroupVolumeLanguageRoDotUTF8 string = "ro.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ru
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRu captures enum value "ru"
	ConsistencyGroupVolumeLanguageRu string = "ru"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// ru.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageRuDotUTF8 captures enum value "ru.utf_8"
	ConsistencyGroupVolumeLanguageRuDotUTF8 string = "ru.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sk
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSk captures enum value "sk"
	ConsistencyGroupVolumeLanguageSk string = "sk"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sk.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSkDotUTF8 captures enum value "sk.utf_8"
	ConsistencyGroupVolumeLanguageSkDotUTF8 string = "sk.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sl
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSl captures enum value "sl"
	ConsistencyGroupVolumeLanguageSl string = "sl"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSlDotUTF8 captures enum value "sl.utf_8"
	ConsistencyGroupVolumeLanguageSlDotUTF8 string = "sl.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sv
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSv captures enum value "sv"
	ConsistencyGroupVolumeLanguageSv string = "sv"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// sv.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageSvDotUTF8 captures enum value "sv.utf_8"
	ConsistencyGroupVolumeLanguageSvDotUTF8 string = "sv.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// tr
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageTr captures enum value "tr"
	ConsistencyGroupVolumeLanguageTr string = "tr"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// tr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageTrDotUTF8 captures enum value "tr.utf_8"
	ConsistencyGroupVolumeLanguageTrDotUTF8 string = "tr.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// utf8mb4
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageUtf8mb4 captures enum value "utf8mb4"
	ConsistencyGroupVolumeLanguageUtf8mb4 string = "utf8mb4"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZh captures enum value "zh"
	ConsistencyGroupVolumeLanguageZh string = "zh"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh.gbk
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhDotGbk captures enum value "zh.gbk"
	ConsistencyGroupVolumeLanguageZhDotGbk string = "zh.gbk"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh.gbk.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhDotGbkDotUTF8 captures enum value "zh.gbk.utf_8"
	ConsistencyGroupVolumeLanguageZhDotGbkDotUTF8 string = "zh.gbk.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhDotUTF8 captures enum value "zh.utf_8"
	ConsistencyGroupVolumeLanguageZhDotUTF8 string = "zh.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTw captures enum value "zh_tw"
	ConsistencyGroupVolumeLanguageZhTw string = "zh_tw"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw.big5
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTwDotBig5 captures enum value "zh_tw.big5"
	ConsistencyGroupVolumeLanguageZhTwDotBig5 string = "zh_tw.big5"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw.big5.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTwDotBig5DotUTF8 captures enum value "zh_tw.big5.utf_8"
	ConsistencyGroupVolumeLanguageZhTwDotBig5DotUTF8 string = "zh_tw.big5.utf_8"

	// BEGIN DEBUGGING
	// consistency_group_volume
	// ConsistencyGroupVolume
	// language
	// Language
	// zh_tw.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumeLanguageZhTwDotUTF8 captures enum value "zh_tw.utf_8"
	ConsistencyGroupVolumeLanguageZhTwDotUTF8 string = "zh_tw.utf_8"
)

// prop value enum
func (m *ConsistencyGroupVolume) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeTypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolume) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(m.Language) { // not required
		return nil
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", m.Language); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 203); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume based on the context it is used
func (m *ConsistencyGroupVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolume) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolume) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolume) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupVolumeProvisioningOptions
type ConsistencyGroupVolumeProvisioningOptions struct {

	// Operation to perform
	// Enum: [create add]
	Action string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count int64 `json:"count,omitempty"`

	// storage service
	StorageService *ConsistencyGroupVolumeProvisioningOptionsStorageService `json:"storage_service,omitempty"`
}

// Validate validates this consistency group volume provisioning options
func (m *ConsistencyGroupVolumeProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumeProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create","add"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeProvisioningOptionsTypeActionPropEnum = append(consistencyGroupVolumeProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptions
	// ConsistencyGroupVolumeProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupVolumeProvisioningOptionsActionCreate string = "create"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptions
	// ConsistencyGroupVolumeProvisioningOptions
	// action
	// Action
	// add
	// END DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsActionAdd captures enum value "add"
	ConsistencyGroupVolumeProvisioningOptionsActionAdd string = "add"
)

// prop value enum
func (m *ConsistencyGroupVolumeProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolumeProvisioningOptions) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume provisioning options based on the context it is used
func (m *ConsistencyGroupVolumeProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeProvisioningOptions) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeProvisioningOptionsStorageService Determines the placement of any storage object created during this operation.
//
//
// swagger:model ConsistencyGroupVolumeProvisioningOptionsStorageService
type ConsistencyGroupVolumeProvisioningOptionsStorageService struct {

	// Storage service name. If not specified, the default value is the most performant for the platform.
	//
	// Enum: [extreme performance value]
	Name string `json:"name,omitempty"`
}

// Validate validates this consistency group volume provisioning options storage service
func (m *ConsistencyGroupVolumeProvisioningOptionsStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumeProvisioningOptionsStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeProvisioningOptionsStorageServiceTypeNamePropEnum = append(consistencyGroupVolumeProvisioningOptionsStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsStorageService
	// ConsistencyGroupVolumeProvisioningOptionsStorageService
	// name
	// Name
	// extreme
	// END DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsStorageServiceNameExtreme captures enum value "extreme"
	ConsistencyGroupVolumeProvisioningOptionsStorageServiceNameExtreme string = "extreme"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsStorageService
	// ConsistencyGroupVolumeProvisioningOptionsStorageService
	// name
	// Name
	// performance
	// END DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsStorageServiceNamePerformance captures enum value "performance"
	ConsistencyGroupVolumeProvisioningOptionsStorageServiceNamePerformance string = "performance"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsStorageService
	// ConsistencyGroupVolumeProvisioningOptionsStorageService
	// name
	// Name
	// value
	// END DEBUGGING
	// ConsistencyGroupVolumeProvisioningOptionsStorageServiceNameValue captures enum value "value"
	ConsistencyGroupVolumeProvisioningOptionsStorageServiceNameValue string = "value"
)

// prop value enum
func (m *ConsistencyGroupVolumeProvisioningOptionsStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeProvisioningOptionsStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeProvisioningOptionsStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("provisioning_options"+"."+"storage_service"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group volume provisioning options storage service based on context it is used
func (m *ConsistencyGroupVolumeProvisioningOptionsStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeProvisioningOptionsStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeProvisioningOptionsStorageService) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeProvisioningOptionsStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeQos The QoS policy for this volume.
//
//
// swagger:model ConsistencyGroupVolumeQos
type ConsistencyGroupVolumeQos struct {

	// policy
	Policy *ConsistencyGroupVolumeQosPolicy `json:"policy,omitempty"`
}

// Validate validates this consistency group volume qos
func (m *ConsistencyGroupVolumeQos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeQos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume qos based on the context it is used
func (m *ConsistencyGroupVolumeQos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeQos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeQos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeQos) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeQos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeQosPolicy The QoS policy
//
//
// swagger:model ConsistencyGroupVolumeQosPolicy
type ConsistencyGroupVolumeQosPolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volume qos policy
func (m *ConsistencyGroupVolumeQosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeQosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volume qos policy based on the context it is used
func (m *ConsistencyGroupVolumeQosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeQosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeQosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeQosPolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeQosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeSpaceType consistency group volume space type
//
// swagger:model ConsistencyGroupVolumeSpaceType
type ConsistencyGroupVolumeSpaceType struct {

	// The available space, in bytes.
	// Read Only: true
	Available int64 `json:"available,omitempty"`

	// Total provisioned size, in bytes.
	Size int64 `json:"size,omitempty"`

	// The virtual space used (includes volume reserves) before storage efficiency, in bytes.
	// Read Only: true
	Used int64 `json:"used,omitempty"`
}

// Validate validates this consistency group volume space type
func (m *ConsistencyGroupVolumeSpaceType) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this consistency group volume space type based on the context it is used
func (m *ConsistencyGroupVolumeSpaceType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumeSpaceType) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolumeSpaceType) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeSpaceType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeSpaceType) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeSpaceType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumeTiering The tiering placement and policy definitions for this volume.
//
//
// swagger:model ConsistencyGroupVolumeTiering
type ConsistencyGroupVolumeTiering struct {

	// Storage tiering placement rules for the object.
	// Enum: [allowed best_effort disallowed required]
	Control string `json:"control,omitempty"`

	// Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold.
	// <br>FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br/>all &dash; Allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br/>auto &dash; Allows tiering of both snapshot and active file system user data to the cloud store<br/>none &dash; Volume blocks are not be tiered to the cloud store.<br/>snapshot_only &dash; Allows tiering of only the volume Snapshot copies not associated with the active file system.
	// <br>The default tiering policy is "snapshot-only" for a FlexVol volume and "none" for a FlexGroup volume. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy it is 31 days.
	//
	// Enum: [all auto backup none snapshot_only]
	Policy string `json:"policy,omitempty"`
}

// Validate validates this consistency group volume tiering
func (m *ConsistencyGroupVolumeTiering) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumeTieringTypeControlPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["allowed","best_effort","disallowed","required"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeTieringTypeControlPropEnum = append(consistencyGroupVolumeTieringTypeControlPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// control
	// Control
	// allowed
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringControlAllowed captures enum value "allowed"
	ConsistencyGroupVolumeTieringControlAllowed string = "allowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// control
	// Control
	// best_effort
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringControlBestEffort captures enum value "best_effort"
	ConsistencyGroupVolumeTieringControlBestEffort string = "best_effort"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// control
	// Control
	// disallowed
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringControlDisallowed captures enum value "disallowed"
	ConsistencyGroupVolumeTieringControlDisallowed string = "disallowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// control
	// Control
	// required
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringControlRequired captures enum value "required"
	ConsistencyGroupVolumeTieringControlRequired string = "required"
)

// prop value enum
func (m *ConsistencyGroupVolumeTiering) validateControlEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeTieringTypeControlPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeTiering) validateControl(formats strfmt.Registry) error {
	if swag.IsZero(m.Control) { // not required
		return nil
	}

	// value enum
	if err := m.validateControlEnum("tiering"+"."+"control", "body", m.Control); err != nil {
		return err
	}

	return nil
}

var consistencyGroupVolumeTieringTypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumeTieringTypePolicyPropEnum = append(consistencyGroupVolumeTieringTypePolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// policy
	// Policy
	// all
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringPolicyAll captures enum value "all"
	ConsistencyGroupVolumeTieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// policy
	// Policy
	// auto
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringPolicyAuto captures enum value "auto"
	ConsistencyGroupVolumeTieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// policy
	// Policy
	// backup
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringPolicyBackup captures enum value "backup"
	ConsistencyGroupVolumeTieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// policy
	// Policy
	// none
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringPolicyNone captures enum value "none"
	ConsistencyGroupVolumeTieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumeTiering
	// ConsistencyGroupVolumeTiering
	// policy
	// Policy
	// snapshot_only
	// END DEBUGGING
	// ConsistencyGroupVolumeTieringPolicySnapshotOnly captures enum value "snapshot_only"
	ConsistencyGroupVolumeTieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *ConsistencyGroupVolumeTiering) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumeTieringTypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumeTiering) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyEnum("tiering"+"."+"policy", "body", m.Policy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group volume tiering based on context it is used
func (m *ConsistencyGroupVolumeTiering) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumeTiering) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumeTiering) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumeTiering
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

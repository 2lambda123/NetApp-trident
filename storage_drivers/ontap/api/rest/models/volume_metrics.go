// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VolumeMetrics Performance numbers, such as IOPS, latency and throughput.
//
// swagger:model volume_metrics
type VolumeMetrics struct {

	// links
	Links *VolumeMetricsLinks `json:"_links,omitempty"`

	// cloud
	Cloud *VolumeMetricsCloud `json:"cloud,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// flexcache
	Flexcache *VolumeMetricsFlexcache `json:"flexcache,omitempty"`

	// iops
	Iops *VolumeMetricsIops `json:"iops,omitempty"`

	// latency
	Latency *VolumeMetricsLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *VolumeMetricsThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume metrics
func (m *VolumeMetrics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloud(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexcache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetrics) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) validateCloud(formats strfmt.Registry) error {
	if swag.IsZero(m.Cloud) { // not required
		return nil
	}

	if m.Cloud != nil {
		if err := m.Cloud.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud")
			}
			return err
		}
	}

	return nil
}

var volumeMetricsTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricsTypeDurationPropEnum = append(volumeMetricsTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// VolumeMetricsDurationPT15S captures enum value "PT15S"
	VolumeMetricsDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// VolumeMetricsDurationPT4M captures enum value "PT4M"
	VolumeMetricsDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// VolumeMetricsDurationPT30M captures enum value "PT30M"
	VolumeMetricsDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// VolumeMetricsDurationPT2H captures enum value "PT2H"
	VolumeMetricsDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// VolumeMetricsDurationP1D captures enum value "P1D"
	VolumeMetricsDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// VolumeMetricsDurationPT5M captures enum value "PT5M"
	VolumeMetricsDurationPT5M string = "PT5M"
)

// prop value enum
func (m *VolumeMetrics) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricsTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetrics) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetrics) validateFlexcache(formats strfmt.Registry) error {
	if swag.IsZero(m.Flexcache) { // not required
		return nil
	}

	if m.Flexcache != nil {
		if err := m.Flexcache.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency")
			}
			return err
		}
	}

	return nil
}

var volumeMetricsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricsTypeStatusPropEnum = append(volumeMetricsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeMetricsStatusOk captures enum value "ok"
	VolumeMetricsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeMetricsStatusError captures enum value "error"
	VolumeMetricsStatusError string = "error"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeMetricsStatusPartialNoData captures enum value "partial_no_data"
	VolumeMetricsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeMetricsStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeMetricsStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeMetricsStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeMetricsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeMetricsStatusPartialOtherError captures enum value "partial_other_error"
	VolumeMetricsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeMetricsStatusNegativeDelta captures enum value "negative_delta"
	VolumeMetricsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeMetricsStatusBackfilledData captures enum value "backfilled_data"
	VolumeMetricsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeMetricsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeMetricsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// volume_metrics
	// VolumeMetrics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeMetricsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeMetricsStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeMetrics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetrics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetrics) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throughput")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume metrics based on the context it is used
func (m *VolumeMetrics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloud(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexcache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetrics) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) contextValidateCloud(ctx context.Context, formats strfmt.Registry) error {

	if m.Cloud != nil {
		if err := m.Cloud.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetrics) contextValidateFlexcache(ctx context.Context, formats strfmt.Registry) error {

	if m.Flexcache != nil {
		if err := m.Flexcache.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetrics) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throughput")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetrics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetrics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetrics) UnmarshalBinary(b []byte) error {
	var res VolumeMetrics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsCloud Performance numbers (IOPS and latency) for cloud store. These numbers are relevant only for volumes hosted on FabricPools.
//
// swagger:model VolumeMetricsCloud
type VolumeMetricsCloud struct {

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *VolumeMetricsCloudIops `json:"iops,omitempty"`

	// latency
	Latency *VolumeMetricsCloudLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume metrics cloud
func (m *VolumeMetricsCloud) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeMetricsCloudTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricsCloudTypeDurationPropEnum = append(volumeMetricsCloudTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// VolumeMetricsCloudDurationPT15S captures enum value "PT15S"
	VolumeMetricsCloudDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// VolumeMetricsCloudDurationPT4M captures enum value "PT4M"
	VolumeMetricsCloudDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// VolumeMetricsCloudDurationPT30M captures enum value "PT30M"
	VolumeMetricsCloudDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// VolumeMetricsCloudDurationPT2H captures enum value "PT2H"
	VolumeMetricsCloudDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// VolumeMetricsCloudDurationP1D captures enum value "P1D"
	VolumeMetricsCloudDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// VolumeMetricsCloudDurationPT5M captures enum value "PT5M"
	VolumeMetricsCloudDurationPT5M string = "PT5M"
)

// prop value enum
func (m *VolumeMetricsCloud) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricsCloudTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricsCloud) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("cloud"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricsCloud) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetricsCloud) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var volumeMetricsCloudTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricsCloudTypeStatusPropEnum = append(volumeMetricsCloudTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeMetricsCloudStatusOk captures enum value "ok"
	VolumeMetricsCloudStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeMetricsCloudStatusError captures enum value "error"
	VolumeMetricsCloudStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeMetricsCloudStatusPartialNoData captures enum value "partial_no_data"
	VolumeMetricsCloudStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeMetricsCloudStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeMetricsCloudStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeMetricsCloudStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeMetricsCloudStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeMetricsCloudStatusPartialOtherError captures enum value "partial_other_error"
	VolumeMetricsCloudStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeMetricsCloudStatusNegativeDelta captures enum value "negative_delta"
	VolumeMetricsCloudStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeMetricsCloudStatusBackfilledData captures enum value "backfilled_data"
	VolumeMetricsCloudStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeMetricsCloudStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeMetricsCloudStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeMetricsCloud
	// VolumeMetricsCloud
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeMetricsCloudStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeMetricsCloudStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeMetricsCloud) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricsCloudTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricsCloud) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("cloud"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricsCloud) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("cloud"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume metrics cloud based on the context it is used
func (m *VolumeMetricsCloud) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricsCloud) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cloud"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricsCloud) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetricsCloud) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetricsCloud) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cloud"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricsCloud) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cloud"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsCloud) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsCloud) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsCloud
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsCloudIops The rate of I/O operations observed at the storage object.
//
// swagger:model VolumeMetricsCloudIops
type VolumeMetricsCloudIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metrics cloud iops
func (m *VolumeMetricsCloudIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metrics cloud iops based on the context it is used
func (m *VolumeMetricsCloudIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsCloudIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsCloudIops) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsCloudIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsCloudLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model VolumeMetricsCloudLatency
type VolumeMetricsCloudLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metrics cloud latency
func (m *VolumeMetricsCloudLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metrics cloud latency based on the context it is used
func (m *VolumeMetricsCloudLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsCloudLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsCloudLatency) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsCloudLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsFlexcache Performance number for FlexCache used to measure cache effectiveness.
//
// swagger:model VolumeMetricsFlexcache
type VolumeMetricsFlexcache struct {

	// Bandwidth savings denoting the amount of data served locally by the cache, in bytes.
	// Example: 4096
	BandwidthSavings int64 `json:"bandwidth_savings,omitempty"`

	// Cache miss percentage.
	// Example: 20
	CacheMissPercent int64 `json:"cache_miss_percent,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT1D
	// Read Only: true
	// Enum: [PT15S PT5M PT30M PT2H PT1D]
	Duration string `json:"duration,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume metrics flexcache
func (m *VolumeMetricsFlexcache) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeMetricsFlexcacheTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT5M","PT30M","PT2H","PT1D"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricsFlexcacheTypeDurationPropEnum = append(volumeMetricsFlexcacheTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// VolumeMetricsFlexcacheDurationPT15S captures enum value "PT15S"
	VolumeMetricsFlexcacheDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// VolumeMetricsFlexcacheDurationPT5M captures enum value "PT5M"
	VolumeMetricsFlexcacheDurationPT5M string = "PT5M"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// VolumeMetricsFlexcacheDurationPT30M captures enum value "PT30M"
	VolumeMetricsFlexcacheDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// VolumeMetricsFlexcacheDurationPT2H captures enum value "PT2H"
	VolumeMetricsFlexcacheDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// duration
	// Duration
	// PT1D
	// END DEBUGGING
	// VolumeMetricsFlexcacheDurationPT1D captures enum value "PT1D"
	VolumeMetricsFlexcacheDurationPT1D string = "PT1D"
)

// prop value enum
func (m *VolumeMetricsFlexcache) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricsFlexcacheTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricsFlexcache) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("flexcache"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

var volumeMetricsFlexcacheTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricsFlexcacheTypeStatusPropEnum = append(volumeMetricsFlexcacheTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusOk captures enum value "ok"
	VolumeMetricsFlexcacheStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusError captures enum value "error"
	VolumeMetricsFlexcacheStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusPartialNoData captures enum value "partial_no_data"
	VolumeMetricsFlexcacheStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeMetricsFlexcacheStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeMetricsFlexcacheStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusPartialOtherError captures enum value "partial_other_error"
	VolumeMetricsFlexcacheStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusNegativeDelta captures enum value "negative_delta"
	VolumeMetricsFlexcacheStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusBackfilledData captures enum value "backfilled_data"
	VolumeMetricsFlexcacheStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeMetricsFlexcacheStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeMetricsFlexcache
	// VolumeMetricsFlexcache
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeMetricsFlexcacheStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeMetricsFlexcacheStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeMetricsFlexcache) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricsFlexcacheTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricsFlexcache) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("flexcache"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricsFlexcache) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("flexcache"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume metrics flexcache based on the context it is used
func (m *VolumeMetricsFlexcache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricsFlexcache) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flexcache"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricsFlexcache) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flexcache"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricsFlexcache) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flexcache"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsFlexcache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsFlexcache) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsFlexcache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsIops The rate of I/O operations observed at the storage object.
//
// swagger:model VolumeMetricsIops
type VolumeMetricsIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metrics iops
func (m *VolumeMetricsIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metrics iops based on the context it is used
func (m *VolumeMetricsIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsIops) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model VolumeMetricsLatency
type VolumeMetricsLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metrics latency
func (m *VolumeMetricsLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metrics latency based on the context it is used
func (m *VolumeMetricsLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsLatency) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsLinks volume metrics links
//
// swagger:model VolumeMetricsLinks
type VolumeMetricsLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume metrics links
func (m *VolumeMetricsLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricsLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume metrics links based on the context it is used
func (m *VolumeMetricsLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricsLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsLinks) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricsThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model VolumeMetricsThroughput
type VolumeMetricsThroughput struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metrics throughput
func (m *VolumeMetricsThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metrics throughput based on the context it is used
func (m *VolumeMetricsThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricsThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricsThroughput) UnmarshalBinary(b []byte) error {
	var res VolumeMetricsThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

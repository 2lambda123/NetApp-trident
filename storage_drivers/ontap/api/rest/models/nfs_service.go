// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NfsService nfs service
//
// swagger:model nfs_service
type NfsService struct {

	// links
	Links *NfsServiceLinks `json:"_links,omitempty"`

	// Specifies if the NFS service is administratively enabled.
	//
	Enabled *bool `json:"enabled,omitempty"`

	// metric
	Metric *NfsServiceMetric `json:"metric,omitempty"`

	// protocol
	Protocol *NfsServiceProtocol `json:"protocol,omitempty"`

	// Specifies the state of the NFS service on the SVM. The following values are supported:
	//           * online - NFS server is ready to accept client requests.
	//           * offline - NFS server is not ready to accept client requests.
	//
	// Read Only: true
	// Enum: [online offline]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *NfsServiceStatistics `json:"statistics,omitempty"`

	// svm
	Svm *NfsServiceSvm `json:"svm,omitempty"`

	// transport
	Transport *NfsServiceTransport `json:"transport,omitempty"`

	// Specifies whether VMware vstorage feature is enabled.
	VstorageEnabled *bool `json:"vstorage_enabled,omitempty"`
}

// Validate validates this nfs service
func (m *NfsService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransport(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsService) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	if m.Protocol != nil {
		if err := m.Protocol.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protocol")
			}
			return err
		}
	}

	return nil
}

var nfsServiceTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsServiceTypeStatePropEnum = append(nfsServiceTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// nfs_service
	// NfsService
	// state
	// State
	// online
	// END RIPPY DEBUGGING
	// NfsServiceStateOnline captures enum value "online"
	NfsServiceStateOnline string = "online"

	// BEGIN RIPPY DEBUGGING
	// nfs_service
	// NfsService
	// state
	// State
	// offline
	// END RIPPY DEBUGGING
	// NfsServiceStateOffline captures enum value "offline"
	NfsServiceStateOffline string = "offline"
)

// prop value enum
func (m *NfsService) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsServiceTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsService) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *NfsService) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) validateTransport(formats strfmt.Registry) error {
	if swag.IsZero(m.Transport) { // not required
		return nil
	}

	if m.Transport != nil {
		if err := m.Transport.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transport")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service based on the context it is used
func (m *NfsService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtocol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransport(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsService) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) contextValidateProtocol(ctx context.Context, formats strfmt.Registry) error {

	if m.Protocol != nil {
		if err := m.Protocol.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protocol")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NfsService) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *NfsService) contextValidateTransport(ctx context.Context, formats strfmt.Registry) error {

	if m.Transport != nil {
		if err := m.Transport.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transport")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsService) UnmarshalBinary(b []byte) error {
	var res NfsService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceLinks nfs service links
//
// swagger:model NfsServiceLinks
type NfsServiceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this nfs service links
func (m *NfsServiceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service links based on the context it is used
func (m *NfsServiceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceLinks) UnmarshalBinary(b []byte) error {
	var res NfsServiceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceMetric Historical performance numbers, such as IOPS latency and throughput, for SVM-NFS protocol.
//
// swagger:model NfsServiceMetric
type NfsServiceMetric struct {

	// v3
	V3 *NfsServiceMetricV3 `json:"v3,omitempty"`
}

// Validate validates this nfs service metric
func (m *NfsServiceMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateV3(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceMetric) validateV3(formats strfmt.Registry) error {
	if swag.IsZero(m.V3) { // not required
		return nil
	}

	if m.V3 != nil {
		if err := m.V3.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service metric based on the context it is used
func (m *NfsServiceMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateV3(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceMetric) contextValidateV3(ctx context.Context, formats strfmt.Registry) error {

	if m.V3 != nil {
		if err := m.V3.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceMetric) UnmarshalBinary(b []byte) error {
	var res NfsServiceMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceMetricV3 The NFSv3 operations
//
// swagger:model NfsServiceMetricV3
type NfsServiceMetricV3 struct {

	// links
	Links *NfsServiceMetricV3Links `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *NfsServiceMetricV3Iops `json:"iops,omitempty"`

	// latency
	Latency *NfsServiceMetricV3Latency `json:"latency,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *NfsServiceMetricV3Throughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25 11:20:13
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nfs service metric v3
func (m *NfsServiceMetricV3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceMetricV3) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var nfsServiceMetricV3TypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsServiceMetricV3TypeDurationPropEnum = append(nfsServiceMetricV3TypeDurationPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// duration
	// Duration
	// PT15S
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3DurationPT15S captures enum value "PT15S"
	NfsServiceMetricV3DurationPT15S string = "PT15S"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// duration
	// Duration
	// PT4M
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3DurationPT4M captures enum value "PT4M"
	NfsServiceMetricV3DurationPT4M string = "PT4M"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// duration
	// Duration
	// PT30M
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3DurationPT30M captures enum value "PT30M"
	NfsServiceMetricV3DurationPT30M string = "PT30M"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// duration
	// Duration
	// PT2H
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3DurationPT2H captures enum value "PT2H"
	NfsServiceMetricV3DurationPT2H string = "PT2H"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// duration
	// Duration
	// P1D
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3DurationP1D captures enum value "P1D"
	NfsServiceMetricV3DurationP1D string = "P1D"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// duration
	// Duration
	// PT5M
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3DurationPT5M captures enum value "PT5M"
	NfsServiceMetricV3DurationPT5M string = "PT5M"
)

// prop value enum
func (m *NfsServiceMetricV3) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsServiceMetricV3TypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsServiceMetricV3) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"v3"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *NfsServiceMetricV3) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceMetricV3) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var nfsServiceMetricV3TypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsServiceMetricV3TypeStatusPropEnum = append(nfsServiceMetricV3TypeStatusPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// ok
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusOk captures enum value "ok"
	NfsServiceMetricV3StatusOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// error
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusError captures enum value "error"
	NfsServiceMetricV3StatusError string = "error"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// partial_no_data
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusPartialNoData captures enum value "partial_no_data"
	NfsServiceMetricV3StatusPartialNoData string = "partial_no_data"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// partial_no_uuid
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusPartialNoUUID captures enum value "partial_no_uuid"
	NfsServiceMetricV3StatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// partial_no_response
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusPartialNoResponse captures enum value "partial_no_response"
	NfsServiceMetricV3StatusPartialNoResponse string = "partial_no_response"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// partial_other_error
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusPartialOtherError captures enum value "partial_other_error"
	NfsServiceMetricV3StatusPartialOtherError string = "partial_other_error"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// negative_delta
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusNegativeDelta captures enum value "negative_delta"
	NfsServiceMetricV3StatusNegativeDelta string = "negative_delta"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// backfilled_data
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusBackfilledData captures enum value "backfilled_data"
	NfsServiceMetricV3StatusBackfilledData string = "backfilled_data"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// inconsistent_delta_time
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NfsServiceMetricV3StatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceMetricV3
	// NfsServiceMetricV3
	// status
	// Status
	// inconsistent_old_data
	// END RIPPY DEBUGGING
	// NfsServiceMetricV3StatusInconsistentOldData captures enum value "inconsistent_old_data"
	NfsServiceMetricV3StatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *NfsServiceMetricV3) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsServiceMetricV3TypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsServiceMetricV3) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"v3"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NfsServiceMetricV3) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceMetricV3) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"v3"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nfs service metric v3 based on the context it is used
func (m *NfsServiceMetricV3) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceMetricV3) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceMetricV3) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"v3"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *NfsServiceMetricV3) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceMetricV3) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceMetricV3) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"v3"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NfsServiceMetricV3) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceMetricV3) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"v3"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceMetricV3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceMetricV3) UnmarshalBinary(b []byte) error {
	var res NfsServiceMetricV3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceMetricV3Iops The rate of I/O operations observed at the storage object.
//
// swagger:model NfsServiceMetricV3Iops
type NfsServiceMetricV3Iops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nfs service metric v3 iops
func (m *NfsServiceMetricV3Iops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nfs service metric v3 iops based on the context it is used
func (m *NfsServiceMetricV3Iops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceMetricV3Iops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceMetricV3Iops) UnmarshalBinary(b []byte) error {
	var res NfsServiceMetricV3Iops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceMetricV3Latency The round trip latency in microseconds observed at the storage object.
//
// swagger:model NfsServiceMetricV3Latency
type NfsServiceMetricV3Latency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nfs service metric v3 latency
func (m *NfsServiceMetricV3Latency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nfs service metric v3 latency based on the context it is used
func (m *NfsServiceMetricV3Latency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceMetricV3Latency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceMetricV3Latency) UnmarshalBinary(b []byte) error {
	var res NfsServiceMetricV3Latency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceMetricV3Links nfs service metric v3 links
//
// swagger:model NfsServiceMetricV3Links
type NfsServiceMetricV3Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this nfs service metric v3 links
func (m *NfsServiceMetricV3Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceMetricV3Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service metric v3 links based on the context it is used
func (m *NfsServiceMetricV3Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceMetricV3Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "v3" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceMetricV3Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceMetricV3Links) UnmarshalBinary(b []byte) error {
	var res NfsServiceMetricV3Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceMetricV3Throughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model NfsServiceMetricV3Throughput
type NfsServiceMetricV3Throughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nfs service metric v3 throughput
func (m *NfsServiceMetricV3Throughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nfs service metric v3 throughput based on the context it is used
func (m *NfsServiceMetricV3Throughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceMetricV3Throughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceMetricV3Throughput) UnmarshalBinary(b []byte) error {
	var res NfsServiceMetricV3Throughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceProtocol nfs service protocol
//
// swagger:model NfsServiceProtocol
type NfsServiceProtocol struct {

	// Specifies whether NFSv3 protocol is enabled.
	V3Enabled *bool `json:"v3_enabled,omitempty"`

	// Specifies whether NFSv4.0 protocol is enabled.
	V40Enabled *bool `json:"v40_enabled,omitempty"`

	// v40 features
	V40Features *NfsServiceProtocolV40Features `json:"v40_features,omitempty"`

	// Specifies whether NFSv4.1 protocol is enabled.
	V41Enabled *bool `json:"v41_enabled,omitempty"`

	// v41 features
	V41Features *NfsServiceProtocolV41Features `json:"v41_features,omitempty"`

	// Specifies the domain portion of the string form of user and group
	// names as defined by the NFSv4 protocol.
	//
	V4IDDomain *string `json:"v4_id_domain,omitempty"`
}

// Validate validates this nfs service protocol
func (m *NfsServiceProtocol) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateV40Features(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateV41Features(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceProtocol) validateV40Features(formats strfmt.Registry) error {
	if swag.IsZero(m.V40Features) { // not required
		return nil
	}

	if m.V40Features != nil {
		if err := m.V40Features.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protocol" + "." + "v40_features")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceProtocol) validateV41Features(formats strfmt.Registry) error {
	if swag.IsZero(m.V41Features) { // not required
		return nil
	}

	if m.V41Features != nil {
		if err := m.V41Features.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protocol" + "." + "v41_features")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service protocol based on the context it is used
func (m *NfsServiceProtocol) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateV40Features(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateV41Features(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceProtocol) contextValidateV40Features(ctx context.Context, formats strfmt.Registry) error {

	if m.V40Features != nil {
		if err := m.V40Features.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protocol" + "." + "v40_features")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceProtocol) contextValidateV41Features(ctx context.Context, formats strfmt.Registry) error {

	if m.V41Features != nil {
		if err := m.V41Features.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protocol" + "." + "v41_features")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceProtocol) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceProtocol) UnmarshalBinary(b []byte) error {
	var res NfsServiceProtocol
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceProtocolV40Features nfs service protocol v40 features
//
// swagger:model NfsServiceProtocolV40Features
type NfsServiceProtocolV40Features struct {

	// Specifies whether NFSv4.0 ACLs is enabled.
	ACLEnabled *bool `json:"acl_enabled,omitempty"`

	// Specifies whether NFSv4.0 Read Delegation is enabled.
	ReadDelegationEnabled *bool `json:"read_delegation_enabled,omitempty"`

	// Specifies whether NFSv4.0 Write Delegation is enabled.
	WriteDelegationEnabled *bool `json:"write_delegation_enabled,omitempty"`
}

// Validate validates this nfs service protocol v40 features
func (m *NfsServiceProtocolV40Features) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this nfs service protocol v40 features based on context it is used
func (m *NfsServiceProtocolV40Features) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceProtocolV40Features) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceProtocolV40Features) UnmarshalBinary(b []byte) error {
	var res NfsServiceProtocolV40Features
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceProtocolV41Features nfs service protocol v41 features
//
// swagger:model NfsServiceProtocolV41Features
type NfsServiceProtocolV41Features struct {

	// Specifies whether NFSv4.1 ACLs is enabled.
	ACLEnabled *bool `json:"acl_enabled,omitempty"`

	// Specifies whether NFSv4.1 Parallel NFS is enabled.
	PnfsEnabled *bool `json:"pnfs_enabled,omitempty"`

	// Specifies whether NFSv4.1 Read Delegation is enabled.
	ReadDelegationEnabled *bool `json:"read_delegation_enabled,omitempty"`

	// Specifies whether NFSv4.1 Write Delegation is enabled.
	WriteDelegationEnabled *bool `json:"write_delegation_enabled,omitempty"`
}

// Validate validates this nfs service protocol v41 features
func (m *NfsServiceProtocolV41Features) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this nfs service protocol v41 features based on context it is used
func (m *NfsServiceProtocolV41Features) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceProtocolV41Features) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceProtocolV41Features) UnmarshalBinary(b []byte) error {
	var res NfsServiceProtocolV41Features
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceStatistics Realtime performance numbers, such as IOPS latency and throughput, for SVM-NFS protocol.
//
// swagger:model NfsServiceStatistics
type NfsServiceStatistics struct {

	// v3
	V3 *NfsServiceStatisticsV3 `json:"v3,omitempty"`
}

// Validate validates this nfs service statistics
func (m *NfsServiceStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateV3(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceStatistics) validateV3(formats strfmt.Registry) error {
	if swag.IsZero(m.V3) { // not required
		return nil
	}

	if m.V3 != nil {
		if err := m.V3.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service statistics based on the context it is used
func (m *NfsServiceStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateV3(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceStatistics) contextValidateV3(ctx context.Context, formats strfmt.Registry) error {

	if m.V3 != nil {
		if err := m.V3.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceStatistics) UnmarshalBinary(b []byte) error {
	var res NfsServiceStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceStatisticsV3 The NFSv3 operations
//
// swagger:model NfsServiceStatisticsV3
type NfsServiceStatisticsV3 struct {

	// iops raw
	IopsRaw *NfsServiceStatisticsV3IopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *NfsServiceStatisticsV3LatencyRaw `json:"latency_raw,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *NfsServiceStatisticsV3ThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25 11:20:13
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nfs service statistics v3
func (m *NfsServiceStatisticsV3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceStatisticsV3) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceStatisticsV3) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var nfsServiceStatisticsV3TypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsServiceStatisticsV3TypeStatusPropEnum = append(nfsServiceStatisticsV3TypeStatusPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// ok
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusOk captures enum value "ok"
	NfsServiceStatisticsV3StatusOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// error
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusError captures enum value "error"
	NfsServiceStatisticsV3StatusError string = "error"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// partial_no_data
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusPartialNoData captures enum value "partial_no_data"
	NfsServiceStatisticsV3StatusPartialNoData string = "partial_no_data"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// partial_no_uuid
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusPartialNoUUID captures enum value "partial_no_uuid"
	NfsServiceStatisticsV3StatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// partial_no_response
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusPartialNoResponse captures enum value "partial_no_response"
	NfsServiceStatisticsV3StatusPartialNoResponse string = "partial_no_response"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// partial_other_error
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusPartialOtherError captures enum value "partial_other_error"
	NfsServiceStatisticsV3StatusPartialOtherError string = "partial_other_error"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// negative_delta
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusNegativeDelta captures enum value "negative_delta"
	NfsServiceStatisticsV3StatusNegativeDelta string = "negative_delta"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// backfilled_data
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusBackfilledData captures enum value "backfilled_data"
	NfsServiceStatisticsV3StatusBackfilledData string = "backfilled_data"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// inconsistent_delta_time
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NfsServiceStatisticsV3StatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN RIPPY DEBUGGING
	// NfsServiceStatisticsV3
	// NfsServiceStatisticsV3
	// status
	// Status
	// inconsistent_old_data
	// END RIPPY DEBUGGING
	// NfsServiceStatisticsV3StatusInconsistentOldData captures enum value "inconsistent_old_data"
	NfsServiceStatisticsV3StatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *NfsServiceStatisticsV3) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsServiceStatisticsV3TypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsServiceStatisticsV3) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"v3"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NfsServiceStatisticsV3) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceStatisticsV3) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"v3"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nfs service statistics v3 based on the context it is used
func (m *NfsServiceStatisticsV3) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceStatisticsV3) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceStatisticsV3) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceStatisticsV3) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"v3"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NfsServiceStatisticsV3) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "v3" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NfsServiceStatisticsV3) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"v3"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceStatisticsV3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceStatisticsV3) UnmarshalBinary(b []byte) error {
	var res NfsServiceStatisticsV3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceStatisticsV3IopsRaw The number of I/O operations observed at the storage object. This should be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model NfsServiceStatisticsV3IopsRaw
type NfsServiceStatisticsV3IopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nfs service statistics v3 iops raw
func (m *NfsServiceStatisticsV3IopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nfs service statistics v3 iops raw based on the context it is used
func (m *NfsServiceStatisticsV3IopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceStatisticsV3IopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceStatisticsV3IopsRaw) UnmarshalBinary(b []byte) error {
	var res NfsServiceStatisticsV3IopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceStatisticsV3LatencyRaw The raw latency in microseconds observed at the storage object. This should be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model NfsServiceStatisticsV3LatencyRaw
type NfsServiceStatisticsV3LatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nfs service statistics v3 latency raw
func (m *NfsServiceStatisticsV3LatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nfs service statistics v3 latency raw based on the context it is used
func (m *NfsServiceStatisticsV3LatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceStatisticsV3LatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceStatisticsV3LatencyRaw) UnmarshalBinary(b []byte) error {
	var res NfsServiceStatisticsV3LatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceStatisticsV3ThroughputRaw Throughput bytes observed at the storage object. This should be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model NfsServiceStatisticsV3ThroughputRaw
type NfsServiceStatisticsV3ThroughputRaw struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nfs service statistics v3 throughput raw
func (m *NfsServiceStatisticsV3ThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nfs service statistics v3 throughput raw based on the context it is used
func (m *NfsServiceStatisticsV3ThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceStatisticsV3ThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceStatisticsV3ThroughputRaw) UnmarshalBinary(b []byte) error {
	var res NfsServiceStatisticsV3ThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceSvm nfs service svm
//
// swagger:model NfsServiceSvm
type NfsServiceSvm struct {

	// links
	Links *NfsServiceSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this nfs service svm
func (m *NfsServiceSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service svm based on the context it is used
func (m *NfsServiceSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceSvm) UnmarshalBinary(b []byte) error {
	var res NfsServiceSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceSvmLinks nfs service svm links
//
// swagger:model NfsServiceSvmLinks
type NfsServiceSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this nfs service svm links
func (m *NfsServiceSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nfs service svm links based on the context it is used
func (m *NfsServiceSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NfsServiceSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceSvmLinks) UnmarshalBinary(b []byte) error {
	var res NfsServiceSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NfsServiceTransport nfs service transport
//
// swagger:model NfsServiceTransport
type NfsServiceTransport struct {

	// Specifies whether TCP transports are enabled on the server.
	//
	TCPEnabled *bool `json:"tcp_enabled,omitempty"`

	// Specifies whether UDP transports are enabled on the server.
	//
	UDPEnabled *bool `json:"udp_enabled,omitempty"`
}

// Validate validates this nfs service transport
func (m *NfsServiceTransport) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this nfs service transport based on context it is used
func (m *NfsServiceTransport) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NfsServiceTransport) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsServiceTransport) UnmarshalBinary(b []byte) error {
	var res NfsServiceTransport
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CloudTarget cloud target
//
// swagger:model cloud_target
type CloudTarget struct {

	// links
	Links *CloudTargetLinks `json:"_links,omitempty"`

	// Access key ID for AWS_S3 and other S3 compatible provider types.
	AccessKey string `json:"access_key,omitempty"`

	// Authentication used to access the target. SnapMirror does not yet support CAP. Required in POST.
	// Enum: [key cap ec2_iam gcp_sa azure_msi]
	AuthenticationType string `json:"authentication_type,omitempty"`

	// Azure account
	AzureAccount string `json:"azure_account,omitempty"`

	// Azure access key
	// Format: password
	AzurePrivateKey strfmt.Password `json:"azure_private_key,omitempty"`

	// This parameter is available only when auth-type is CAP. It specifies a full URL of the request to a CAP server for retrieving temporary credentials (access-key, secret-pasword, and session token) for accessing the object store.
	// Example: https://123.45.67.89:1234/CAP/api/v1/credentials?agency=myagency\u0026mission=mymission\u0026role=myrole
	CapURL string `json:"cap_url,omitempty"`

	// Is SSL/TLS certificate validation enabled? The default value is true. This can only be modified for SGWS, IBM_COS, and ONTAP_S3 provider types.
	CertificateValidationEnabled bool `json:"certificate_validation_enabled,omitempty"`

	// cluster
	Cluster *CloudTargetCluster `json:"cluster,omitempty"`

	// Data bucket/container name. For FabricLink, a wildcard character "*" can also be specified to indicate that all the buckets in an SVM can use the same target information. However, for containers other than ONTAP, an exact name should be specified.
	// Example: bucket1
	Container string `json:"container,omitempty"`

	// ipspace
	Ipspace *CloudTargetIpspace `json:"ipspace,omitempty"`

	// Cloud target name
	Name string `json:"name,omitempty"`

	// Owner of the target. Allowed values are FabricPool, SnapMirror or S3_SnapMirror. A target can be used by only one feature.
	// Enum: [fabricpool snapmirror s3_snapmirror]
	Owner string `json:"owner,omitempty"`

	// Port number of the object store that ONTAP uses when establishing a connection. Required in POST.
	Port int64 `json:"port,omitempty"`

	// Type of cloud provider. Allowed values depend on owner type. For FabricPool, AliCloud, AWS_S3, Azure_Cloud, GoggleCloud, IBM_COS, SGWS, and ONTAP_S3 are allowed. For SnapMirror, the valid values are AWS_S3 or SGWS. For FabricLink, AWS_S3, SGWS, S3_Compatible, S3EMU, LOOPBACK and ONTAP_S3 are allowed.
	ProviderType string `json:"provider_type,omitempty"`

	// Secret access key for AWS_S3 and other S3 compatible provider types.
	// Format: password
	SecretPassword strfmt.Password `json:"secret_password,omitempty"`

	// Fully qualified domain name of the object store server. Required on POST.  For Amazon S3, server name must be an AWS regional endpoint in the format s3.amazonaws.com or s3-<region>.amazonaws.com, for example, s3-us-west-2.amazonaws.com. The region of the server and the bucket must match. For Azure, if the server is a "blob.core.windows.net" or a "blob.core.usgovcloudapi.net", then a value of azure-account followed by a period is added in front of the server.
	Server string `json:"server,omitempty"`

	// Encryption of data at rest by the object store server for AWS_S3 and other S3 compatible provider types. This is an advanced property. In most cases it is best not to change default value of "sse_s3" for object store servers which support SSE-S3 encryption. The encryption is in addition to any encryption done by ONTAP at a volume or at an aggregate level. Note that changing this option does not change encryption of data which already exist in the object store.
	// Enum: [none sse_s3]
	ServerSideEncryption string `json:"server_side_encryption,omitempty"`

	// Use of the cloud target by SnapMirror.
	// Enum: [data metadata]
	SnapmirrorUse string `json:"snapmirror_use,omitempty"`

	// SSL/HTTPS enabled or not
	SslEnabled *bool `json:"ssl_enabled,omitempty"`

	// svm
	Svm *CloudTargetSvm `json:"svm,omitempty"`

	// URL style used to access S3 bucket.
	// Enum: [path_style virtual_hosted_style]
	URLStyle string `json:"url_style,omitempty"`

	// Use HTTP proxy when connecting to the object store.
	UseHTTPProxy *bool `json:"use_http_proxy,omitempty"`

	// The amount of cloud space used by all the aggregates attached to the target, in bytes. This field is only populated for FabricPool targets. The value is recalculated once every 5 minutes.
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// Cloud target UUID
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cloud target
func (m *CloudTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAzurePrivateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecretPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServerSideEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapmirrorUse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURLStyle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTarget) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

var cloudTargetTypeAuthenticationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["key","cap","ec2_iam","gcp_sa","azure_msi"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloudTargetTypeAuthenticationTypePropEnum = append(cloudTargetTypeAuthenticationTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// authentication_type
	// AuthenticationType
	// key
	// END DEBUGGING
	// CloudTargetAuthenticationTypeKey captures enum value "key"
	CloudTargetAuthenticationTypeKey string = "key"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// authentication_type
	// AuthenticationType
	// cap
	// END DEBUGGING
	// CloudTargetAuthenticationTypeCap captures enum value "cap"
	CloudTargetAuthenticationTypeCap string = "cap"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// authentication_type
	// AuthenticationType
	// ec2_iam
	// END DEBUGGING
	// CloudTargetAuthenticationTypeEc2Iam captures enum value "ec2_iam"
	CloudTargetAuthenticationTypeEc2Iam string = "ec2_iam"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// authentication_type
	// AuthenticationType
	// gcp_sa
	// END DEBUGGING
	// CloudTargetAuthenticationTypeGcpSa captures enum value "gcp_sa"
	CloudTargetAuthenticationTypeGcpSa string = "gcp_sa"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// authentication_type
	// AuthenticationType
	// azure_msi
	// END DEBUGGING
	// CloudTargetAuthenticationTypeAzureMsi captures enum value "azure_msi"
	CloudTargetAuthenticationTypeAzureMsi string = "azure_msi"
)

// prop value enum
func (m *CloudTarget) validateAuthenticationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloudTargetTypeAuthenticationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloudTarget) validateAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthenticationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthenticationTypeEnum("authentication_type", "body", m.AuthenticationType); err != nil {
		return err
	}

	return nil
}

func (m *CloudTarget) validateAzurePrivateKey(formats strfmt.Registry) error {
	if swag.IsZero(m.AzurePrivateKey) { // not required
		return nil
	}

	if err := validate.FormatOf("azure_private_key", "body", "password", m.AzurePrivateKey.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CloudTarget) validateCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Cluster) { // not required
		return nil
	}

	if m.Cluster != nil {
		if err := m.Cluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

func (m *CloudTarget) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

var cloudTargetTypeOwnerPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fabricpool","snapmirror","s3_snapmirror"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloudTargetTypeOwnerPropEnum = append(cloudTargetTypeOwnerPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// owner
	// Owner
	// fabricpool
	// END DEBUGGING
	// CloudTargetOwnerFabricpool captures enum value "fabricpool"
	CloudTargetOwnerFabricpool string = "fabricpool"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// owner
	// Owner
	// snapmirror
	// END DEBUGGING
	// CloudTargetOwnerSnapmirror captures enum value "snapmirror"
	CloudTargetOwnerSnapmirror string = "snapmirror"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// owner
	// Owner
	// s3_snapmirror
	// END DEBUGGING
	// CloudTargetOwnerS3Snapmirror captures enum value "s3_snapmirror"
	CloudTargetOwnerS3Snapmirror string = "s3_snapmirror"
)

// prop value enum
func (m *CloudTarget) validateOwnerEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloudTargetTypeOwnerPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloudTarget) validateOwner(formats strfmt.Registry) error {
	if swag.IsZero(m.Owner) { // not required
		return nil
	}

	// value enum
	if err := m.validateOwnerEnum("owner", "body", m.Owner); err != nil {
		return err
	}

	return nil
}

func (m *CloudTarget) validateSecretPassword(formats strfmt.Registry) error {
	if swag.IsZero(m.SecretPassword) { // not required
		return nil
	}

	if err := validate.FormatOf("secret_password", "body", "password", m.SecretPassword.String(), formats); err != nil {
		return err
	}

	return nil
}

var cloudTargetTypeServerSideEncryptionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","sse_s3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloudTargetTypeServerSideEncryptionPropEnum = append(cloudTargetTypeServerSideEncryptionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// server_side_encryption
	// ServerSideEncryption
	// none
	// END DEBUGGING
	// CloudTargetServerSideEncryptionNone captures enum value "none"
	CloudTargetServerSideEncryptionNone string = "none"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// server_side_encryption
	// ServerSideEncryption
	// sse_s3
	// END DEBUGGING
	// CloudTargetServerSideEncryptionSseS3 captures enum value "sse_s3"
	CloudTargetServerSideEncryptionSseS3 string = "sse_s3"
)

// prop value enum
func (m *CloudTarget) validateServerSideEncryptionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloudTargetTypeServerSideEncryptionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloudTarget) validateServerSideEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.ServerSideEncryption) { // not required
		return nil
	}

	// value enum
	if err := m.validateServerSideEncryptionEnum("server_side_encryption", "body", m.ServerSideEncryption); err != nil {
		return err
	}

	return nil
}

var cloudTargetTypeSnapmirrorUsePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["data","metadata"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloudTargetTypeSnapmirrorUsePropEnum = append(cloudTargetTypeSnapmirrorUsePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// snapmirror_use
	// SnapmirrorUse
	// data
	// END DEBUGGING
	// CloudTargetSnapmirrorUseData captures enum value "data"
	CloudTargetSnapmirrorUseData string = "data"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// snapmirror_use
	// SnapmirrorUse
	// metadata
	// END DEBUGGING
	// CloudTargetSnapmirrorUseMetadata captures enum value "metadata"
	CloudTargetSnapmirrorUseMetadata string = "metadata"
)

// prop value enum
func (m *CloudTarget) validateSnapmirrorUseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloudTargetTypeSnapmirrorUsePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloudTarget) validateSnapmirrorUse(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapmirrorUse) { // not required
		return nil
	}

	// value enum
	if err := m.validateSnapmirrorUseEnum("snapmirror_use", "body", m.SnapmirrorUse); err != nil {
		return err
	}

	return nil
}

func (m *CloudTarget) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

var cloudTargetTypeURLStylePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["path_style","virtual_hosted_style"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloudTargetTypeURLStylePropEnum = append(cloudTargetTypeURLStylePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// url_style
	// URLStyle
	// path_style
	// END DEBUGGING
	// CloudTargetURLStylePathStyle captures enum value "path_style"
	CloudTargetURLStylePathStyle string = "path_style"

	// BEGIN DEBUGGING
	// cloud_target
	// CloudTarget
	// url_style
	// URLStyle
	// virtual_hosted_style
	// END DEBUGGING
	// CloudTargetURLStyleVirtualHostedStyle captures enum value "virtual_hosted_style"
	CloudTargetURLStyleVirtualHostedStyle string = "virtual_hosted_style"
)

// prop value enum
func (m *CloudTarget) validateURLStyleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloudTargetTypeURLStylePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloudTarget) validateURLStyle(formats strfmt.Registry) error {
	if swag.IsZero(m.URLStyle) { // not required
		return nil
	}

	// value enum
	if err := m.validateURLStyleEnum("url_style", "body", m.URLStyle); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cloud target based on the context it is used
func (m *CloudTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTarget) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *CloudTarget) contextValidateCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Cluster != nil {
		if err := m.Cluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

func (m *CloudTarget) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *CloudTarget) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *CloudTarget) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *CloudTarget) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloudTarget) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloudTarget) UnmarshalBinary(b []byte) error {
	var res CloudTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CloudTargetCluster cloud target cluster
//
// swagger:model CloudTargetCluster
type CloudTargetCluster struct {

	// The name of the cluster that owns the cloud target. For POST, this accepts the name of the peer cluster only if the cluster is in switchover state.
	Name string `json:"name,omitempty"`

	// The UUID of the cluster that owns the cloud target. For POST, this accepts the UUID of the peer cluster only if the cluster is in switchover state.
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cloud target cluster
func (m *CloudTargetCluster) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cloud target cluster based on context it is used
func (m *CloudTargetCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CloudTargetCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloudTargetCluster) UnmarshalBinary(b []byte) error {
	var res CloudTargetCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CloudTargetIpspace IPspace to use in order to reach the cloud target.
//
// swagger:model CloudTargetIpspace
type CloudTargetIpspace struct {

	// links
	Links *CloudTargetIpspaceLinks `json:"_links,omitempty"`

	// IPspace name
	// Example: exchange
	Name string `json:"name,omitempty"`

	// IPspace UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cloud target ipspace
func (m *CloudTargetIpspace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetIpspace) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cloud target ipspace based on the context it is used
func (m *CloudTargetIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetIpspace) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloudTargetIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloudTargetIpspace) UnmarshalBinary(b []byte) error {
	var res CloudTargetIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CloudTargetIpspaceLinks cloud target ipspace links
//
// swagger:model CloudTargetIpspaceLinks
type CloudTargetIpspaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cloud target ipspace links
func (m *CloudTargetIpspaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetIpspaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cloud target ipspace links based on the context it is used
func (m *CloudTargetIpspaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetIpspaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloudTargetIpspaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloudTargetIpspaceLinks) UnmarshalBinary(b []byte) error {
	var res CloudTargetIpspaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CloudTargetLinks cloud target links
//
// swagger:model CloudTargetLinks
type CloudTargetLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cloud target links
func (m *CloudTargetLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cloud target links based on the context it is used
func (m *CloudTargetLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloudTargetLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloudTargetLinks) UnmarshalBinary(b []byte) error {
	var res CloudTargetLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CloudTargetSvm This field is only applicable when used for SnapMirror and FabricLink. For POST and PATCH, SVM information is required for SnapMirror and FabricLink targets and not allowed for FabricPool targets.
//
// swagger:model CloudTargetSvm
type CloudTargetSvm struct {

	// links
	Links *CloudTargetSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cloud target svm
func (m *CloudTargetSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cloud target svm based on the context it is used
func (m *CloudTargetSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloudTargetSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloudTargetSvm) UnmarshalBinary(b []byte) error {
	var res CloudTargetSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CloudTargetSvmLinks cloud target svm links
//
// swagger:model CloudTargetSvmLinks
type CloudTargetSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cloud target svm links
func (m *CloudTargetSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cloud target svm links based on the context it is used
func (m *CloudTargetSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloudTargetSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloudTargetSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloudTargetSvmLinks) UnmarshalBinary(b []byte) error {
	var res CloudTargetSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

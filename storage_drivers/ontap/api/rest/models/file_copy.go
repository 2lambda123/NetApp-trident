// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// FileCopy File copy
//
// swagger:model file_copy
type FileCopy struct {

	// The maximum amount of time (in seconds) that the source can be quiesced before a destination file must be made available for read-write traffic.
	// Example: 10
	CutoverTime *int64 `json:"cutover_time,omitempty"`

	// A list of source files along with the destinations they are copied to. If the terminal path component of the destination is a directory, then the source file's basename is replicated in that directory.
	FilesToCopy []*FileCopyFilesToCopyItems0 `json:"files_to_copy,omitempty"`

	// Specifies whether the source file should be held quiescent for the duration of the copy operation.
	HoldQuiescence *bool `json:"hold_quiescence,omitempty"`

	// The maximum amount of data (in bytes) that can be transferred per second in support of this operation.
	MaxThroughput int64 `json:"max_throughput,omitempty"`

	// The maximum amount of time (in seconds) that the source reference file can be quiesced before the corresponding destination file must be made available for read-write traffic.
	// Example: 10
	ReferenceCutoverTime *int64 `json:"reference_cutover_time,omitempty"`

	// reference file
	ReferenceFile *FileCopyReferenceFile `json:"reference_file,omitempty"`
}

// Validate validates this file copy
func (m *FileCopy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFilesToCopy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferenceFile(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopy) validateFilesToCopy(formats strfmt.Registry) error {
	if swag.IsZero(m.FilesToCopy) { // not required
		return nil
	}

	for i := 0; i < len(m.FilesToCopy); i++ {
		if swag.IsZero(m.FilesToCopy[i]) { // not required
			continue
		}

		if m.FilesToCopy[i] != nil {
			if err := m.FilesToCopy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files_to_copy" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileCopy) validateReferenceFile(formats strfmt.Registry) error {
	if swag.IsZero(m.ReferenceFile) { // not required
		return nil
	}

	if m.ReferenceFile != nil {
		if err := m.ReferenceFile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file copy based on the context it is used
func (m *FileCopy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFilesToCopy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReferenceFile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopy) contextValidateFilesToCopy(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FilesToCopy); i++ {

		if m.FilesToCopy[i] != nil {
			if err := m.FilesToCopy[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files_to_copy" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileCopy) contextValidateReferenceFile(ctx context.Context, formats strfmt.Registry) error {

	if m.ReferenceFile != nil {
		if err := m.ReferenceFile.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileCopy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileCopy) UnmarshalBinary(b []byte) error {
	var res FileCopy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileCopyFilesToCopyItems0 file copy files to copy items0
//
// swagger:model FileCopyFilesToCopyItems0
type FileCopyFilesToCopyItems0 struct {

	// destination
	Destination *FileReference `json:"destination,omitempty"`

	// source
	Source *FileReference `json:"source,omitempty"`
}

// Validate validates this file copy files to copy items0
func (m *FileCopyFilesToCopyItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyFilesToCopyItems0) validateDestination(formats strfmt.Registry) error {
	if swag.IsZero(m.Destination) { // not required
		return nil
	}

	if m.Destination != nil {
		if err := m.Destination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

func (m *FileCopyFilesToCopyItems0) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file copy files to copy items0 based on the context it is used
func (m *FileCopyFilesToCopyItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyFilesToCopyItems0) contextValidateDestination(ctx context.Context, formats strfmt.Registry) error {

	if m.Destination != nil {
		if err := m.Destination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

func (m *FileCopyFilesToCopyItems0) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileCopyFilesToCopyItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileCopyFilesToCopyItems0) UnmarshalBinary(b []byte) error {
	var res FileCopyFilesToCopyItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileCopyReferenceFile file copy reference file
//
// swagger:model FileCopyReferenceFile
type FileCopyReferenceFile struct {

	// The source reference file. If a reference file is specified, data for other files being copied will be transferred as a difference from the reference file. This can save bandwidth and destination storage if the specified source files share blocks. If provided, this input must match one of the source file paths. This input need not be provided if only one source file is specified.
	Path string `json:"path,omitempty"`

	// volume
	Volume *FileCopyReferenceFileVolume `json:"volume,omitempty"`
}

// Validate validates this file copy reference file
func (m *FileCopyReferenceFile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyReferenceFile) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file copy reference file based on the context it is used
func (m *FileCopyReferenceFile) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyReferenceFile) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileCopyReferenceFile) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileCopyReferenceFile) UnmarshalBinary(b []byte) error {
	var res FileCopyReferenceFile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileCopyReferenceFileVolume file copy reference file volume
//
// swagger:model FileCopyReferenceFileVolume
type FileCopyReferenceFileVolume struct {

	// links
	Links *FileCopyReferenceFileVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this file copy reference file volume
func (m *FileCopyReferenceFileVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyReferenceFileVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file copy reference file volume based on the context it is used
func (m *FileCopyReferenceFileVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyReferenceFileVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileCopyReferenceFileVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileCopyReferenceFileVolume) UnmarshalBinary(b []byte) error {
	var res FileCopyReferenceFileVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileCopyReferenceFileVolumeLinks file copy reference file volume links
//
// swagger:model FileCopyReferenceFileVolumeLinks
type FileCopyReferenceFileVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file copy reference file volume links
func (m *FileCopyReferenceFileVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyReferenceFileVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file copy reference file volume links based on the context it is used
func (m *FileCopyReferenceFileVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileCopyReferenceFileVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileCopyReferenceFileVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileCopyReferenceFileVolumeLinks) UnmarshalBinary(b []byte) error {
	var res FileCopyReferenceFileVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

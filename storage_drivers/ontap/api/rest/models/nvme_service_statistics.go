// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NvmeServiceStatistics These are raw performance numbers, such as IOPS latency and throughput for SVM protocols. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster.
//
// swagger:model nvme_service_statistics
type NvmeServiceStatistics struct {

	// fc
	Fc *NvmeServiceStatisticsFc `json:"fc,omitempty"`

	// iops raw
	IopsRaw *NvmeServiceStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *NvmeServiceStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// tcp
	TCP *NvmeServiceStatisticsTCP `json:"tcp,omitempty"`

	// throughput raw
	ThroughputRaw *NvmeServiceStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nvme service statistics
func (m *NvmeServiceStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTCP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceStatistics) validateFc(formats strfmt.Registry) error {
	if swag.IsZero(m.Fc) { // not required
		return nil
	}

	if m.Fc != nil {
		if err := m.Fc.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency_raw")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceStatisticsTypeStatusPropEnum = append(nvmeServiceStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// NvmeServiceStatisticsStatusOk captures enum value "ok"
	NvmeServiceStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// NvmeServiceStatisticsStatusError captures enum value "error"
	NvmeServiceStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NvmeServiceStatisticsStatusPartialNoData captures enum value "partial_no_data"
	NvmeServiceStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NvmeServiceStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	NvmeServiceStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NvmeServiceStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	NvmeServiceStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NvmeServiceStatisticsStatusNegativeDelta captures enum value "negative_delta"
	NvmeServiceStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// not_found
	// END DEBUGGING
	// NvmeServiceStatisticsStatusNotFound captures enum value "not_found"
	NvmeServiceStatisticsStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NvmeServiceStatisticsStatusBackfilledData captures enum value "backfilled_data"
	NvmeServiceStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NvmeServiceStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NvmeServiceStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NvmeServiceStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NvmeServiceStatisticsStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// nvme_service_statistics
	// NvmeServiceStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NvmeServiceStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	NvmeServiceStatisticsStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *NvmeServiceStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceStatistics) validateTCP(formats strfmt.Registry) error {
	if swag.IsZero(m.TCP) { // not required
		return nil
	}

	if m.TCP != nil {
		if err := m.TCP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nvme service statistics based on the context it is used
func (m *NvmeServiceStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFc(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTCP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceStatistics) contextValidateFc(ctx context.Context, formats strfmt.Registry) error {

	if m.Fc != nil {
		if err := m.Fc.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceStatistics) contextValidateTCP(ctx context.Context, formats strfmt.Registry) error {

	if m.TCP != nil {
		if err := m.TCP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatistics) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsFc The NVMe/FC portion of the aggregated statistics.
//
// swagger:model NvmeServiceStatisticsFc
type NvmeServiceStatisticsFc struct {

	// iops raw
	IopsRaw *NvmeServiceStatisticsFcIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *NvmeServiceStatisticsFcLatencyRaw `json:"latency_raw,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *NvmeServiceStatisticsFcThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nvme service statistics fc
func (m *NvmeServiceStatisticsFc) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceStatisticsFc) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsFc) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceStatisticsFcTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceStatisticsFcTypeStatusPropEnum = append(nvmeServiceStatisticsFcTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// ok
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusOk captures enum value "ok"
	NvmeServiceStatisticsFcStatusOk string = "ok"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// error
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusError captures enum value "error"
	NvmeServiceStatisticsFcStatusError string = "error"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusPartialNoData captures enum value "partial_no_data"
	NvmeServiceStatisticsFcStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusPartialNoResponse captures enum value "partial_no_response"
	NvmeServiceStatisticsFcStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusPartialOtherError captures enum value "partial_other_error"
	NvmeServiceStatisticsFcStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusNegativeDelta captures enum value "negative_delta"
	NvmeServiceStatisticsFcStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// not_found
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusNotFound captures enum value "not_found"
	NvmeServiceStatisticsFcStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusBackfilledData captures enum value "backfilled_data"
	NvmeServiceStatisticsFcStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NvmeServiceStatisticsFcStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NvmeServiceStatisticsFcStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsFc
	// NvmeServiceStatisticsFc
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NvmeServiceStatisticsFcStatusPartialNoUUID captures enum value "partial_no_uuid"
	NvmeServiceStatisticsFcStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *NvmeServiceStatisticsFc) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceStatisticsFcTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceStatisticsFc) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("fc"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceStatisticsFc) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsFc) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("fc"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nvme service statistics fc based on the context it is used
func (m *NvmeServiceStatisticsFc) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceStatisticsFc) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsFc) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsFc) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fc"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceStatisticsFc) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsFc) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fc"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsFc) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsFc) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsFc
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsFcIopsRaw The number of I/O operations observed at the storage object. This should be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model NvmeServiceStatisticsFcIopsRaw
type NvmeServiceStatisticsFcIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics fc iops raw
func (m *NvmeServiceStatisticsFcIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics fc iops raw based on the context it is used
func (m *NvmeServiceStatisticsFcIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsFcIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsFcIopsRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsFcIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsFcLatencyRaw The raw latency in microseconds observed at the storage object. This should be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model NvmeServiceStatisticsFcLatencyRaw
type NvmeServiceStatisticsFcLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics fc latency raw
func (m *NvmeServiceStatisticsFcLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics fc latency raw based on the context it is used
func (m *NvmeServiceStatisticsFcLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsFcLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsFcLatencyRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsFcLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsFcThroughputRaw Throughput bytes observed at the storage object. This should be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model NvmeServiceStatisticsFcThroughputRaw
type NvmeServiceStatisticsFcThroughputRaw struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics fc throughput raw
func (m *NvmeServiceStatisticsFcThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics fc throughput raw based on the context it is used
func (m *NvmeServiceStatisticsFcThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsFcThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsFcThroughputRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsFcThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsIopsRaw The number of I/O operations observed at the storage object. This should be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model NvmeServiceStatisticsIopsRaw
type NvmeServiceStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics iops raw
func (m *NvmeServiceStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics iops raw based on the context it is used
func (m *NvmeServiceStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This should be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model NvmeServiceStatisticsLatencyRaw
type NvmeServiceStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics latency raw
func (m *NvmeServiceStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics latency raw based on the context it is used
func (m *NvmeServiceStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsTCP The NVMe/TCP portion of the aggregated statistics.
//
// swagger:model NvmeServiceStatisticsTCP
type NvmeServiceStatisticsTCP struct {

	// iops raw
	IopsRaw *NvmeServiceStatisticsTCPIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *NvmeServiceStatisticsTCPLatencyRaw `json:"latency_raw,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *NvmeServiceStatisticsTCPThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nvme service statistics TCP
func (m *NvmeServiceStatisticsTCP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceStatisticsTCP) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsTCP) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceStatisticsTcpTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceStatisticsTcpTypeStatusPropEnum = append(nvmeServiceStatisticsTcpTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// ok
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusOk captures enum value "ok"
	NvmeServiceStatisticsTCPStatusOk string = "ok"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// error
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusError captures enum value "error"
	NvmeServiceStatisticsTCPStatusError string = "error"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusPartialNoData captures enum value "partial_no_data"
	NvmeServiceStatisticsTCPStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusPartialNoResponse captures enum value "partial_no_response"
	NvmeServiceStatisticsTCPStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusPartialOtherError captures enum value "partial_other_error"
	NvmeServiceStatisticsTCPStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusNegativeDelta captures enum value "negative_delta"
	NvmeServiceStatisticsTCPStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// not_found
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusNotFound captures enum value "not_found"
	NvmeServiceStatisticsTCPStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusBackfilledData captures enum value "backfilled_data"
	NvmeServiceStatisticsTCPStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NvmeServiceStatisticsTCPStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NvmeServiceStatisticsTCPStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// NvmeServiceStatisticsTCP
	// NvmeServiceStatisticsTCP
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NvmeServiceStatisticsTCPStatusPartialNoUUID captures enum value "partial_no_uuid"
	NvmeServiceStatisticsTCPStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *NvmeServiceStatisticsTCP) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceStatisticsTcpTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceStatisticsTCP) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("tcp"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceStatisticsTCP) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsTCP) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("tcp"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nvme service statistics TCP based on the context it is used
func (m *NvmeServiceStatisticsTCP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceStatisticsTCP) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsTCP) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsTCP) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tcp"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceStatisticsTCP) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceStatisticsTCP) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tcp"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCP) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsTCP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsTCPIopsRaw The number of I/O operations observed at the storage object. This should be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model NvmeServiceStatisticsTCPIopsRaw
type NvmeServiceStatisticsTCPIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics TCP iops raw
func (m *NvmeServiceStatisticsTCPIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics TCP iops raw based on the context it is used
func (m *NvmeServiceStatisticsTCPIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCPIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCPIopsRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsTCPIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsTCPLatencyRaw The raw latency in microseconds observed at the storage object. This should be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model NvmeServiceStatisticsTCPLatencyRaw
type NvmeServiceStatisticsTCPLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics TCP latency raw
func (m *NvmeServiceStatisticsTCPLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics TCP latency raw based on the context it is used
func (m *NvmeServiceStatisticsTCPLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCPLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCPLatencyRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsTCPLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsTCPThroughputRaw Throughput bytes observed at the storage object. This should be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model NvmeServiceStatisticsTCPThroughputRaw
type NvmeServiceStatisticsTCPThroughputRaw struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics TCP throughput raw
func (m *NvmeServiceStatisticsTCPThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics TCP throughput raw based on the context it is used
func (m *NvmeServiceStatisticsTCPThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCPThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsTCPThroughputRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsTCPThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceStatisticsThroughputRaw Throughput bytes observed at the storage object. This should be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model NvmeServiceStatisticsThroughputRaw
type NvmeServiceStatisticsThroughputRaw struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service statistics throughput raw
func (m *NvmeServiceStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service statistics throughput raw based on the context it is used
func (m *NvmeServiceStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res NvmeServiceStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

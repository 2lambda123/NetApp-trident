// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ApplicationComponent Application component
//
// swagger:model application_component
type ApplicationComponent struct {

	// links
	Links *ApplicationComponentLinks `json:"_links,omitempty"`

	// application
	Application *ApplicationComponentApplication `json:"application,omitempty"`

	// backing storage
	BackingStorage *ApplicationBackingStorage `json:"backing_storage,omitempty"`

	// cifs access
	CifsAccess []*ApplicationCifsProperties `json:"cifs_access,omitempty"`

	// Defines the type of file system that will be installed on this application component.
	// Read Only: true
	// Enum: [m1fs xfs generic]
	FileSystem string `json:"file_system,omitempty"`

	// Host management URL
	// Read Only: true
	HostManagementURL string `json:"host_management_url,omitempty"`

	// L2 Host FQDN
	// Read Only: true
	HostName string `json:"host_name,omitempty"`

	// Application component name
	// Read Only: true
	Name string `json:"name,omitempty"`

	// nfs access
	NfsAccess []*ApplicationNfsProperties `json:"nfs_access,omitempty"`

	// nvme access
	NvmeAccess []*ApplicationNvmeAccess `json:"nvme_access,omitempty"`

	// protection groups
	ProtectionGroups []*ApplicationProtectionGroups `json:"protection_groups,omitempty"`

	// san access
	SanAccess []*ApplicationSanAccess `json:"san_access,omitempty"`

	// storage service
	StorageService *ApplicationComponentStorageService `json:"storage_service,omitempty"`

	// svm
	Svm *ApplicationComponentSvm `json:"svm,omitempty"`

	// The application component UUID. Valid in URL.
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this application component
func (m *ApplicationComponent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApplication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackingStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCifsAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileSystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNvmeAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSanAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponent) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) validateApplication(formats strfmt.Registry) error {
	if swag.IsZero(m.Application) { // not required
		return nil
	}

	if m.Application != nil {
		if err := m.Application.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) validateBackingStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.BackingStorage) { // not required
		return nil
	}

	if m.BackingStorage != nil {
		if err := m.BackingStorage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backing_storage")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) validateCifsAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.CifsAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.CifsAccess); i++ {
		if swag.IsZero(m.CifsAccess[i]) { // not required
			continue
		}

		if m.CifsAccess[i] != nil {
			if err := m.CifsAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var applicationComponentTypeFileSystemPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["m1fs","xfs","generic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		applicationComponentTypeFileSystemPropEnum = append(applicationComponentTypeFileSystemPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// application_component
	// ApplicationComponent
	// file_system
	// FileSystem
	// m1fs
	// END RIPPY DEBUGGING
	// ApplicationComponentFileSystemM1fs captures enum value "m1fs"
	ApplicationComponentFileSystemM1fs string = "m1fs"

	// BEGIN RIPPY DEBUGGING
	// application_component
	// ApplicationComponent
	// file_system
	// FileSystem
	// xfs
	// END RIPPY DEBUGGING
	// ApplicationComponentFileSystemXfs captures enum value "xfs"
	ApplicationComponentFileSystemXfs string = "xfs"

	// BEGIN RIPPY DEBUGGING
	// application_component
	// ApplicationComponent
	// file_system
	// FileSystem
	// generic
	// END RIPPY DEBUGGING
	// ApplicationComponentFileSystemGeneric captures enum value "generic"
	ApplicationComponentFileSystemGeneric string = "generic"
)

// prop value enum
func (m *ApplicationComponent) validateFileSystemEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, applicationComponentTypeFileSystemPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ApplicationComponent) validateFileSystem(formats strfmt.Registry) error {
	if swag.IsZero(m.FileSystem) { // not required
		return nil
	}

	// value enum
	if err := m.validateFileSystemEnum("file_system", "body", m.FileSystem); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponent) validateNfsAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.NfsAccess); i++ {
		if swag.IsZero(m.NfsAccess[i]) { // not required
			continue
		}

		if m.NfsAccess[i] != nil {
			if err := m.NfsAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) validateNvmeAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.NvmeAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.NvmeAccess); i++ {
		if swag.IsZero(m.NvmeAccess[i]) { // not required
			continue
		}

		if m.NvmeAccess[i] != nil {
			if err := m.NvmeAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nvme_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) validateProtectionGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ProtectionGroups); i++ {
		if swag.IsZero(m.ProtectionGroups[i]) { // not required
			continue
		}

		if m.ProtectionGroups[i] != nil {
			if err := m.ProtectionGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("protection_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) validateSanAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.SanAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.SanAccess); i++ {
		if swag.IsZero(m.SanAccess[i]) { // not required
			continue
		}

		if m.SanAccess[i] != nil {
			if err := m.SanAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("san_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application component based on the context it is used
func (m *ApplicationComponent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateApplication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackingStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCifsAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileSystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostManagementURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfsAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNvmeAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectionGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSanAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponent) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) contextValidateApplication(ctx context.Context, formats strfmt.Registry) error {

	if m.Application != nil {
		if err := m.Application.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) contextValidateBackingStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.BackingStorage != nil {
		if err := m.BackingStorage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backing_storage")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) contextValidateCifsAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CifsAccess); i++ {

		if m.CifsAccess[i] != nil {
			if err := m.CifsAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) contextValidateFileSystem(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "file_system", "body", string(m.FileSystem)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponent) contextValidateHostManagementURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "host_management_url", "body", string(m.HostManagementURL)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponent) contextValidateHostName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "host_name", "body", string(m.HostName)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponent) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponent) contextValidateNfsAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NfsAccess); i++ {

		if m.NfsAccess[i] != nil {
			if err := m.NfsAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) contextValidateNvmeAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NvmeAccess); i++ {

		if m.NvmeAccess[i] != nil {
			if err := m.NvmeAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nvme_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) contextValidateProtectionGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ProtectionGroups); i++ {

		if m.ProtectionGroups[i] != nil {
			if err := m.ProtectionGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("protection_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) contextValidateSanAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SanAccess); i++ {

		if m.SanAccess[i] != nil {
			if err := m.SanAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("san_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApplicationComponent) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponent) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationComponent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationComponent) UnmarshalBinary(b []byte) error {
	var res ApplicationComponent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationComponentApplication application component application
//
// swagger:model ApplicationComponentApplication
type ApplicationComponentApplication struct {

	// links
	Links *ApplicationComponentApplicationLinks `json:"_links,omitempty"`

	// Application name
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The application UUID. Valid in URL.
	// Required: true
	// Read Only: true
	UUID string `json:"uuid"`
}

// Validate validates this application component application
func (m *ApplicationComponentApplication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentApplication) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponentApplication) validateUUID(formats strfmt.Registry) error {

	if err := validate.RequiredString("application"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this application component application based on the context it is used
func (m *ApplicationComponentApplication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentApplication) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *ApplicationComponentApplication) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "application"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponentApplication) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "application"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationComponentApplication) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationComponentApplication) UnmarshalBinary(b []byte) error {
	var res ApplicationComponentApplication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationComponentApplicationLinks application component application links
//
// swagger:model ApplicationComponentApplicationLinks
type ApplicationComponentApplicationLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this application component application links
func (m *ApplicationComponentApplicationLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentApplicationLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application component application links based on the context it is used
func (m *ApplicationComponentApplicationLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentApplicationLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationComponentApplicationLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationComponentApplicationLinks) UnmarshalBinary(b []byte) error {
	var res ApplicationComponentApplicationLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationComponentLinks application component links
//
// swagger:model ApplicationComponentLinks
type ApplicationComponentLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this application component links
func (m *ApplicationComponentLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this application component links based on the context it is used
func (m *ApplicationComponentLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationComponentLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationComponentLinks) UnmarshalBinary(b []byte) error {
	var res ApplicationComponentLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationComponentStorageService application component storage service
//
// swagger:model ApplicationComponentStorageService
type ApplicationComponentStorageService struct {

	// Storage service name
	// Read Only: true
	Name string `json:"name,omitempty"`

	// Storage service UUID
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this application component storage service
func (m *ApplicationComponentStorageService) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application component storage service based on the context it is used
func (m *ApplicationComponentStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentStorageService) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "storage_service"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponentStorageService) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "storage_service"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationComponentStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationComponentStorageService) UnmarshalBinary(b []byte) error {
	var res ApplicationComponentStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ApplicationComponentSvm application component svm
//
// swagger:model ApplicationComponentSvm
type ApplicationComponentSvm struct {

	// SVM name
	// Read Only: true
	Name string `json:"name,omitempty"`

	// SVM UUID
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this application component svm
func (m *ApplicationComponentSvm) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this application component svm based on the context it is used
func (m *ApplicationComponentSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApplicationComponentSvm) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "svm"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ApplicationComponentSvm) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "svm"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApplicationComponentSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApplicationComponentSvm) UnmarshalBinary(b []byte) error {
	var res ApplicationComponentSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster Complete cluster information
//
// swagger:model cluster
type Cluster struct {

	// links
	Links *ClusterLinks `json:"_links,omitempty"`

	// certificate
	Certificate *ClusterCertificate `json:"certificate,omitempty"`

	// configuration backup
	ConfigurationBackup *ClusterConfigurationBackup `json:"configuration_backup,omitempty"`

	// contact
	// Example: support@company.com
	Contact string `json:"contact,omitempty"`

	// A list of DNS domains.
	// Domain names have the following requirements:
	// * The name must contain only the following characters: A through Z,
	//   a through z, 0 through 9, ".", "-" or "_".
	// * The first character of each label, delimited by ".", must be one
	//   of the following characters: A through Z or a through z or 0
	//   through 9.
	// * The last character of each label, delimited by ".", must be one of
	//   the following characters: A through Z, a through z, or 0 through 9.
	// * The top level domain must contain only the following characters: A
	//   through Z, a through z.
	// * The system reserves the following names:"all", "local", and "localhost".
	//
	// Example: ["example.com","example2.example3.com"]
	// Max Items: 6
	DNSDomains []string `json:"dns_domains,omitempty"`

	// license
	License *ClusterLicense `json:"license,omitempty"`

	// location
	// Example: building 1
	Location string `json:"location,omitempty"`

	// management interface
	ManagementInterface *ClusterManagementInterface `json:"management_interface,omitempty"`

	// management interfaces
	// Read Only: true
	ManagementInterfaces []*ClusterManagementInterfacesItems0 `json:"management_interfaces,omitempty"`

	// metric
	Metric *ClusterMetric `json:"metric,omitempty"`

	// name
	// Example: cluster1
	Name string `json:"name,omitempty"`

	// The list of IP addresses of the DNS servers. Addresses can be either
	// IPv4 or IPv6 addresses.
	//
	// Example: ["10.224.65.20","2001:db08:a0b:12f0::1"]
	// Max Items: 3
	NameServers []string `json:"name_servers,omitempty"`

	// nodes
	Nodes []*ClusterNodesItems0 `json:"nodes,omitempty"`

	// Host name, IPv4 address, or IPv6 address for the external NTP time servers.
	// Example: ["time.nist.gov","10.98.19.20","2610:20:6F15:15::27"]
	NtpServers []string `json:"ntp_servers,omitempty"`

	// Initial admin password used to create the cluster.
	// Example: mypassword
	// Format: password
	Password strfmt.Password `json:"password,omitempty"`

	// peering policy
	PeeringPolicy *ClusterPeeringPolicy `json:"peering_policy,omitempty"`

	// Specifies if this cluster is an All SAN Array.
	// Read Only: true
	SanOptimized *bool `json:"san_optimized,omitempty"`

	// statistics
	Statistics *ClusterStatistics `json:"statistics,omitempty"`

	// timezone
	Timezone *ClusterTimezone `json:"timezone,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// version
	Version *ClusterVersion `json:"version,omitempty"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurationBackup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSDomains(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicense(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeeringPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimezone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateCertificate(formats strfmt.Registry) error {
	if swag.IsZero(m.Certificate) { // not required
		return nil
	}

	if m.Certificate != nil {
		if err := m.Certificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateConfigurationBackup(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigurationBackup) { // not required
		return nil
	}

	if m.ConfigurationBackup != nil {
		if err := m.ConfigurationBackup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("configuration_backup")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateDNSDomains(formats strfmt.Registry) error {
	if swag.IsZero(m.DNSDomains) { // not required
		return nil
	}

	iDNSDomainsSize := int64(len(m.DNSDomains))

	if err := validate.MaxItems("dns_domains", "body", iDNSDomainsSize, 6); err != nil {
		return err
	}

	for i := 0; i < len(m.DNSDomains); i++ {

		if err := validate.MinLength("dns_domains"+"."+strconv.Itoa(i), "body", m.DNSDomains[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("dns_domains"+"."+strconv.Itoa(i), "body", m.DNSDomains[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (m *Cluster) validateLicense(formats strfmt.Registry) error {
	if swag.IsZero(m.License) { // not required
		return nil
	}

	if m.License != nil {
		if err := m.License.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateManagementInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterface) { // not required
		return nil
	}

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateManagementInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {
		if swag.IsZero(m.ManagementInterfaces[i]) { // not required
			continue
		}

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateNameServers(formats strfmt.Registry) error {
	if swag.IsZero(m.NameServers) { // not required
		return nil
	}

	iNameServersSize := int64(len(m.NameServers))

	if err := validate.MaxItems("name_servers", "body", iNameServersSize, 3); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateNodes(formats strfmt.Registry) error {
	if swag.IsZero(m.Nodes) { // not required
		return nil
	}

	for i := 0; i < len(m.Nodes); i++ {
		if swag.IsZero(m.Nodes[i]) { // not required
			continue
		}

		if m.Nodes[i] != nil {
			if err := m.Nodes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.FormatOf("password", "body", "password", m.Password.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validatePeeringPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.PeeringPolicy) { // not required
		return nil
	}

	if m.PeeringPolicy != nil {
		if err := m.PeeringPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("peering_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateTimezone(formats strfmt.Registry) error {
	if swag.IsZero(m.Timezone) { // not required
		return nil
	}

	if m.Timezone != nil {
		if err := m.Timezone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timezone")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster based on the context it is used
func (m *Cluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurationBackup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLicense(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNodes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeeringPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSanOptimized(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimezone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateCertificate(ctx context.Context, formats strfmt.Registry) error {

	if m.Certificate != nil {
		if err := m.Certificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateConfigurationBackup(ctx context.Context, formats strfmt.Registry) error {

	if m.ConfigurationBackup != nil {
		if err := m.ConfigurationBackup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("configuration_backup")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateLicense(ctx context.Context, formats strfmt.Registry) error {

	if m.License != nil {
		if err := m.License.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateManagementInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateManagementInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "management_interfaces", "body", []*ClusterManagementInterfacesItems0(m.ManagementInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateNodes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Nodes); i++ {

		if m.Nodes[i] != nil {
			if err := m.Nodes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidatePeeringPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.PeeringPolicy != nil {
		if err := m.PeeringPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("peering_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSanOptimized(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "san_optimized", "body", m.SanOptimized); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateTimezone(ctx context.Context, formats strfmt.Registry) error {

	if m.Timezone != nil {
		if err := m.Timezone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timezone")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterCertificate Support for this field will be removed in a future release. Please use /api/cluster/web for this field. Certificate used by cluster and node management interfaces for TLS connection requests.
//
// swagger:model ClusterCertificate
type ClusterCertificate struct {

	// links
	Links *ClusterCertificateLinks `json:"_links,omitempty"`

	// Certificate name
	// Example: cert1
	Name string `json:"name,omitempty"`

	// Certificate UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster certificate
func (m *ClusterCertificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster certificate based on the context it is used
func (m *ClusterCertificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterCertificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterCertificate) UnmarshalBinary(b []byte) error {
	var res ClusterCertificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterCertificateLinks cluster certificate links
//
// swagger:model ClusterCertificateLinks
type ClusterCertificateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster certificate links
func (m *ClusterCertificateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster certificate links based on the context it is used
func (m *ClusterCertificateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterCertificateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certificate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterCertificateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterCertificateLinks) UnmarshalBinary(b []byte) error {
	var res ClusterCertificateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterConfigurationBackup cluster configuration backup
//
// swagger:model ClusterConfigurationBackup
type ClusterConfigurationBackup struct {

	// password
	// Example: yourpassword
	// Format: password
	Password strfmt.Password `json:"password,omitempty"`

	// An external backup location for the cluster configuration. This is mostly required for single node clusters where node and cluster configuration backups cannot be copied to other nodes in the cluster.
	// Example: http://10.224.65.198/backups
	URL string `json:"url,omitempty"`

	// username
	// Example: me
	Username string `json:"username,omitempty"`

	// Use this parameter with the value "true" to validate the digital certificate of the remote server. Digital certificate validation is available only when the HTTPS protocol is used in the URL; it is disabled by default.
	ValidateCertificate bool `json:"validate_certificate,omitempty"`
}

// Validate validates this cluster configuration backup
func (m *ClusterConfigurationBackup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfigurationBackup) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.FormatOf("configuration_backup"+"."+"password", "body", "password", m.Password.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster configuration backup based on context it is used
func (m *ClusterConfigurationBackup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterConfigurationBackup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterConfigurationBackup) UnmarshalBinary(b []byte) error {
	var res ClusterConfigurationBackup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterLicense License keys or NLF contents.
//
// swagger:model ClusterLicense
type ClusterLicense struct {

	// keys
	Keys []string `json:"keys,omitempty"`
}

// Validate validates this cluster license
func (m *ClusterLicense) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cluster license based on context it is used
func (m *ClusterLicense) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterLicense) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterLicense) UnmarshalBinary(b []byte) error {
	var res ClusterLicense
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterLinks cluster links
//
// swagger:model ClusterLinks
type ClusterLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster links
func (m *ClusterLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster links based on the context it is used
func (m *ClusterLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterLinks) UnmarshalBinary(b []byte) error {
	var res ClusterLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterface The management interface of the cluster. The subnet mask and gateway for this interface are used for the node management interfaces provided in the node configuration.
//
// swagger:model ClusterManagementInterface
type ClusterManagementInterface struct {

	// ip
	IP *ClusterManagementInterfaceIP `json:"ip,omitempty"`
}

// Validate validates this cluster management interface
func (m *ClusterManagementInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster management interface based on the context it is used
func (m *ClusterManagementInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterface) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfaceIP Object to setup an interface along with its default router.
//
// swagger:model ClusterManagementInterfaceIP
type ClusterManagementInterfaceIP struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this cluster management interface IP
func (m *ClusterManagementInterfaceIP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfaceIP) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("management_interface" + "." + "ip" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster management interface IP based on the context it is used
func (m *ClusterManagementInterfaceIP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfaceIP) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("management_interface" + "." + "ip" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfaceIP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfaceIP) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfaceIP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfacesItems0 cluster management interfaces items0
//
// swagger:model ClusterManagementInterfacesItems0
type ClusterManagementInterfacesItems0 struct {

	// links
	Links *ClusterManagementInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *ClusterManagementInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface. If only the name is provided, the SVM scope
	// must be provided by the object this object is embedded in.
	//
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster management interfaces items0
func (m *ClusterManagementInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterManagementInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster management interfaces items0 based on the context it is used
func (m *ClusterManagementInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterManagementInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfacesItems0IP IP information
//
// swagger:model ClusterManagementInterfacesItems0IP
type ClusterManagementInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this cluster management interfaces items0 IP
func (m *ClusterManagementInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster management interfaces items0 IP based on the context it is used
func (m *ClusterManagementInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterManagementInterfacesItems0Links cluster management interfaces items0 links
//
// swagger:model ClusterManagementInterfacesItems0Links
type ClusterManagementInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster management interfaces items0 links
func (m *ClusterManagementInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster management interfaces items0 links based on the context it is used
func (m *ClusterManagementInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterManagementInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterManagementInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterManagementInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetric cluster metric
//
// swagger:model ClusterMetric
type ClusterMetric struct {

	// links
	Links *ClusterMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *ClusterMetricIops `json:"iops,omitempty"`

	// latency
	Latency *ClusterMetricLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *ClusterMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this cluster metric
func (m *ClusterMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var clusterMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterMetricTypeDurationPropEnum = append(clusterMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// ClusterMetricDurationPT15S captures enum value "PT15S"
	ClusterMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// ClusterMetricDurationPT4M captures enum value "PT4M"
	ClusterMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// ClusterMetricDurationPT30M captures enum value "PT30M"
	ClusterMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// ClusterMetricDurationPT2H captures enum value "PT2H"
	ClusterMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// ClusterMetricDurationP1D captures enum value "P1D"
	ClusterMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// ClusterMetricDurationPT5M captures enum value "PT5M"
	ClusterMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *ClusterMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var clusterMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterMetricTypeStatusPropEnum = append(clusterMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// ClusterMetricStatusOk captures enum value "ok"
	ClusterMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// ClusterMetricStatusError captures enum value "error"
	ClusterMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// ClusterMetricStatusPartialNoData captures enum value "partial_no_data"
	ClusterMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// ClusterMetricStatusPartialNoResponse captures enum value "partial_no_response"
	ClusterMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// ClusterMetricStatusPartialOtherError captures enum value "partial_other_error"
	ClusterMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// ClusterMetricStatusNegativeDelta captures enum value "negative_delta"
	ClusterMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// not_found
	// END DEBUGGING
	// ClusterMetricStatusNotFound captures enum value "not_found"
	ClusterMetricStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// ClusterMetricStatusBackfilledData captures enum value "backfilled_data"
	ClusterMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// ClusterMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	ClusterMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// ClusterMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	ClusterMetricStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// ClusterMetric
	// ClusterMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// ClusterMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	ClusterMetricStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *ClusterMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster metric based on the context it is used
func (m *ClusterMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetric) UnmarshalBinary(b []byte) error {
	var res ClusterMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model ClusterMetricIops
type ClusterMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster metric iops
func (m *ClusterMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster metric iops based on the context it is used
func (m *ClusterMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricIops) UnmarshalBinary(b []byte) error {
	var res ClusterMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model ClusterMetricLatency
type ClusterMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster metric latency
func (m *ClusterMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster metric latency based on the context it is used
func (m *ClusterMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricLatency) UnmarshalBinary(b []byte) error {
	var res ClusterMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricLinks cluster metric links
//
// swagger:model ClusterMetricLinks
type ClusterMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster metric links
func (m *ClusterMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metric links based on the context it is used
func (m *ClusterMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricLinks) UnmarshalBinary(b []byte) error {
	var res ClusterMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model ClusterMetricThroughput
type ClusterMetricThroughput struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster metric throughput
func (m *ClusterMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster metric throughput based on the context it is used
func (m *ClusterMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetricThroughput) UnmarshalBinary(b []byte) error {
	var res ClusterMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0 Complete node information
//
// swagger:model ClusterNodesItems0
type ClusterNodesItems0 struct {

	// links
	Links *ClusterNodesItems0Links `json:"_links,omitempty"`

	// cluster interface
	ClusterInterface *ClusterNodesItems0ClusterInterface `json:"cluster_interface,omitempty"`

	// cluster interfaces
	// Read Only: true
	ClusterInterfaces []*ClusterNodesItems0ClusterInterfacesItems0 `json:"cluster_interfaces,omitempty"`

	// controller
	Controller *ClusterNodesItems0Controller `json:"controller,omitempty"`

	// The current or "wall clock" time of the node in ISO-8601 date, time, and time zone format.
	// The ISO-8601 date and time are localized based on the ONTAP cluster's timezone setting.
	//
	// Example: 2019-04-17T11:49:26-04:00
	// Read Only: true
	// Format: date-time
	Date *strfmt.DateTime `json:"date,omitempty"`

	// external cache
	ExternalCache *ClusterNodesItems0ExternalCache `json:"external_cache,omitempty"`

	// ha
	Ha *ClusterNodesItems0Ha `json:"ha,omitempty"`

	// hw assist
	HwAssist *ClusterNodesItems0HwAssist `json:"hw_assist,omitempty"`

	// Specifies whether or not the node is in spares low condition.
	// Read Only: true
	IsSparesLow *bool `json:"is_spares_low,omitempty"`

	// location
	// Example: rack 2 row 5
	Location string `json:"location,omitempty"`

	// management interface
	ManagementInterface *ClusterNodesItems0ManagementInterface `json:"management_interface,omitempty"`

	// management interfaces
	// Read Only: true
	ManagementInterfaces []*ClusterNodesItems0ManagementInterfacesItems0 `json:"management_interfaces,omitempty"`

	// Possible values:
	// * <i>available</i> - A node is detected on the internal cluster network and can be added to the cluster.  Nodes that have a membership of "available" are not returned when a GET request is called when the cluster exists. Provide a query on the "membership" property for <i>available</i> to scan for nodes on the cluster network. Nodes that have a membership of "available" are returned automatically before a cluster is created.
	// * <i>joining</i> - Joining nodes are in the process of being added to the cluster. The node might be progressing through the steps to become a member or might have failed. The job to add the node or create the cluster provides details on the current progress of the node.
	// * <i>member</i> - Nodes that are members have successfully joined the cluster.
	//
	// Read Only: true
	// Enum: [available joining member]
	Membership string `json:"membership,omitempty"`

	// metric
	Metric *ClusterNodesItems0Metric `json:"metric,omitempty"`

	// metrocluster
	Metrocluster *ClusterNodesItems0Metrocluster `json:"metrocluster,omitempty"`

	// model
	// Example: FAS3070
	// Read Only: true
	Model string `json:"model,omitempty"`

	// name
	// Example: node-01
	Name string `json:"name,omitempty"`

	// nvram
	Nvram *ClusterNodesItems0Nvram `json:"nvram,omitempty"`

	// Owner of the node.
	// Example: Example Corp
	Owner string `json:"owner,omitempty"`

	// serial number
	// Example: 4048820-60-9
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// service processor
	ServiceProcessor *ClusterNodesItems0ServiceProcessor `json:"service_processor,omitempty"`

	// State of the node:
	// * <i>up</i> - Node is up and operational.
	// * <i>booting</i> - Node is booting up.
	// * <i>down</i> - Node has stopped or is dumping core.
	// * <i>taken_over</i> - Node has been taken over by its HA partner and is not yet waiting for giveback.
	// * <i>waiting_for_giveback</i> - Node has been taken over by its HA partner and is waiting for the HA partner to giveback disks.
	// * <i>degraded</i> - Node has one or more critical services offline.
	// * <i>unknown</i> - Node or its HA partner cannot be contacted and there is no information on the node's state.
	//
	// Read Only: true
	// Enum: [up booting down taken_over waiting_for_giveback degraded unknown]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *ClusterNodesItems0Statistics `json:"statistics,omitempty"`

	// The storage configuration in the system. Possible values:
	// * <i>mixed_path</i>
	// * <i>single_path</i>
	// * <i>multi_path</i>
	// * <i>quad_path</i>
	// * <i>mixed_path_ha</i>
	// * <i>single_path_ha</i>
	// * <i>multi_path_ha</i>
	// * <i>quad_path_ha</i>
	// * <i>unknown</i>
	//
	// Read Only: true
	// Enum: [unknown single_path multi_path mixed_path quad_path single_path_ha multi_path_ha mixed_path_ha quad_path_ha]
	StorageConfiguration string `json:"storage_configuration,omitempty"`

	// system id
	// Example: 0537035403
	// Read Only: true
	SystemID string `json:"system_id,omitempty"`

	// OEM system machine type.
	// Example: 7Y56-CTOWW1
	// Read Only: true
	SystemMachineType string `json:"system_machine_type,omitempty"`

	// The total time, in seconds, that the node has been up.
	// Example: 300536
	// Read Only: true
	Uptime int64 `json:"uptime,omitempty"`

	// uuid
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// OEM vendor serial number.
	// Example: 791603000068
	// Read Only: true
	VendorSerialNumber string `json:"vendor_serial_number,omitempty"`

	// version
	Version *ClusterNodesItems0Version `json:"version,omitempty"`

	// vm
	VM *ClusterNodesItems0VM `json:"vm,omitempty"`
}

// Validate validates this cluster nodes items0
func (m *ClusterNodesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateController(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHa(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHwAssist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMembership(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetrocluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNvram(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceProcessor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVM(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateClusterInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterface) { // not required
		return nil
	}

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateClusterInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {
		if swag.IsZero(m.ClusterInterfaces[i]) { // not required
			continue
		}

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0) validateController(formats strfmt.Registry) error {
	if swag.IsZero(m.Controller) { // not required
		return nil
	}

	if m.Controller != nil {
		if err := m.Controller.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date-time", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateExternalCache(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalCache) { // not required
		return nil
	}

	if m.ExternalCache != nil {
		if err := m.ExternalCache.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_cache")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateHa(formats strfmt.Registry) error {
	if swag.IsZero(m.Ha) { // not required
		return nil
	}

	if m.Ha != nil {
		if err := m.Ha.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateHwAssist(formats strfmt.Registry) error {
	if swag.IsZero(m.HwAssist) { // not required
		return nil
	}

	if m.HwAssist != nil {
		if err := m.HwAssist.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateManagementInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterface) { // not required
		return nil
	}

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateManagementInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {
		if swag.IsZero(m.ManagementInterfaces[i]) { // not required
			continue
		}

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var clusterNodesItems0TypeMembershipPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["available","joining","member"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0TypeMembershipPropEnum = append(clusterNodesItems0TypeMembershipPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// membership
	// Membership
	// available
	// END DEBUGGING
	// ClusterNodesItems0MembershipAvailable captures enum value "available"
	ClusterNodesItems0MembershipAvailable string = "available"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// membership
	// Membership
	// joining
	// END DEBUGGING
	// ClusterNodesItems0MembershipJoining captures enum value "joining"
	ClusterNodesItems0MembershipJoining string = "joining"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// membership
	// Membership
	// member
	// END DEBUGGING
	// ClusterNodesItems0MembershipMember captures enum value "member"
	ClusterNodesItems0MembershipMember string = "member"
)

// prop value enum
func (m *ClusterNodesItems0) validateMembershipEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0TypeMembershipPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0) validateMembership(formats strfmt.Registry) error {
	if swag.IsZero(m.Membership) { // not required
		return nil
	}

	// value enum
	if err := m.validateMembershipEnum("membership", "body", m.Membership); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateMetrocluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Metrocluster) { // not required
		return nil
	}

	if m.Metrocluster != nil {
		if err := m.Metrocluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateNvram(formats strfmt.Registry) error {
	if swag.IsZero(m.Nvram) { // not required
		return nil
	}

	if m.Nvram != nil {
		if err := m.Nvram.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvram")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateServiceProcessor(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceProcessor) { // not required
		return nil
	}

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","booting","down","taken_over","waiting_for_giveback","degraded","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0TypeStatePropEnum = append(clusterNodesItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// up
	// END DEBUGGING
	// ClusterNodesItems0StateUp captures enum value "up"
	ClusterNodesItems0StateUp string = "up"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// booting
	// END DEBUGGING
	// ClusterNodesItems0StateBooting captures enum value "booting"
	ClusterNodesItems0StateBooting string = "booting"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// down
	// END DEBUGGING
	// ClusterNodesItems0StateDown captures enum value "down"
	ClusterNodesItems0StateDown string = "down"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// taken_over
	// END DEBUGGING
	// ClusterNodesItems0StateTakenOver captures enum value "taken_over"
	ClusterNodesItems0StateTakenOver string = "taken_over"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// waiting_for_giveback
	// END DEBUGGING
	// ClusterNodesItems0StateWaitingForGiveback captures enum value "waiting_for_giveback"
	ClusterNodesItems0StateWaitingForGiveback string = "waiting_for_giveback"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// degraded
	// END DEBUGGING
	// ClusterNodesItems0StateDegraded captures enum value "degraded"
	ClusterNodesItems0StateDegraded string = "degraded"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// state
	// State
	// unknown
	// END DEBUGGING
	// ClusterNodesItems0StateUnknown captures enum value "unknown"
	ClusterNodesItems0StateUnknown string = "unknown"
)

// prop value enum
func (m *ClusterNodesItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0TypeStorageConfigurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","single_path","multi_path","mixed_path","quad_path","single_path_ha","multi_path_ha","mixed_path_ha","quad_path_ha"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0TypeStorageConfigurationPropEnum = append(clusterNodesItems0TypeStorageConfigurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// unknown
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationUnknown captures enum value "unknown"
	ClusterNodesItems0StorageConfigurationUnknown string = "unknown"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// single_path
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationSinglePath captures enum value "single_path"
	ClusterNodesItems0StorageConfigurationSinglePath string = "single_path"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// multi_path
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationMultiPath captures enum value "multi_path"
	ClusterNodesItems0StorageConfigurationMultiPath string = "multi_path"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// mixed_path
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationMixedPath captures enum value "mixed_path"
	ClusterNodesItems0StorageConfigurationMixedPath string = "mixed_path"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// quad_path
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationQuadPath captures enum value "quad_path"
	ClusterNodesItems0StorageConfigurationQuadPath string = "quad_path"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// single_path_ha
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationSinglePathHa captures enum value "single_path_ha"
	ClusterNodesItems0StorageConfigurationSinglePathHa string = "single_path_ha"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// multi_path_ha
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationMultiPathHa captures enum value "multi_path_ha"
	ClusterNodesItems0StorageConfigurationMultiPathHa string = "multi_path_ha"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// mixed_path_ha
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationMixedPathHa captures enum value "mixed_path_ha"
	ClusterNodesItems0StorageConfigurationMixedPathHa string = "mixed_path_ha"

	// BEGIN DEBUGGING
	// ClusterNodesItems0
	// ClusterNodesItems0
	// storage_configuration
	// StorageConfiguration
	// quad_path_ha
	// END DEBUGGING
	// ClusterNodesItems0StorageConfigurationQuadPathHa captures enum value "quad_path_ha"
	ClusterNodesItems0StorageConfigurationQuadPathHa string = "quad_path_ha"
)

// prop value enum
func (m *ClusterNodesItems0) validateStorageConfigurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0TypeStorageConfigurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0) validateStorageConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageConfiguration) { // not required
		return nil
	}

	// value enum
	if err := m.validateStorageConfigurationEnum("storage_configuration", "body", m.StorageConfiguration); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) validateVM(formats strfmt.Registry) error {
	if swag.IsZero(m.VM) { // not required
		return nil
	}

	if m.VM != nil {
		if err := m.VM.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 based on the context it is used
func (m *ClusterNodesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateController(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalCache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHa(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHwAssist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSparesLow(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMembership(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetrocluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNvram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceProcessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemMachineType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUptime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVendorSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVM(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateClusterInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateClusterInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster_interfaces", "body", []*ClusterNodesItems0ClusterInterfacesItems0(m.ClusterInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateController(ctx context.Context, formats strfmt.Registry) error {

	if m.Controller != nil {
		if err := m.Controller.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "date", "body", m.Date); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateExternalCache(ctx context.Context, formats strfmt.Registry) error {

	if m.ExternalCache != nil {
		if err := m.ExternalCache.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_cache")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateHa(ctx context.Context, formats strfmt.Registry) error {

	if m.Ha != nil {
		if err := m.Ha.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateHwAssist(ctx context.Context, formats strfmt.Registry) error {

	if m.HwAssist != nil {
		if err := m.HwAssist.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateIsSparesLow(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "is_spares_low", "body", m.IsSparesLow); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateManagementInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateManagementInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "management_interfaces", "body", []*ClusterNodesItems0ManagementInterfacesItems0(m.ManagementInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateMembership(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "membership", "body", string(m.Membership)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateMetrocluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Metrocluster != nil {
		if err := m.Metrocluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateNvram(ctx context.Context, formats strfmt.Registry) error {

	if m.Nvram != nil {
		if err := m.Nvram.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nvram")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateServiceProcessor(ctx context.Context, formats strfmt.Registry) error {

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateStorageConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "storage_configuration", "body", string(m.StorageConfiguration)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateSystemID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_id", "body", string(m.SystemID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateSystemMachineType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_machine_type", "body", string(m.SystemMachineType)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateUptime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uptime", "body", int64(m.Uptime)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateVendorSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vendor_serial_number", "body", string(m.VendorSerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0) contextValidateVM(ctx context.Context, formats strfmt.Registry) error {

	if m.VM != nil {
		if err := m.VM.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterface The cluster network IP address of the node to be added.
//
// swagger:model ClusterNodesItems0ClusterInterface
type ClusterNodesItems0ClusterInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interface
func (m *ClusterNodesItems0ClusterInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interface based on the context it is used
func (m *ClusterNodesItems0ClusterInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterfacesItems0 Network interface
//
// swagger:model ClusterNodesItems0ClusterInterfacesItems0
type ClusterNodesItems0ClusterInterfacesItems0 struct {

	// links
	Links *ClusterNodesItems0ClusterInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *ClusterNodesItems0ClusterInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface. If only the name is provided, the SVM scope
	// must be provided by the object this object is embedded in.
	//
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interfaces items0
func (m *ClusterNodesItems0ClusterInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interfaces items0 based on the context it is used
func (m *ClusterNodesItems0ClusterInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterfacesItems0IP IP information
//
// swagger:model ClusterNodesItems0ClusterInterfacesItems0IP
type ClusterNodesItems0ClusterInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interfaces items0 IP
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interfaces items0 IP based on the context it is used
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ClusterInterfacesItems0Links cluster nodes items0 cluster interfaces items0 links
//
// swagger:model ClusterNodesItems0ClusterInterfacesItems0Links
type ClusterNodesItems0ClusterInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 cluster interfaces items0 links
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 cluster interfaces items0 links based on the context it is used
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ClusterInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ClusterInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ClusterInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Controller Controller information
//
// swagger:model ClusterNodesItems0Controller
type ClusterNodesItems0Controller struct {

	// Type of the system board. This is defined by vendor.
	// Example: System Board XXVIII
	// Read Only: true
	Board string `json:"board,omitempty"`

	// cpu
	CPU *ClusterNodesItems0ControllerCPU `json:"cpu,omitempty"`

	// failed fan
	FailedFan *ClusterNodesItems0ControllerFailedFan `json:"failed_fan,omitempty"`

	// failed power supply
	FailedPowerSupply *ClusterNodesItems0ControllerFailedPowerSupply `json:"failed_power_supply,omitempty"`

	// A list of Flash-Cache devices. Only returned when requested by name.
	// Read Only: true
	FlashCache []*ClusterNodesItems0ControllerFlashCacheItems0 `json:"flash_cache,omitempty"`

	// List of FRUs on the node. Only returned when requested by name.
	Frus []*ClusterNodesItems0ControllerFrusItems0 `json:"frus,omitempty"`

	// Memory available on the node, in bytes.
	// Example: 1024000000
	// Read Only: true
	MemorySize int64 `json:"memory_size,omitempty"`

	// Specifies whether the hardware is currently operating outside of its recommended temperature range. The hardware shuts down if the temperature exceeds critical thresholds.
	// Read Only: true
	// Enum: [over normal]
	OverTemperature string `json:"over_temperature,omitempty"`
}

// Validate validates this cluster nodes items0 controller
func (m *ClusterNodesItems0Controller) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPU(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailedFan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailedPowerSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlashCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverTemperature(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Controller) validateCPU(formats strfmt.Registry) error {
	if swag.IsZero(m.CPU) { // not required
		return nil
	}

	if m.CPU != nil {
		if err := m.CPU.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "cpu")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Controller) validateFailedFan(formats strfmt.Registry) error {
	if swag.IsZero(m.FailedFan) { // not required
		return nil
	}

	if m.FailedFan != nil {
		if err := m.FailedFan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Controller) validateFailedPowerSupply(formats strfmt.Registry) error {
	if swag.IsZero(m.FailedPowerSupply) { // not required
		return nil
	}

	if m.FailedPowerSupply != nil {
		if err := m.FailedPowerSupply.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Controller) validateFlashCache(formats strfmt.Registry) error {
	if swag.IsZero(m.FlashCache) { // not required
		return nil
	}

	for i := 0; i < len(m.FlashCache); i++ {
		if swag.IsZero(m.FlashCache[i]) { // not required
			continue
		}

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Controller) validateFrus(formats strfmt.Registry) error {
	if swag.IsZero(m.Frus) { // not required
		return nil
	}

	for i := 0; i < len(m.Frus); i++ {
		if swag.IsZero(m.Frus[i]) { // not required
			continue
		}

		if m.Frus[i] != nil {
			if err := m.Frus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var clusterNodesItems0ControllerTypeOverTemperaturePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["over","normal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerTypeOverTemperaturePropEnum = append(clusterNodesItems0ControllerTypeOverTemperaturePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0Controller
	// ClusterNodesItems0Controller
	// over_temperature
	// OverTemperature
	// over
	// END DEBUGGING
	// ClusterNodesItems0ControllerOverTemperatureOver captures enum value "over"
	ClusterNodesItems0ControllerOverTemperatureOver string = "over"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Controller
	// ClusterNodesItems0Controller
	// over_temperature
	// OverTemperature
	// normal
	// END DEBUGGING
	// ClusterNodesItems0ControllerOverTemperatureNormal captures enum value "normal"
	ClusterNodesItems0ControllerOverTemperatureNormal string = "normal"
)

// prop value enum
func (m *ClusterNodesItems0Controller) validateOverTemperatureEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerTypeOverTemperaturePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0Controller) validateOverTemperature(formats strfmt.Registry) error {
	if swag.IsZero(m.OverTemperature) { // not required
		return nil
	}

	// value enum
	if err := m.validateOverTemperatureEnum("controller"+"."+"over_temperature", "body", m.OverTemperature); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller based on the context it is used
func (m *ClusterNodesItems0Controller) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBoard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCPU(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailedFan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailedPowerSupply(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlashCache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemorySize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverTemperature(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateBoard(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"board", "body", string(m.Board)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateCPU(ctx context.Context, formats strfmt.Registry) error {

	if m.CPU != nil {
		if err := m.CPU.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "cpu")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateFailedFan(ctx context.Context, formats strfmt.Registry) error {

	if m.FailedFan != nil {
		if err := m.FailedFan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateFailedPowerSupply(ctx context.Context, formats strfmt.Registry) error {

	if m.FailedPowerSupply != nil {
		if err := m.FailedPowerSupply.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateFlashCache(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"flash_cache", "body", []*ClusterNodesItems0ControllerFlashCacheItems0(m.FlashCache)); err != nil {
		return err
	}

	for i := 0; i < len(m.FlashCache); i++ {

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateFrus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Frus); i++ {

		if m.Frus[i] != nil {
			if err := m.Frus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateMemorySize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"memory_size", "body", int64(m.MemorySize)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Controller) contextValidateOverTemperature(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"over_temperature", "body", string(m.OverTemperature)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Controller) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Controller) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Controller
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerCPU CPU information.
//
// swagger:model ClusterNodesItems0ControllerCPU
type ClusterNodesItems0ControllerCPU struct {

	// Number of CPUs on the node.
	// Example: 20
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// Firmware release number. Defined by the CPU manufacturer.
	// Read Only: true
	FirmwareRelease string `json:"firmware_release,omitempty"`

	// CPU type on the node.
	// Read Only: true
	Processor string `json:"processor,omitempty"`
}

// Validate validates this cluster nodes items0 controller CPU
func (m *ClusterNodesItems0ControllerCPU) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 controller CPU based on the context it is used
func (m *ClusterNodesItems0ControllerCPU) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareRelease(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerCPU) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"cpu"+"."+"count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerCPU) contextValidateFirmwareRelease(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"cpu"+"."+"firmware_release", "body", string(m.FirmwareRelease)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerCPU) contextValidateProcessor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"cpu"+"."+"processor", "body", string(m.Processor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerCPU) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerCPU) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerCPU
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFailedFan cluster nodes items0 controller failed fan
//
// swagger:model ClusterNodesItems0ControllerFailedFan
type ClusterNodesItems0ControllerFailedFan struct {

	// Specifies a count of the number of chassis fans that are not operating within the recommended RPM range.
	// Example: 1
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// message
	Message *ClusterNodesItems0ControllerFailedFanMessage `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 controller failed fan
func (m *ClusterNodesItems0ControllerFailedFan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFailedFan) validateMessage(formats strfmt.Registry) error {
	if swag.IsZero(m.Message) { // not required
		return nil
	}

	if m.Message != nil {
		if err := m.Message.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller failed fan based on the context it is used
func (m *ClusterNodesItems0ControllerFailedFan) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFailedFan) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_fan"+"."+"count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFailedFan) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if m.Message != nil {
		if err := m.Message.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_fan" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedFan) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedFan) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFailedFan
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFailedFanMessage cluster nodes items0 controller failed fan message
//
// swagger:model ClusterNodesItems0ControllerFailedFanMessage
type ClusterNodesItems0ControllerFailedFanMessage struct {

	// Error code describing the current condition of chassis fans.
	// Example: 111411207
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message describing the current condition of chassis fans. It is only of use when `failed_fan.count` is not zero.
	// Example: There are no failed fans.
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 controller failed fan message
func (m *ClusterNodesItems0ControllerFailedFanMessage) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 controller failed fan message based on the context it is used
func (m *ClusterNodesItems0ControllerFailedFanMessage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFailedFanMessage) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_fan"+"."+"message"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFailedFanMessage) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_fan"+"."+"message"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedFanMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedFanMessage) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFailedFanMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFailedPowerSupply cluster nodes items0 controller failed power supply
//
// swagger:model ClusterNodesItems0ControllerFailedPowerSupply
type ClusterNodesItems0ControllerFailedPowerSupply struct {

	// Number of failed power supply units.
	// Example: 1
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// message
	Message *ClusterNodesItems0ControllerFailedPowerSupplyMessage `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 controller failed power supply
func (m *ClusterNodesItems0ControllerFailedPowerSupply) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFailedPowerSupply) validateMessage(formats strfmt.Registry) error {
	if swag.IsZero(m.Message) { // not required
		return nil
	}

	if m.Message != nil {
		if err := m.Message.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller failed power supply based on the context it is used
func (m *ClusterNodesItems0ControllerFailedPowerSupply) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFailedPowerSupply) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_power_supply"+"."+"count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFailedPowerSupply) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if m.Message != nil {
		if err := m.Message.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller" + "." + "failed_power_supply" + "." + "message")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedPowerSupply) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedPowerSupply) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFailedPowerSupply
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFailedPowerSupplyMessage cluster nodes items0 controller failed power supply message
//
// swagger:model ClusterNodesItems0ControllerFailedPowerSupplyMessage
type ClusterNodesItems0ControllerFailedPowerSupplyMessage struct {

	// Error code describing the current condition of power supply.
	// Example: 111411208
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message describing the state of any power supplies that are currently degraded. It is only of use when `failed_power_supply.count` is not zero.
	// Example: There are no failed power supplies.
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 controller failed power supply message
func (m *ClusterNodesItems0ControllerFailedPowerSupplyMessage) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 controller failed power supply message based on the context it is used
func (m *ClusterNodesItems0ControllerFailedPowerSupplyMessage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFailedPowerSupplyMessage) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_power_supply"+"."+"message"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFailedPowerSupplyMessage) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"failed_power_supply"+"."+"message"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedPowerSupplyMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFailedPowerSupplyMessage) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFailedPowerSupplyMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFlashCacheItems0 cluster nodes items0 controller flash cache items0
//
// swagger:model ClusterNodesItems0ControllerFlashCacheItems0
type ClusterNodesItems0ControllerFlashCacheItems0 struct {

	// Size in bytes
	// Example: 1024000000000
	// Read Only: true
	Capacity int64 `json:"capacity,omitempty"`

	// device id
	// Example: 0
	// Read Only: true
	DeviceID int64 `json:"device_id,omitempty"`

	// firmware file
	// Example: X9170_O000Z6300NVM
	// Read Only: true
	FirmwareFile string `json:"firmware_file,omitempty"`

	// firmware version
	// Example: NA05
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// hardware revision
	// Example: A1
	// Read Only: true
	HardwareRevision string `json:"hardware_revision,omitempty"`

	// model
	// Example: X1970A
	// Read Only: true
	Model string `json:"model,omitempty"`

	// part number
	// Example: 119-00207
	// Read Only: true
	PartNumber string `json:"part_number,omitempty"`

	// serial number
	// Example: A22P5061550000187
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// slot
	// Example: 6-1
	// Read Only: true
	Slot string `json:"slot,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok erasing erased failed removed]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 controller flash cache items0
func (m *ClusterNodesItems0ControllerFlashCacheItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","erasing","erased","failed","removed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum = append(clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// ok
	// END DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateOk captures enum value "ok"
	ClusterNodesItems0ControllerFlashCacheItems0StateOk string = "ok"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// erasing
	// END DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateErasing captures enum value "erasing"
	ClusterNodesItems0ControllerFlashCacheItems0StateErasing string = "erasing"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// erased
	// END DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateErased captures enum value "erased"
	ClusterNodesItems0ControllerFlashCacheItems0StateErased string = "erased"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// failed
	// END DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateFailed captures enum value "failed"
	ClusterNodesItems0ControllerFlashCacheItems0StateFailed string = "failed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0
	// ClusterNodesItems0ControllerFlashCacheItems0
	// state
	// State
	// removed
	// END DEBUGGING
	// ClusterNodesItems0ControllerFlashCacheItems0StateRemoved captures enum value "removed"
	ClusterNodesItems0ControllerFlashCacheItems0StateRemoved string = "removed"
)

// prop value enum
func (m *ClusterNodesItems0ControllerFlashCacheItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerFlashCacheItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller flash cache items0 based on the context it is used
func (m *ClusterNodesItems0ControllerFlashCacheItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeviceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareFile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHardwareRevision(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSlot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateCapacity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "capacity", "body", int64(m.Capacity)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateDeviceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "device_id", "body", int64(m.DeviceID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateFirmwareFile(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "firmware_file", "body", string(m.FirmwareFile)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateHardwareRevision(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "hardware_revision", "body", string(m.HardwareRevision)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidatePartNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "part_number", "body", string(m.PartNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateSlot(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "slot", "body", string(m.Slot)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFlashCacheItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFlashCacheItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFlashCacheItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFlashCacheItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ControllerFrusItems0 cluster nodes items0 controller frus items0
//
// swagger:model ClusterNodesItems0ControllerFrusItems0
type ClusterNodesItems0ControllerFrusItems0 struct {

	// id
	// Read Only: true
	ID string `json:"id,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok error]
	State string `json:"state,omitempty"`

	// type
	// Read Only: true
	// Enum: [fan psu pcie disk nvs dimm controller]
	Type string `json:"type,omitempty"`
}

// Validate validates this cluster nodes items0 controller frus items0
func (m *ClusterNodesItems0ControllerFrusItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0ControllerFrusItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerFrusItems0TypeStatePropEnum = append(clusterNodesItems0ControllerFrusItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// state
	// State
	// ok
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0StateOk captures enum value "ok"
	ClusterNodesItems0ControllerFrusItems0StateOk string = "ok"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// state
	// State
	// error
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0StateError captures enum value "error"
	ClusterNodesItems0ControllerFrusItems0StateError string = "error"
)

// prop value enum
func (m *ClusterNodesItems0ControllerFrusItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerFrusItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var clusterNodesItems0ControllerFrusItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fan","psu","pcie","disk","nvs","dimm","controller"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ControllerFrusItems0TypeTypePropEnum = append(clusterNodesItems0ControllerFrusItems0TypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// fan
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeFan captures enum value "fan"
	ClusterNodesItems0ControllerFrusItems0TypeFan string = "fan"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// psu
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypePsu captures enum value "psu"
	ClusterNodesItems0ControllerFrusItems0TypePsu string = "psu"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// pcie
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypePcie captures enum value "pcie"
	ClusterNodesItems0ControllerFrusItems0TypePcie string = "pcie"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// disk
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeDisk captures enum value "disk"
	ClusterNodesItems0ControllerFrusItems0TypeDisk string = "disk"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// nvs
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeNvs captures enum value "nvs"
	ClusterNodesItems0ControllerFrusItems0TypeNvs string = "nvs"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// dimm
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeDimm captures enum value "dimm"
	ClusterNodesItems0ControllerFrusItems0TypeDimm string = "dimm"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0
	// ClusterNodesItems0ControllerFrusItems0
	// type
	// Type
	// controller
	// END DEBUGGING
	// ClusterNodesItems0ControllerFrusItems0TypeController captures enum value "controller"
	ClusterNodesItems0ControllerFrusItems0TypeController string = "controller"
)

// prop value enum
func (m *ClusterNodesItems0ControllerFrusItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ControllerFrusItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 controller frus items0 based on the context it is used
func (m *ClusterNodesItems0ControllerFrusItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ControllerFrusItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFrusItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ControllerFrusItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ControllerFrusItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ExternalCache Cache used for buffer management.
//
// swagger:model ClusterNodesItems0ExternalCache
type ClusterNodesItems0ExternalCache struct {

	// Indicates whether the external cache is enabled.
	// Example: true
	IsEnabled bool `json:"is_enabled,omitempty"`

	// Indicates whether HyA caching is enabled.
	// Example: true
	IsHyaEnabled bool `json:"is_hya_enabled,omitempty"`

	// Indicates whether rewarm is enabled.
	// Example: true
	IsRewarmEnabled bool `json:"is_rewarm_enabled,omitempty"`

	// PCS size in gigabytes.
	PcsSize int64 `json:"pcs_size,omitempty"`
}

// Validate validates this cluster nodes items0 external cache
func (m *ClusterNodesItems0ExternalCache) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cluster nodes items0 external cache based on context it is used
func (m *ClusterNodesItems0ExternalCache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ExternalCache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ExternalCache) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ExternalCache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Ha cluster nodes items0 ha
//
// swagger:model ClusterNodesItems0Ha
type ClusterNodesItems0Ha struct {

	// Specifies whether giveback is automatically initiated when the node that owns the storage is ready.
	// Read Only: true
	AutoGiveback *bool `json:"auto_giveback,omitempty"`

	// Specifies whether or not storage failover is enabled.
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// giveback
	Giveback *ClusterNodesItems0HaGiveback `json:"giveback,omitempty"`

	// interconnect
	Interconnect *ClusterNodesItems0HaInterconnect `json:"interconnect,omitempty"`

	// Nodes in this node's High Availability (HA) group.
	// Read Only: true
	Partners []*ClusterNodesItems0HaPartnersItems0 `json:"partners,omitempty"`

	// ports
	// Read Only: true
	Ports []*ClusterNodesItems0HaPortsItems0 `json:"ports,omitempty"`

	// takeover
	Takeover *ClusterNodesItems0HaTakeover `json:"takeover,omitempty"`
}

// Validate validates this cluster nodes items0 ha
func (m *ClusterNodesItems0Ha) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGiveback(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterconnect(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartners(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTakeover(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Ha) validateGiveback(formats strfmt.Registry) error {
	if swag.IsZero(m.Giveback) { // not required
		return nil
	}

	if m.Giveback != nil {
		if err := m.Giveback.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Ha) validateInterconnect(formats strfmt.Registry) error {
	if swag.IsZero(m.Interconnect) { // not required
		return nil
	}

	if m.Interconnect != nil {
		if err := m.Interconnect.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "interconnect")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Ha) validatePartners(formats strfmt.Registry) error {
	if swag.IsZero(m.Partners) { // not required
		return nil
	}

	for i := 0; i < len(m.Partners); i++ {
		if swag.IsZero(m.Partners[i]) { // not required
			continue
		}

		if m.Partners[i] != nil {
			if err := m.Partners[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) validateTakeover(formats strfmt.Registry) error {
	if swag.IsZero(m.Takeover) { // not required
		return nil
	}

	if m.Takeover != nil {
		if err := m.Takeover.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha based on the context it is used
func (m *ClusterNodesItems0Ha) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInterconnect(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartners(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTakeover(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateAutoGiveback(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"auto_giveback", "body", m.AutoGiveback); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateGiveback(ctx context.Context, formats strfmt.Registry) error {

	if m.Giveback != nil {
		if err := m.Giveback.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateInterconnect(ctx context.Context, formats strfmt.Registry) error {

	if m.Interconnect != nil {
		if err := m.Interconnect.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "interconnect")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidatePartners(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"partners", "body", []*ClusterNodesItems0HaPartnersItems0(m.Partners)); err != nil {
		return err
	}

	for i := 0; i < len(m.Partners); i++ {

		if m.Partners[i] != nil {
			if err := m.Partners[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"ports", "body", []*ClusterNodesItems0HaPortsItems0(m.Ports)); err != nil {
		return err
	}

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Ha) contextValidateTakeover(ctx context.Context, formats strfmt.Registry) error {

	if m.Takeover != nil {
		if err := m.Takeover.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Ha) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Ha) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Ha
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGiveback Represents the state of the node that is giving storage back to its HA partner.
//
// swagger:model ClusterNodesItems0HaGiveback
type ClusterNodesItems0HaGiveback struct {

	// failure
	Failure *ClusterNodesItems0HaGivebackFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [nothing_to_giveback not_attempted in_progress failed]
	State string `json:"state,omitempty"`

	// Giveback status of each aggregate.
	// Read Only: true
	Status []*ClusterNodesItems0HaGivebackStatusItems0 `json:"status,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback
func (m *ClusterNodesItems0HaGiveback) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGiveback) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0HaGivebackTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["nothing_to_giveback","not_attempted","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaGivebackTypeStatePropEnum = append(clusterNodesItems0HaGivebackTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// nothing_to_giveback
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStateNothingToGiveback captures enum value "nothing_to_giveback"
	ClusterNodesItems0HaGivebackStateNothingToGiveback string = "nothing_to_giveback"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// not_attempted
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStateNotAttempted captures enum value "not_attempted"
	ClusterNodesItems0HaGivebackStateNotAttempted string = "not_attempted"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// in_progress
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStateInProgress captures enum value "in_progress"
	ClusterNodesItems0HaGivebackStateInProgress string = "in_progress"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGiveback
	// ClusterNodesItems0HaGiveback
	// state
	// State
	// failed
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStateFailed captures enum value "failed"
	ClusterNodesItems0HaGivebackStateFailed string = "failed"
)

// prop value enum
func (m *ClusterNodesItems0HaGiveback) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaGivebackTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaGiveback) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"giveback"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0HaGiveback) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	for i := 0; i < len(m.Status); i++ {
		if swag.IsZero(m.Status[i]) { // not required
			continue
		}

		if m.Status[i] != nil {
			if err := m.Status[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "giveback" + "." + "status" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback based on the context it is used
func (m *ClusterNodesItems0HaGiveback) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGiveback) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0HaGiveback) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"giveback"+"."+"status", "body", []*ClusterNodesItems0HaGivebackStatusItems0(m.Status)); err != nil {
		return err
	}

	for i := 0; i < len(m.Status); i++ {

		if m.Status[i] != nil {
			if err := m.Status[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "giveback" + "." + "status" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGiveback) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGiveback) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGiveback
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGivebackFailure Indicates the failure code and message.
//
// swagger:model ClusterNodesItems0HaGivebackFailure
type ClusterNodesItems0HaGivebackFailure struct {

	// Message code
	// Example: 852126
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate giveback. Run the \"storage failover show-giveback\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback failure
func (m *ClusterNodesItems0HaGivebackFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback failure based on the context it is used
func (m *ClusterNodesItems0HaGivebackFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackFailure) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGivebackFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGivebackStatusItems0 cluster nodes items0 ha giveback status items0
//
// swagger:model ClusterNodesItems0HaGivebackStatusItems0
type ClusterNodesItems0HaGivebackStatusItems0 struct {

	// aggregate
	Aggregate *ClusterNodesItems0HaGivebackStatusItems0Aggregate `json:"aggregate,omitempty"`

	// error
	Error *ClusterNodesItems0HaGivebackStatusItems0Error `json:"error,omitempty"`

	// Giveback state of the aggregate. <br/>
	// Possible values include no aggregates to giveback(nothing_to_giveback), failed to disable background disk firmware update(BDFU) on source node(failed_bdfu_source), <br/>
	// giveback delayed as disk firmware update is in progress on source node(delayed_bdfu_source), performing veto checks(running_checks). <br/>
	//
	// Enum: [done failed in_progress not_started nothing_to_giveback failed_bdfu_source failed_bdfu_dest delayed_bdfu_source delayed_bdfu_dest running_checks]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback status items0
func (m *ClusterNodesItems0HaGivebackStatusItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0) validateAggregate(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregate) { // not required
		return nil
	}

	if m.Aggregate != nil {
		if err := m.Aggregate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0HaGivebackStatusItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["done","failed","in_progress","not_started","nothing_to_giveback","failed_bdfu_source","failed_bdfu_dest","delayed_bdfu_source","delayed_bdfu_dest","running_checks"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaGivebackStatusItems0TypeStatePropEnum = append(clusterNodesItems0HaGivebackStatusItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// done
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateDone captures enum value "done"
	ClusterNodesItems0HaGivebackStatusItems0StateDone string = "done"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// failed
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateFailed captures enum value "failed"
	ClusterNodesItems0HaGivebackStatusItems0StateFailed string = "failed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// in_progress
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateInProgress captures enum value "in_progress"
	ClusterNodesItems0HaGivebackStatusItems0StateInProgress string = "in_progress"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// not_started
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateNotStarted captures enum value "not_started"
	ClusterNodesItems0HaGivebackStatusItems0StateNotStarted string = "not_started"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// nothing_to_giveback
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateNothingToGiveback captures enum value "nothing_to_giveback"
	ClusterNodesItems0HaGivebackStatusItems0StateNothingToGiveback string = "nothing_to_giveback"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// failed_bdfu_source
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateFailedBdfuSource captures enum value "failed_bdfu_source"
	ClusterNodesItems0HaGivebackStatusItems0StateFailedBdfuSource string = "failed_bdfu_source"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// failed_bdfu_dest
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateFailedBdfuDest captures enum value "failed_bdfu_dest"
	ClusterNodesItems0HaGivebackStatusItems0StateFailedBdfuDest string = "failed_bdfu_dest"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// delayed_bdfu_source
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateDelayedBdfuSource captures enum value "delayed_bdfu_source"
	ClusterNodesItems0HaGivebackStatusItems0StateDelayedBdfuSource string = "delayed_bdfu_source"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// delayed_bdfu_dest
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateDelayedBdfuDest captures enum value "delayed_bdfu_dest"
	ClusterNodesItems0HaGivebackStatusItems0StateDelayedBdfuDest string = "delayed_bdfu_dest"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0
	// ClusterNodesItems0HaGivebackStatusItems0
	// state
	// State
	// running_checks
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0StateRunningChecks captures enum value "running_checks"
	ClusterNodesItems0HaGivebackStatusItems0StateRunningChecks string = "running_checks"
)

// prop value enum
func (m *ClusterNodesItems0HaGivebackStatusItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaGivebackStatusItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback status items0 based on the context it is used
func (m *ClusterNodesItems0HaGivebackStatusItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAggregate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0) contextValidateAggregate(ctx context.Context, formats strfmt.Registry) error {

	if m.Aggregate != nil {
		if err := m.Aggregate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if m.Error != nil {
		if err := m.Error.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGivebackStatusItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGivebackStatusItems0Aggregate Aggregate name and UUID.
//
// swagger:model ClusterNodesItems0HaGivebackStatusItems0Aggregate
type ClusterNodesItems0HaGivebackStatusItems0Aggregate struct {

	// links
	Links *ClusterNodesItems0HaGivebackStatusItems0AggregateLinks `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback status items0 aggregate
func (m *ClusterNodesItems0HaGivebackStatusItems0Aggregate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0Aggregate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback status items0 aggregate based on the context it is used
func (m *ClusterNodesItems0HaGivebackStatusItems0Aggregate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0Aggregate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0Aggregate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0Aggregate) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGivebackStatusItems0Aggregate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGivebackStatusItems0AggregateLinks cluster nodes items0 ha giveback status items0 aggregate links
//
// swagger:model ClusterNodesItems0HaGivebackStatusItems0AggregateLinks
type ClusterNodesItems0HaGivebackStatusItems0AggregateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback status items0 aggregate links
func (m *ClusterNodesItems0HaGivebackStatusItems0AggregateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0AggregateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback status items0 aggregate links based on the context it is used
func (m *ClusterNodesItems0HaGivebackStatusItems0AggregateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0AggregateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0AggregateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0AggregateLinks) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGivebackStatusItems0AggregateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaGivebackStatusItems0Error Indicates the failed aggregate giveback code and message.
//
// swagger:model ClusterNodesItems0HaGivebackStatusItems0Error
type ClusterNodesItems0HaGivebackStatusItems0Error struct {

	// Message code.
	// Example: 852126
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Detailed message based on the state.
	// Read Only: true
	// Enum: [shutdown not_homes_partner not_sfo failed_limbo offline_failed migrating veto communication_err online_timeout online_failed hdd_to_aff_dest]
	Message string `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 ha giveback status items0 error
func (m *ClusterNodesItems0HaGivebackStatusItems0Error) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["shutdown","not_homes_partner","not_sfo","failed_limbo","offline_failed","migrating","veto","communication_err","online_timeout","online_failed","hdd_to_aff_dest"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum = append(clusterNodesItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// shutdown
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageShutdown captures enum value "shutdown"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageShutdown string = "shutdown"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// not_homes_partner
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageNotHomesPartner captures enum value "not_homes_partner"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageNotHomesPartner string = "not_homes_partner"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// not_sfo
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageNotSfo captures enum value "not_sfo"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageNotSfo string = "not_sfo"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// failed_limbo
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageFailedLimbo captures enum value "failed_limbo"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageFailedLimbo string = "failed_limbo"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// offline_failed
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageOfflineFailed captures enum value "offline_failed"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageOfflineFailed string = "offline_failed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// migrating
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageMigrating captures enum value "migrating"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageMigrating string = "migrating"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// veto
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageVeto captures enum value "veto"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageVeto string = "veto"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// communication_err
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageCommunicationErr captures enum value "communication_err"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageCommunicationErr string = "communication_err"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// online_timeout
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageOnlineTimeout captures enum value "online_timeout"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageOnlineTimeout string = "online_timeout"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// online_failed
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageOnlineFailed captures enum value "online_failed"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageOnlineFailed string = "online_failed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// ClusterNodesItems0HaGivebackStatusItems0Error
	// message
	// Message
	// hdd_to_aff_dest
	// END DEBUGGING
	// ClusterNodesItems0HaGivebackStatusItems0ErrorMessageHddToAffDest captures enum value "hdd_to_aff_dest"
	ClusterNodesItems0HaGivebackStatusItems0ErrorMessageHddToAffDest string = "hdd_to_aff_dest"
)

// prop value enum
func (m *ClusterNodesItems0HaGivebackStatusItems0Error) validateMessageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaGivebackStatusItems0ErrorTypeMessagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0Error) validateMessage(formats strfmt.Registry) error {
	if swag.IsZero(m.Message) { // not required
		return nil
	}

	// value enum
	if err := m.validateMessageEnum("error"+"."+"message", "body", m.Message); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha giveback status items0 error based on the context it is used
func (m *ClusterNodesItems0HaGivebackStatusItems0Error) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0Error) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "error"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0HaGivebackStatusItems0Error) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "error"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0Error) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaGivebackStatusItems0Error) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaGivebackStatusItems0Error
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaInterconnect cluster nodes items0 ha interconnect
//
// swagger:model ClusterNodesItems0HaInterconnect
type ClusterNodesItems0HaInterconnect struct {

	// HA interconnect device name.
	// Example: MVIA-RDMA
	// Read Only: true
	Adapter string `json:"adapter,omitempty"`

	// Indicates the HA interconnect status.
	// Read Only: true
	// Enum: [down up]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 ha interconnect
func (m *ClusterNodesItems0HaInterconnect) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0HaInterconnectTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["down","up"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaInterconnectTypeStatePropEnum = append(clusterNodesItems0HaInterconnectTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaInterconnect
	// ClusterNodesItems0HaInterconnect
	// state
	// State
	// down
	// END DEBUGGING
	// ClusterNodesItems0HaInterconnectStateDown captures enum value "down"
	ClusterNodesItems0HaInterconnectStateDown string = "down"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaInterconnect
	// ClusterNodesItems0HaInterconnect
	// state
	// State
	// up
	// END DEBUGGING
	// ClusterNodesItems0HaInterconnectStateUp captures enum value "up"
	ClusterNodesItems0HaInterconnectStateUp string = "up"
)

// prop value enum
func (m *ClusterNodesItems0HaInterconnect) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaInterconnectTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaInterconnect) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"interconnect"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha interconnect based on the context it is used
func (m *ClusterNodesItems0HaInterconnect) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdapter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaInterconnect) contextValidateAdapter(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"interconnect"+"."+"adapter", "body", string(m.Adapter)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0HaInterconnect) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"interconnect"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaInterconnect) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaInterconnect) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaInterconnect
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaPartnersItems0 cluster nodes items0 ha partners items0
//
// swagger:model ClusterNodesItems0HaPartnersItems0
type ClusterNodesItems0HaPartnersItems0 struct {

	// links
	Links *ClusterNodesItems0HaPartnersItems0Links `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 ha partners items0
func (m *ClusterNodesItems0HaPartnersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha partners items0 based on the context it is used
func (m *ClusterNodesItems0HaPartnersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaPartnersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaPartnersItems0Links cluster nodes items0 ha partners items0 links
//
// swagger:model ClusterNodesItems0HaPartnersItems0Links
type ClusterNodesItems0HaPartnersItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 ha partners items0 links
func (m *ClusterNodesItems0HaPartnersItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha partners items0 links based on the context it is used
func (m *ClusterNodesItems0HaPartnersItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPartnersItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaPartnersItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaPartnersItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaPortsItems0 cluster nodes items0 ha ports items0
//
// swagger:model ClusterNodesItems0HaPortsItems0
type ClusterNodesItems0HaPortsItems0 struct {

	// HA port number
	// Example: 0
	// Read Only: true
	Number int64 `json:"number,omitempty"`

	// HA port state:
	// * <i>down</i> - Logical HA link is down.
	// * <i>initialized</i> - Logical HA link is initialized. The physical link is up, but the subnet manager hasn’t started to configure the port.
	// * <i>armed</i> - Logical HA link is armed. The physical link is up and the subnet manager started but did not yet complete configuring the port.
	// * <i>active</i> - Logical HA link is active.
	// * <i>reserved</i> - Logical HA link is active, but the physical link is down.
	//
	// Example: active
	// Read Only: true
	// Enum: [down initialized armed active reserved]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 ha ports items0
func (m *ClusterNodesItems0HaPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0HaPortsItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["down","initialized","armed","active","reserved"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaPortsItems0TypeStatePropEnum = append(clusterNodesItems0HaPortsItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// down
	// END DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateDown captures enum value "down"
	ClusterNodesItems0HaPortsItems0StateDown string = "down"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// initialized
	// END DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateInitialized captures enum value "initialized"
	ClusterNodesItems0HaPortsItems0StateInitialized string = "initialized"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// armed
	// END DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateArmed captures enum value "armed"
	ClusterNodesItems0HaPortsItems0StateArmed string = "armed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// active
	// END DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateActive captures enum value "active"
	ClusterNodesItems0HaPortsItems0StateActive string = "active"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaPortsItems0
	// ClusterNodesItems0HaPortsItems0
	// state
	// State
	// reserved
	// END DEBUGGING
	// ClusterNodesItems0HaPortsItems0StateReserved captures enum value "reserved"
	ClusterNodesItems0HaPortsItems0StateReserved string = "reserved"
)

// prop value enum
func (m *ClusterNodesItems0HaPortsItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaPortsItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaPortsItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha ports items0 based on the context it is used
func (m *ClusterNodesItems0HaPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaPortsItems0) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "number", "body", int64(m.Number)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0HaPortsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaPortsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaTakeover This represents the state of the node that is taking over storage from its HA partner.
//
// swagger:model ClusterNodesItems0HaTakeover
type ClusterNodesItems0HaTakeover struct {

	// failure
	Failure *ClusterNodesItems0HaTakeoverFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [not_possible not_attempted in_takeover in_progress failed]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 ha takeover
func (m *ClusterNodesItems0HaTakeover) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaTakeover) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0HaTakeoverTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_possible","not_attempted","in_takeover","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HaTakeoverTypeStatePropEnum = append(clusterNodesItems0HaTakeoverTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// not_possible
	// END DEBUGGING
	// ClusterNodesItems0HaTakeoverStateNotPossible captures enum value "not_possible"
	ClusterNodesItems0HaTakeoverStateNotPossible string = "not_possible"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// not_attempted
	// END DEBUGGING
	// ClusterNodesItems0HaTakeoverStateNotAttempted captures enum value "not_attempted"
	ClusterNodesItems0HaTakeoverStateNotAttempted string = "not_attempted"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// in_takeover
	// END DEBUGGING
	// ClusterNodesItems0HaTakeoverStateInTakeover captures enum value "in_takeover"
	ClusterNodesItems0HaTakeoverStateInTakeover string = "in_takeover"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// in_progress
	// END DEBUGGING
	// ClusterNodesItems0HaTakeoverStateInProgress captures enum value "in_progress"
	ClusterNodesItems0HaTakeoverStateInProgress string = "in_progress"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HaTakeover
	// ClusterNodesItems0HaTakeover
	// state
	// State
	// failed
	// END DEBUGGING
	// ClusterNodesItems0HaTakeoverStateFailed captures enum value "failed"
	ClusterNodesItems0HaTakeoverStateFailed string = "failed"
)

// prop value enum
func (m *ClusterNodesItems0HaTakeover) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HaTakeoverTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HaTakeover) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"takeover"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 ha takeover based on the context it is used
func (m *ClusterNodesItems0HaTakeover) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HaTakeover) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeover) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeover) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaTakeover
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HaTakeoverFailure Indicates the failure code and message.
//
// swagger:model ClusterNodesItems0HaTakeoverFailure
type ClusterNodesItems0HaTakeoverFailure struct {

	// Message code
	// Example: 852130
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate takeover. Run the \"storage failover show-takeover\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this cluster nodes items0 ha takeover failure
func (m *ClusterNodesItems0HaTakeoverFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 ha takeover failure based on the context it is used
func (m *ClusterNodesItems0HaTakeoverFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeoverFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HaTakeoverFailure) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HaTakeoverFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HwAssist The hardware assist information.
//
// swagger:model ClusterNodesItems0HwAssist
type ClusterNodesItems0HwAssist struct {

	// status
	Status *ClusterNodesItems0HwAssistStatus `json:"status,omitempty"`
}

// Validate validates this cluster nodes items0 hw assist
func (m *ClusterNodesItems0HwAssist) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HwAssist) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 hw assist based on the context it is used
func (m *ClusterNodesItems0HwAssist) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HwAssist) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssist) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssist) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HwAssist
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HwAssistStatus cluster nodes items0 hw assist status
//
// swagger:model ClusterNodesItems0HwAssistStatus
type ClusterNodesItems0HwAssistStatus struct {

	// Indicates whether hardware assist is enabled on the node.
	Enabled bool `json:"enabled,omitempty"`

	// local
	Local *ClusterNodesItems0HwAssistStatusLocal `json:"local,omitempty"`

	// partner
	Partner *ClusterNodesItems0HwAssistStatusPartner `json:"partner,omitempty"`
}

// Validate validates this cluster nodes items0 hw assist status
func (m *ClusterNodesItems0HwAssistStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HwAssistStatus) validateLocal(formats strfmt.Registry) error {
	if swag.IsZero(m.Local) { // not required
		return nil
	}

	if m.Local != nil {
		if err := m.Local.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0HwAssistStatus) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(m.Partner) { // not required
		return nil
	}

	if m.Partner != nil {
		if err := m.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 hw assist status based on the context it is used
func (m *ClusterNodesItems0HwAssistStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0HwAssistStatus) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if m.Local != nil {
		if err := m.Local.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "local")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0HwAssistStatus) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if m.Partner != nil {
		if err := m.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hw_assist" + "." + "status" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssistStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssistStatus) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HwAssistStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HwAssistStatusLocal cluster nodes items0 hw assist status local
//
// swagger:model ClusterNodesItems0HwAssistStatusLocal
type ClusterNodesItems0HwAssistStatusLocal struct {

	// The hardware assist IP address.
	IP string `json:"ip,omitempty"`

	// The hardware assist port.
	Port int64 `json:"port,omitempty"`

	// The hardware assist monitor status.
	// Enum: [active inactive]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 hw assist status local
func (m *ClusterNodesItems0HwAssistStatusLocal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0HwAssistStatusLocalTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HwAssistStatusLocalTypeStatePropEnum = append(clusterNodesItems0HwAssistStatusLocalTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HwAssistStatusLocal
	// ClusterNodesItems0HwAssistStatusLocal
	// state
	// State
	// active
	// END DEBUGGING
	// ClusterNodesItems0HwAssistStatusLocalStateActive captures enum value "active"
	ClusterNodesItems0HwAssistStatusLocalStateActive string = "active"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HwAssistStatusLocal
	// ClusterNodesItems0HwAssistStatusLocal
	// state
	// State
	// inactive
	// END DEBUGGING
	// ClusterNodesItems0HwAssistStatusLocalStateInactive captures enum value "inactive"
	ClusterNodesItems0HwAssistStatusLocalStateInactive string = "inactive"
)

// prop value enum
func (m *ClusterNodesItems0HwAssistStatusLocal) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HwAssistStatusLocalTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HwAssistStatusLocal) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("hw_assist"+"."+"status"+"."+"local"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster nodes items0 hw assist status local based on context it is used
func (m *ClusterNodesItems0HwAssistStatusLocal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssistStatusLocal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssistStatusLocal) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HwAssistStatusLocal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0HwAssistStatusPartner cluster nodes items0 hw assist status partner
//
// swagger:model ClusterNodesItems0HwAssistStatusPartner
type ClusterNodesItems0HwAssistStatusPartner struct {

	// The hardware assist IP address.
	IP string `json:"ip,omitempty"`

	// The hardware assist port.
	Port int64 `json:"port,omitempty"`

	// The hardware assist monitor status.
	// Enum: [active inactive]
	State string `json:"state,omitempty"`
}

// Validate validates this cluster nodes items0 hw assist status partner
func (m *ClusterNodesItems0HwAssistStatusPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0HwAssistStatusPartnerTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0HwAssistStatusPartnerTypeStatePropEnum = append(clusterNodesItems0HwAssistStatusPartnerTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0HwAssistStatusPartner
	// ClusterNodesItems0HwAssistStatusPartner
	// state
	// State
	// active
	// END DEBUGGING
	// ClusterNodesItems0HwAssistStatusPartnerStateActive captures enum value "active"
	ClusterNodesItems0HwAssistStatusPartnerStateActive string = "active"

	// BEGIN DEBUGGING
	// ClusterNodesItems0HwAssistStatusPartner
	// ClusterNodesItems0HwAssistStatusPartner
	// state
	// State
	// inactive
	// END DEBUGGING
	// ClusterNodesItems0HwAssistStatusPartnerStateInactive captures enum value "inactive"
	ClusterNodesItems0HwAssistStatusPartnerStateInactive string = "inactive"
)

// prop value enum
func (m *ClusterNodesItems0HwAssistStatusPartner) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0HwAssistStatusPartnerTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0HwAssistStatusPartner) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("hw_assist"+"."+"status"+"."+"partner"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster nodes items0 hw assist status partner based on context it is used
func (m *ClusterNodesItems0HwAssistStatusPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssistStatusPartner) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0HwAssistStatusPartner) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0HwAssistStatusPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Links cluster nodes items0 links
//
// swagger:model ClusterNodesItems0Links
type ClusterNodesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 links
func (m *ClusterNodesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 links based on the context it is used
func (m *ClusterNodesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterface The management interface of the node to be added. The subnet mask is set based on the management interface of the cluster or the managment interfaces of other nodes.
//
// swagger:model ClusterNodesItems0ManagementInterface
type ClusterNodesItems0ManagementInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this cluster nodes items0 management interface
func (m *ClusterNodesItems0ManagementInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interface based on the context it is used
func (m *ClusterNodesItems0ManagementInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterfacesItems0 Network interface
//
// swagger:model ClusterNodesItems0ManagementInterfacesItems0
type ClusterNodesItems0ManagementInterfacesItems0 struct {

	// links
	Links *ClusterNodesItems0ManagementInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *ClusterNodesItems0ManagementInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface. If only the name is provided, the SVM scope
	// must be provided by the object this object is embedded in.
	//
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 management interfaces items0
func (m *ClusterNodesItems0ManagementInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interfaces items0 based on the context it is used
func (m *ClusterNodesItems0ManagementInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterfacesItems0IP IP information
//
// swagger:model ClusterNodesItems0ManagementInterfacesItems0IP
type ClusterNodesItems0ManagementInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this cluster nodes items0 management interfaces items0 IP
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interfaces items0 IP based on the context it is used
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ManagementInterfacesItems0Links cluster nodes items0 management interfaces items0 links
//
// swagger:model ClusterNodesItems0ManagementInterfacesItems0Links
type ClusterNodesItems0ManagementInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 management interfaces items0 links
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 management interfaces items0 links based on the context it is used
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ManagementInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ManagementInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ManagementInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Metric CPU performance for the nodes.
//
// swagger:model ClusterNodesItems0Metric
type ClusterNodesItems0Metric struct {

	// links
	Links *ClusterNodesItems0MetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Enum: [PT15S PT5M PT30M PT2H P1D]
	Duration string `json:"duration,omitempty"`

	// Average CPU Utilization for the node
	// Example: 13
	ProcessorUtilization int64 `json:"processor_utilization,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cluster nodes items0 metric
func (m *ClusterNodesItems0Metric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Metric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0MetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT5M","PT30M","PT2H","P1D"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0MetricTypeDurationPropEnum = append(clusterNodesItems0MetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// ClusterNodesItems0MetricDurationPT15S captures enum value "PT15S"
	ClusterNodesItems0MetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// ClusterNodesItems0MetricDurationPT5M captures enum value "PT5M"
	ClusterNodesItems0MetricDurationPT5M string = "PT5M"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// ClusterNodesItems0MetricDurationPT30M captures enum value "PT30M"
	ClusterNodesItems0MetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// ClusterNodesItems0MetricDurationPT2H captures enum value "PT2H"
	ClusterNodesItems0MetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// ClusterNodesItems0MetricDurationP1D captures enum value "P1D"
	ClusterNodesItems0MetricDurationP1D string = "P1D"
)

// prop value enum
func (m *ClusterNodesItems0Metric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0MetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0Metric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

var clusterNodesItems0MetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0MetricTypeStatusPropEnum = append(clusterNodesItems0MetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// ok
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusOk captures enum value "ok"
	ClusterNodesItems0MetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// error
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusError captures enum value "error"
	ClusterNodesItems0MetricStatusError string = "error"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusPartialNoData captures enum value "partial_no_data"
	ClusterNodesItems0MetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	ClusterNodesItems0MetricStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusPartialNoResponse captures enum value "partial_no_response"
	ClusterNodesItems0MetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusPartialOtherError captures enum value "partial_other_error"
	ClusterNodesItems0MetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusNegativeDelta captures enum value "negative_delta"
	ClusterNodesItems0MetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusBackfilledData captures enum value "backfilled_data"
	ClusterNodesItems0MetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	ClusterNodesItems0MetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metric
	// ClusterNodesItems0Metric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// ClusterNodesItems0MetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	ClusterNodesItems0MetricStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *ClusterNodesItems0Metric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0MetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0Metric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Metric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 metric based on the context it is used
func (m *ClusterNodesItems0Metric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Metric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Metric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Metric) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Metric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0MetricLinks cluster nodes items0 metric links
//
// swagger:model ClusterNodesItems0MetricLinks
type ClusterNodesItems0MetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cluster nodes items0 metric links
func (m *ClusterNodesItems0MetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0MetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 metric links based on the context it is used
func (m *ClusterNodesItems0MetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0MetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0MetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0MetricLinks) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0MetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Metrocluster Metrocluster
//
// swagger:model ClusterNodesItems0Metrocluster
type ClusterNodesItems0Metrocluster struct {

	// Indicates whether the MetroCluster over IP platform supports custom VLAN IDs.
	// Read Only: true
	CustomVlanCapable *bool `json:"custom_vlan_capable,omitempty"`

	// MetroCluster over IP ports.
	// Read Only: true
	Ports []*ClusterNodesItems0MetroclusterPortsItems0 `json:"ports,omitempty"`

	// The Metrocluster configuration type
	// Read Only: true
	// Enum: [fc fc_2_node ip]
	Type string `json:"type,omitempty"`
}

// Validate validates this cluster nodes items0 metrocluster
func (m *ClusterNodesItems0Metrocluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Metrocluster) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrocluster" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var clusterNodesItems0MetroclusterTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fc","fc_2_node","ip"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0MetroclusterTypeTypePropEnum = append(clusterNodesItems0MetroclusterTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metrocluster
	// ClusterNodesItems0Metrocluster
	// type
	// Type
	// fc
	// END DEBUGGING
	// ClusterNodesItems0MetroclusterTypeFc captures enum value "fc"
	ClusterNodesItems0MetroclusterTypeFc string = "fc"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metrocluster
	// ClusterNodesItems0Metrocluster
	// type
	// Type
	// fc_2_node
	// END DEBUGGING
	// ClusterNodesItems0MetroclusterTypeFc2Node captures enum value "fc_2_node"
	ClusterNodesItems0MetroclusterTypeFc2Node string = "fc_2_node"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Metrocluster
	// ClusterNodesItems0Metrocluster
	// type
	// Type
	// ip
	// END DEBUGGING
	// ClusterNodesItems0MetroclusterTypeIP captures enum value "ip"
	ClusterNodesItems0MetroclusterTypeIP string = "ip"
)

// prop value enum
func (m *ClusterNodesItems0Metrocluster) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0MetroclusterTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0Metrocluster) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("metrocluster"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 metrocluster based on the context it is used
func (m *ClusterNodesItems0Metrocluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCustomVlanCapable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Metrocluster) contextValidateCustomVlanCapable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metrocluster"+"."+"custom_vlan_capable", "body", m.CustomVlanCapable); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Metrocluster) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metrocluster"+"."+"ports", "body", []*ClusterNodesItems0MetroclusterPortsItems0(m.Ports)); err != nil {
		return err
	}

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrocluster" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNodesItems0Metrocluster) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metrocluster"+"."+"type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Metrocluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Metrocluster) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Metrocluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0MetroclusterPortsItems0 cluster nodes items0 metrocluster ports items0
//
// swagger:model ClusterNodesItems0MetroclusterPortsItems0
type ClusterNodesItems0MetroclusterPortsItems0 struct {

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`
}

// Validate validates this cluster nodes items0 metrocluster ports items0
func (m *ClusterNodesItems0MetroclusterPortsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cluster nodes items0 metrocluster ports items0 based on context it is used
func (m *ClusterNodesItems0MetroclusterPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0MetroclusterPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0MetroclusterPortsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0MetroclusterPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Nvram cluster nodes items0 nvram
//
// swagger:model ClusterNodesItems0Nvram
type ClusterNodesItems0Nvram struct {

	// Specifies status of the NVRAM battery. Possible values:
	// * <i>battery_ok</i>
	// * <i>battery_partially_discharged</i>
	// * <i>battery_fully_discharged</i>
	// * <i>battery_not_present</i>
	// * <i>battery_near_end_of_life</i>
	// * <i>battery_at_end_of_life</i>
	// * <i>battery_unknown</i>
	// * <i>battery_over_charged</i>
	// * <i>battery_fully_charged</i>
	//
	// Read Only: true
	// Enum: [battery_ok battery_partially_discharged battery_fully_discharged battery_not_present battery_near_end_of_life battery_at_end_of_life battery_unknown battery_over_charged battery_fully_charged]
	BatteryState string `json:"battery_state,omitempty"`

	// Vendor specific NVRAM ID of the node.
	// Read Only: true
	ID int64 `json:"id,omitempty"`
}

// Validate validates this cluster nodes items0 nvram
func (m *ClusterNodesItems0Nvram) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBatteryState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0NvramTypeBatteryStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["battery_ok","battery_partially_discharged","battery_fully_discharged","battery_not_present","battery_near_end_of_life","battery_at_end_of_life","battery_unknown","battery_over_charged","battery_fully_charged"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0NvramTypeBatteryStatePropEnum = append(clusterNodesItems0NvramTypeBatteryStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_ok
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryOk captures enum value "battery_ok"
	ClusterNodesItems0NvramBatteryStateBatteryOk string = "battery_ok"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_partially_discharged
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryPartiallyDischarged captures enum value "battery_partially_discharged"
	ClusterNodesItems0NvramBatteryStateBatteryPartiallyDischarged string = "battery_partially_discharged"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_fully_discharged
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryFullyDischarged captures enum value "battery_fully_discharged"
	ClusterNodesItems0NvramBatteryStateBatteryFullyDischarged string = "battery_fully_discharged"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_not_present
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryNotPresent captures enum value "battery_not_present"
	ClusterNodesItems0NvramBatteryStateBatteryNotPresent string = "battery_not_present"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_near_end_of_life
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryNearEndOfLife captures enum value "battery_near_end_of_life"
	ClusterNodesItems0NvramBatteryStateBatteryNearEndOfLife string = "battery_near_end_of_life"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_at_end_of_life
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryAtEndOfLife captures enum value "battery_at_end_of_life"
	ClusterNodesItems0NvramBatteryStateBatteryAtEndOfLife string = "battery_at_end_of_life"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_unknown
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryUnknown captures enum value "battery_unknown"
	ClusterNodesItems0NvramBatteryStateBatteryUnknown string = "battery_unknown"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_over_charged
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryOverCharged captures enum value "battery_over_charged"
	ClusterNodesItems0NvramBatteryStateBatteryOverCharged string = "battery_over_charged"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Nvram
	// ClusterNodesItems0Nvram
	// battery_state
	// BatteryState
	// battery_fully_charged
	// END DEBUGGING
	// ClusterNodesItems0NvramBatteryStateBatteryFullyCharged captures enum value "battery_fully_charged"
	ClusterNodesItems0NvramBatteryStateBatteryFullyCharged string = "battery_fully_charged"
)

// prop value enum
func (m *ClusterNodesItems0Nvram) validateBatteryStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0NvramTypeBatteryStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0Nvram) validateBatteryState(formats strfmt.Registry) error {
	if swag.IsZero(m.BatteryState) { // not required
		return nil
	}

	// value enum
	if err := m.validateBatteryStateEnum("nvram"+"."+"battery_state", "body", m.BatteryState); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 nvram based on the context it is used
func (m *ClusterNodesItems0Nvram) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBatteryState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Nvram) contextValidateBatteryState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nvram"+"."+"battery_state", "body", string(m.BatteryState)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Nvram) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nvram"+"."+"id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Nvram) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Nvram) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Nvram
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessor cluster nodes items0 service processor
//
// swagger:model ClusterNodesItems0ServiceProcessor
type ClusterNodesItems0ServiceProcessor struct {

	// api service
	APIService *ClusterNodesItems0ServiceProcessorAPIService `json:"api_service,omitempty"`

	// auto config
	AutoConfig *ClusterNodesItems0ServiceProcessorAutoConfig `json:"auto_config,omitempty"`

	// Indicates whether the service processor can be automatically updated from ONTAP.
	AutoupdateEnabled bool `json:"autoupdate_enabled,omitempty"`

	// backup
	Backup *ClusterNodesItems0ServiceProcessorBackup `json:"backup,omitempty"`

	// Set to "true" to use DHCP to configure an IPv4 interface. Do not provide values for address, netmask and gateway when set to "true".
	DhcpEnabled bool `json:"dhcp_enabled,omitempty"`

	// The version of firmware installed.
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// ipv4 interface
	IPV4Interface *ClusterNodesItems0ServiceProcessorIPV4Interface `json:"ipv4_interface,omitempty"`

	// ipv6 interface
	IPV6Interface *ClusterNodesItems0ServiceProcessorIPV6Interface `json:"ipv6_interface,omitempty"`

	// Indicates whether the service processor network is configured.
	// Read Only: true
	IsIPConfigured *bool `json:"is_ip_configured,omitempty"`

	// Provides the "update status" of the last service processor update.
	// Read Only: true
	// Enum: [failed passed]
	LastUpdateState string `json:"last_update_state,omitempty"`

	// link status
	// Read Only: true
	// Enum: [up down disabled unknown]
	LinkStatus string `json:"link_status,omitempty"`

	// mac address
	// Read Only: true
	MacAddress string `json:"mac_address,omitempty"`

	// primary
	Primary *ClusterNodesItems0ServiceProcessorPrimary `json:"primary,omitempty"`

	// ssh info
	SSHInfo *ClusterNodesItems0ServiceProcessorSSHInfo `json:"ssh_info,omitempty"`

	// state
	// Read Only: true
	// Enum: [online offline degraded rebooting unknown updating node_offline sp_daemon_offline]
	State string `json:"state,omitempty"`

	// type
	// Read Only: true
	// Enum: [sp none bmc]
	Type string `json:"type,omitempty"`
}

// Validate validates this cluster nodes items0 service processor
func (m *ClusterNodesItems0ServiceProcessor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAPIService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV4Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV6Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSSHInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateAPIService(formats strfmt.Registry) error {
	if swag.IsZero(m.APIService) { // not required
		return nil
	}

	if m.APIService != nil {
		if err := m.APIService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "api_service")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateAutoConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoConfig) { // not required
		return nil
	}

	if m.AutoConfig != nil {
		if err := m.AutoConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "auto_config")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateBackup(formats strfmt.Registry) error {
	if swag.IsZero(m.Backup) { // not required
		return nil
	}

	if m.Backup != nil {
		if err := m.Backup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "backup")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateIPV4Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV4Interface) { // not required
		return nil
	}

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateIPV6Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV6Interface) { // not required
		return nil
	}

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0ServiceProcessorTypeLastUpdateStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["failed","passed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorTypeLastUpdateStatePropEnum = append(clusterNodesItems0ServiceProcessorTypeLastUpdateStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// last_update_state
	// LastUpdateState
	// failed
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorLastUpdateStateFailed captures enum value "failed"
	ClusterNodesItems0ServiceProcessorLastUpdateStateFailed string = "failed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// last_update_state
	// LastUpdateState
	// passed
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorLastUpdateStatePassed captures enum value "passed"
	ClusterNodesItems0ServiceProcessorLastUpdateStatePassed string = "passed"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessor) validateLastUpdateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorTypeLastUpdateStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateLastUpdateState(formats strfmt.Registry) error {
	if swag.IsZero(m.LastUpdateState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLastUpdateStateEnum("service_processor"+"."+"last_update_state", "body", m.LastUpdateState); err != nil {
		return err
	}

	return nil
}

var clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down","disabled","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum = append(clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// up
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusUp captures enum value "up"
	ClusterNodesItems0ServiceProcessorLinkStatusUp string = "up"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// down
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusDown captures enum value "down"
	ClusterNodesItems0ServiceProcessorLinkStatusDown string = "down"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// disabled
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusDisabled captures enum value "disabled"
	ClusterNodesItems0ServiceProcessorLinkStatusDisabled string = "disabled"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// link_status
	// LinkStatus
	// unknown
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorLinkStatusUnknown captures enum value "unknown"
	ClusterNodesItems0ServiceProcessorLinkStatusUnknown string = "unknown"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessor) validateLinkStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorTypeLinkStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateLinkStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.LinkStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkStatusEnum("service_processor"+"."+"link_status", "body", m.LinkStatus); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validatePrimary(formats strfmt.Registry) error {
	if swag.IsZero(m.Primary) { // not required
		return nil
	}

	if m.Primary != nil {
		if err := m.Primary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "primary")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateSSHInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.SSHInfo) { // not required
		return nil
	}

	if m.SSHInfo != nil {
		if err := m.SSHInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info")
			}
			return err
		}
	}

	return nil
}

var clusterNodesItems0ServiceProcessorTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","offline","degraded","rebooting","unknown","updating","node_offline","sp_daemon_offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorTypeStatePropEnum = append(clusterNodesItems0ServiceProcessorTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// online
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateOnline captures enum value "online"
	ClusterNodesItems0ServiceProcessorStateOnline string = "online"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// offline
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateOffline captures enum value "offline"
	ClusterNodesItems0ServiceProcessorStateOffline string = "offline"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// degraded
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateDegraded captures enum value "degraded"
	ClusterNodesItems0ServiceProcessorStateDegraded string = "degraded"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// rebooting
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateRebooting captures enum value "rebooting"
	ClusterNodesItems0ServiceProcessorStateRebooting string = "rebooting"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// unknown
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateUnknown captures enum value "unknown"
	ClusterNodesItems0ServiceProcessorStateUnknown string = "unknown"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// updating
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateUpdating captures enum value "updating"
	ClusterNodesItems0ServiceProcessorStateUpdating string = "updating"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// node_offline
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateNodeOffline captures enum value "node_offline"
	ClusterNodesItems0ServiceProcessorStateNodeOffline string = "node_offline"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// state
	// State
	// sp_daemon_offline
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorStateSpDaemonOffline captures enum value "sp_daemon_offline"
	ClusterNodesItems0ServiceProcessorStateSpDaemonOffline string = "sp_daemon_offline"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessor) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var clusterNodesItems0ServiceProcessorTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["sp","none","bmc"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorTypeTypePropEnum = append(clusterNodesItems0ServiceProcessorTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// type
	// Type
	// sp
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorTypeSp captures enum value "sp"
	ClusterNodesItems0ServiceProcessorTypeSp string = "sp"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// type
	// Type
	// none
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorTypeNone captures enum value "none"
	ClusterNodesItems0ServiceProcessorTypeNone string = "none"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessor
	// ClusterNodesItems0ServiceProcessor
	// type
	// Type
	// bmc
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorTypeBmc captures enum value "bmc"
	ClusterNodesItems0ServiceProcessorTypeBmc string = "bmc"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessor) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("service_processor"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor based on the context it is used
func (m *ClusterNodesItems0ServiceProcessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAPIService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutoConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV4Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV6Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsIPConfigured(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinkStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSSHInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateAPIService(ctx context.Context, formats strfmt.Registry) error {

	if m.APIService != nil {
		if err := m.APIService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "api_service")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateAutoConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoConfig != nil {
		if err := m.AutoConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "auto_config")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateBackup(ctx context.Context, formats strfmt.Registry) error {

	if m.Backup != nil {
		if err := m.Backup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "backup")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateIPV4Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateIPV6Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateIsIPConfigured(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"is_ip_configured", "body", m.IsIPConfigured); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateLastUpdateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"last_update_state", "body", string(m.LastUpdateState)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateLinkStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"link_status", "body", string(m.LinkStatus)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateMacAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"mac_address", "body", string(m.MacAddress)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidatePrimary(ctx context.Context, formats strfmt.Registry) error {

	if m.Primary != nil {
		if err := m.Primary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "primary")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateSSHInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.SSHInfo != nil {
		if err := m.SSHInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessor) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessor) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorAPIService Provides the properties of the service processor API service.
//
// swagger:model ClusterNodesItems0ServiceProcessorAPIService
type ClusterNodesItems0ServiceProcessorAPIService struct {

	// Indicates whether the service processor API service is enabled.
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// Indicates whether the service processor API service limit access is enabled.
	// Read Only: true
	LimitAccess *bool `json:"limit_access,omitempty"`

	// Indicates the port number of service processor API service.
	// Read Only: true
	Port int64 `json:"port,omitempty"`
}

// Validate validates this cluster nodes items0 service processor API service
func (m *ClusterNodesItems0ServiceProcessorAPIService) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 service processor API service based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorAPIService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorAPIService) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"api_service"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessorAPIService) contextValidateLimitAccess(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"api_service"+"."+"limit_access", "body", m.LimitAccess); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessorAPIService) contextValidatePort(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"api_service"+"."+"port", "body", int64(m.Port)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorAPIService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorAPIService) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorAPIService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorAutoConfig Provides the properties of the service processor auto configuration.
//
// swagger:model ClusterNodesItems0ServiceProcessorAutoConfig
type ClusterNodesItems0ServiceProcessorAutoConfig struct {

	// Indicates the service processor auto configuration IPv4 subnet name. To enable IPv4 auto-config give the subnet name, give the value as null or an empty string "" to disable auto-config.
	// Example: ipv4_mgmt
	IPV4Subnet string `json:"ipv4_subnet,omitempty"`

	// Indicates the service processor auto configuration IPv6 subnet name. To enable IPv6 auto-config give the subnet name, give the value as null or an empty string "" to disable auto-config.
	// Example: ipv6_mgmt
	IPV6Subnet string `json:"ipv6_subnet,omitempty"`
}

// Validate validates this cluster nodes items0 service processor auto config
func (m *ClusterNodesItems0ServiceProcessorAutoConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 service processor auto config based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorAutoConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorAutoConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorAutoConfig) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorAutoConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorBackup Provides the properties of the service processor backup partition.
//
// swagger:model ClusterNodesItems0ServiceProcessorBackup
type ClusterNodesItems0ServiceProcessorBackup struct {

	// Indicates whether the service processor is currently booted from the backup partition.
	// Read Only: true
	IsCurrent *bool `json:"is_current,omitempty"`

	// Status of the backup partition.
	// Read Only: true
	// Enum: [installed corrupt updating auto_updating none]
	State string `json:"state,omitempty"`

	// Firmware version of the backup partition.
	// Example: 11.6
	// Read Only: true
	Version string `json:"version,omitempty"`
}

// Validate validates this cluster nodes items0 service processor backup
func (m *ClusterNodesItems0ServiceProcessorBackup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0ServiceProcessorBackupTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["installed","corrupt","updating","auto_updating","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorBackupTypeStatePropEnum = append(clusterNodesItems0ServiceProcessorBackupTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackup
	// ClusterNodesItems0ServiceProcessorBackup
	// state
	// State
	// installed
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackupStateInstalled captures enum value "installed"
	ClusterNodesItems0ServiceProcessorBackupStateInstalled string = "installed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackup
	// ClusterNodesItems0ServiceProcessorBackup
	// state
	// State
	// corrupt
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackupStateCorrupt captures enum value "corrupt"
	ClusterNodesItems0ServiceProcessorBackupStateCorrupt string = "corrupt"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackup
	// ClusterNodesItems0ServiceProcessorBackup
	// state
	// State
	// updating
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackupStateUpdating captures enum value "updating"
	ClusterNodesItems0ServiceProcessorBackupStateUpdating string = "updating"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackup
	// ClusterNodesItems0ServiceProcessorBackup
	// state
	// State
	// auto_updating
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackupStateAutoUpdating captures enum value "auto_updating"
	ClusterNodesItems0ServiceProcessorBackupStateAutoUpdating string = "auto_updating"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackup
	// ClusterNodesItems0ServiceProcessorBackup
	// state
	// State
	// none
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorBackupStateNone captures enum value "none"
	ClusterNodesItems0ServiceProcessorBackupStateNone string = "none"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessorBackup) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorBackupTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorBackup) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"backup"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor backup based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorBackup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIsCurrent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorBackup) contextValidateIsCurrent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"backup"+"."+"is_current", "body", m.IsCurrent); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessorBackup) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"backup"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessorBackup) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"backup"+"."+"version", "body", string(m.Version)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorBackup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorBackup) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorBackup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorIPV4Interface Object to setup an interface along with its default router.
//
// swagger:model ClusterNodesItems0ServiceProcessorIPV4Interface
type ClusterNodesItems0ServiceProcessorIPV4Interface struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this cluster nodes items0 service processor IP v4 interface
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor IP v4 interface based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV4Interface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorIPV4Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorIPV6Interface Object to setup an interface along with its default router.
//
// swagger:model ClusterNodesItems0ServiceProcessorIPV6Interface
type ClusterNodesItems0ServiceProcessorIPV6Interface struct {

	// IPv6 address
	// Example: fd20:8b1e:b255:5011:10:141:4:97
	Address string `json:"address,omitempty"`

	// The IPv6 address of the default router.
	// Example: fd20:8b1e:b255:5011:10::1
	Gateway string `json:"gateway,omitempty"`

	// The IPv6 netmask/prefix length. The default value is 64 with a valid range of 1 to 127.
	// Example: 64
	Netmask int64 `json:"netmask,omitempty"`
}

// Validate validates this cluster nodes items0 service processor IP v6 interface
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cluster nodes items0 service processor IP v6 interface based on context it is used
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorIPV6Interface) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorIPV6Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorPrimary Provides the properties of the service processor primary partition.
//
// swagger:model ClusterNodesItems0ServiceProcessorPrimary
type ClusterNodesItems0ServiceProcessorPrimary struct {

	// Indicates whether the service processor is currently booted from the primary partition.
	// Read Only: true
	IsCurrent *bool `json:"is_current,omitempty"`

	// Status of the primary partition.
	// Read Only: true
	// Enum: [installed corrupt updating auto_updating none]
	State string `json:"state,omitempty"`

	// Firmware version of the primary partition.
	// Example: 11.6
	// Read Only: true
	Version string `json:"version,omitempty"`
}

// Validate validates this cluster nodes items0 service processor primary
func (m *ClusterNodesItems0ServiceProcessorPrimary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0ServiceProcessorPrimaryTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["installed","corrupt","updating","auto_updating","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0ServiceProcessorPrimaryTypeStatePropEnum = append(clusterNodesItems0ServiceProcessorPrimaryTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimary
	// ClusterNodesItems0ServiceProcessorPrimary
	// state
	// State
	// installed
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimaryStateInstalled captures enum value "installed"
	ClusterNodesItems0ServiceProcessorPrimaryStateInstalled string = "installed"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimary
	// ClusterNodesItems0ServiceProcessorPrimary
	// state
	// State
	// corrupt
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimaryStateCorrupt captures enum value "corrupt"
	ClusterNodesItems0ServiceProcessorPrimaryStateCorrupt string = "corrupt"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimary
	// ClusterNodesItems0ServiceProcessorPrimary
	// state
	// State
	// updating
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimaryStateUpdating captures enum value "updating"
	ClusterNodesItems0ServiceProcessorPrimaryStateUpdating string = "updating"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimary
	// ClusterNodesItems0ServiceProcessorPrimary
	// state
	// State
	// auto_updating
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimaryStateAutoUpdating captures enum value "auto_updating"
	ClusterNodesItems0ServiceProcessorPrimaryStateAutoUpdating string = "auto_updating"

	// BEGIN DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimary
	// ClusterNodesItems0ServiceProcessorPrimary
	// state
	// State
	// none
	// END DEBUGGING
	// ClusterNodesItems0ServiceProcessorPrimaryStateNone captures enum value "none"
	ClusterNodesItems0ServiceProcessorPrimaryStateNone string = "none"
)

// prop value enum
func (m *ClusterNodesItems0ServiceProcessorPrimary) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0ServiceProcessorPrimaryTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorPrimary) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"primary"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor primary based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorPrimary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIsCurrent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorPrimary) contextValidateIsCurrent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"primary"+"."+"is_current", "body", m.IsCurrent); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessorPrimary) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"primary"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0ServiceProcessorPrimary) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"primary"+"."+"version", "body", string(m.Version)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorPrimary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorPrimary) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorPrimary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0ServiceProcessorSSHInfo Service processor SSH allowed IP address configuration applied across the cluster.
//
// swagger:model ClusterNodesItems0ServiceProcessorSSHInfo
type ClusterNodesItems0ServiceProcessorSSHInfo struct {

	// Allowed IP addresses
	AllowedAddresses []IPAddressAndNetmask `json:"allowed_addresses,omitempty"`
}

// Validate validates this cluster nodes items0 service processor SSH info
func (m *ClusterNodesItems0ServiceProcessorSSHInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAllowedAddresses(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorSSHInfo) validateAllowedAddresses(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowedAddresses) { // not required
		return nil
	}

	for i := 0; i < len(m.AllowedAddresses); i++ {

		if err := m.AllowedAddresses[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info" + "." + "allowed_addresses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this cluster nodes items0 service processor SSH info based on the context it is used
func (m *ClusterNodesItems0ServiceProcessorSSHInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAllowedAddresses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0ServiceProcessorSSHInfo) contextValidateAllowedAddresses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AllowedAddresses); i++ {

		if err := m.AllowedAddresses[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ssh_info" + "." + "allowed_addresses" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorSSHInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0ServiceProcessorSSHInfo) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0ServiceProcessorSSHInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Statistics Raw CPU performance for the nodes.
//
// swagger:model ClusterNodesItems0Statistics
type ClusterNodesItems0Statistics struct {

	// Base counter for CPU Utilization.
	// Example: 12345123
	ProcessorUtilizationBase int64 `json:"processor_utilization_base,omitempty"`

	// Raw CPU Utilization for the node. This should be divided by the processor_utilization_base to calculate the percentage CPU utilization for the node.
	// Example: 13
	ProcessorUtilizationRaw int64 `json:"processor_utilization_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this cluster nodes items0 statistics
func (m *ClusterNodesItems0Statistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0StatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0StatisticsTypeStatusPropEnum = append(clusterNodesItems0StatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusOk captures enum value "ok"
	ClusterNodesItems0StatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// error
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusError captures enum value "error"
	ClusterNodesItems0StatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusPartialNoData captures enum value "partial_no_data"
	ClusterNodesItems0StatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	ClusterNodesItems0StatisticsStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	ClusterNodesItems0StatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusPartialOtherError captures enum value "partial_other_error"
	ClusterNodesItems0StatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusNegativeDelta captures enum value "negative_delta"
	ClusterNodesItems0StatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusBackfilledData captures enum value "backfilled_data"
	ClusterNodesItems0StatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	ClusterNodesItems0StatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// ClusterNodesItems0Statistics
	// ClusterNodesItems0Statistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// ClusterNodesItems0StatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	ClusterNodesItems0StatisticsStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *ClusterNodesItems0Statistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0StatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0Statistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Statistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster nodes items0 statistics based on context it is used
func (m *ClusterNodesItems0Statistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Statistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Statistics) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Statistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0VM cluster nodes items0 VM
//
// swagger:model ClusterNodesItems0VM
type ClusterNodesItems0VM struct {

	// Cloud provider where the VM is hosted.
	// Read Only: true
	// Enum: [GoogleCloud AWS_S3 Azure_Cloud]
	ProviderType string `json:"provider_type,omitempty"`
}

// Validate validates this cluster nodes items0 VM
func (m *ClusterNodesItems0VM) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProviderType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterNodesItems0VmTypeProviderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GoogleCloud","AWS_S3","Azure_Cloud"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterNodesItems0VmTypeProviderTypePropEnum = append(clusterNodesItems0VmTypeProviderTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterNodesItems0VM
	// ClusterNodesItems0VM
	// provider_type
	// ProviderType
	// GoogleCloud
	// END DEBUGGING
	// ClusterNodesItems0VMProviderTypeGoogleCloud captures enum value "GoogleCloud"
	ClusterNodesItems0VMProviderTypeGoogleCloud string = "GoogleCloud"

	// BEGIN DEBUGGING
	// ClusterNodesItems0VM
	// ClusterNodesItems0VM
	// provider_type
	// ProviderType
	// AWS_S3
	// END DEBUGGING
	// ClusterNodesItems0VMProviderTypeAWSS3 captures enum value "AWS_S3"
	ClusterNodesItems0VMProviderTypeAWSS3 string = "AWS_S3"

	// BEGIN DEBUGGING
	// ClusterNodesItems0VM
	// ClusterNodesItems0VM
	// provider_type
	// ProviderType
	// Azure_Cloud
	// END DEBUGGING
	// ClusterNodesItems0VMProviderTypeAzureCloud captures enum value "Azure_Cloud"
	ClusterNodesItems0VMProviderTypeAzureCloud string = "Azure_Cloud"
)

// prop value enum
func (m *ClusterNodesItems0VM) validateProviderTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterNodesItems0VmTypeProviderTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterNodesItems0VM) validateProviderType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProviderType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProviderTypeEnum("vm"+"."+"provider_type", "body", m.ProviderType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster nodes items0 VM based on the context it is used
func (m *ClusterNodesItems0VM) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProviderType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0VM) contextValidateProviderType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vm"+"."+"provider_type", "body", string(m.ProviderType)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0VM) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0VM) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0VM
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterNodesItems0Version This returns the cluster version information.  When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.
//
// swagger:model ClusterNodesItems0Version
type ClusterNodesItems0Version struct {

	// The full cluster version string.
	// Example: NetApp Release 9.4.0: Sun Nov 05 18:20:57 UTC 2017
	// Read Only: true
	Full string `json:"full,omitempty"`

	// The generation portion of the version.
	// Example: 9
	// Read Only: true
	Generation int64 `json:"generation,omitempty"`

	// The major portion of the version.
	// Example: 4
	// Read Only: true
	Major int64 `json:"major,omitempty"`

	// The minor portion of the version.
	// Example: 0
	// Read Only: true
	Minor int64 `json:"minor,omitempty"`
}

// Validate validates this cluster nodes items0 version
func (m *ClusterNodesItems0Version) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster nodes items0 version based on the context it is used
func (m *ClusterNodesItems0Version) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMajor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNodesItems0Version) contextValidateFull(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"full", "body", string(m.Full)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Version) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Version) contextValidateMajor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"major", "body", int64(m.Major)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNodesItems0Version) contextValidateMinor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"minor", "body", int64(m.Minor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNodesItems0Version) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNodesItems0Version) UnmarshalBinary(b []byte) error {
	var res ClusterNodesItems0Version
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterPeeringPolicy cluster peering policy
//
// swagger:model ClusterPeeringPolicy
type ClusterPeeringPolicy struct {

	// Indicates whether authentication is required in the communication between cluster peers. If true, authentication is required to establish communication between cluster peers.
	// Read Only: true
	AuthenticationRequired *bool `json:"authentication_required,omitempty"`

	// Indicates whether encryption is required in the communication between cluster peers. If true, encryption is required to establish communication between cluster peers.
	// Read Only: true
	EncryptionRequired *bool `json:"encryption_required,omitempty"`

	// Minimum required length for a passphrase. For more information on password strength best practices, see: https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#implement-proper-password-strength-controls
	// Read Only: true
	// Maximum: 1500
	// Minimum: 0
	MinimumPassphraseLength int64 `json:"minimum_passphrase_length,omitempty"`
}

// Validate validates this cluster peering policy
func (m *ClusterPeeringPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMinimumPassphraseLength(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeeringPolicy) validateMinimumPassphraseLength(formats strfmt.Registry) error {
	if swag.IsZero(m.MinimumPassphraseLength) { // not required
		return nil
	}

	if err := validate.MinimumInt("peering_policy"+"."+"minimum_passphrase_length", "body", m.MinimumPassphraseLength, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("peering_policy"+"."+"minimum_passphrase_length", "body", m.MinimumPassphraseLength, 1500, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster peering policy based on the context it is used
func (m *ClusterPeeringPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthenticationRequired(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEncryptionRequired(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinimumPassphraseLength(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterPeeringPolicy) contextValidateAuthenticationRequired(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "peering_policy"+"."+"authentication_required", "body", m.AuthenticationRequired); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeeringPolicy) contextValidateEncryptionRequired(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "peering_policy"+"."+"encryption_required", "body", m.EncryptionRequired); err != nil {
		return err
	}

	return nil
}

func (m *ClusterPeeringPolicy) contextValidateMinimumPassphraseLength(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "peering_policy"+"."+"minimum_passphrase_length", "body", int64(m.MinimumPassphraseLength)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterPeeringPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterPeeringPolicy) UnmarshalBinary(b []byte) error {
	var res ClusterPeeringPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatistics cluster statistics
//
// swagger:model ClusterStatistics
type ClusterStatistics struct {

	// iops raw
	IopsRaw *ClusterStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *ClusterStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *ClusterStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this cluster statistics
func (m *ClusterStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var clusterStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterStatisticsTypeStatusPropEnum = append(clusterStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// ClusterStatisticsStatusOk captures enum value "ok"
	ClusterStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// ClusterStatisticsStatusError captures enum value "error"
	ClusterStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// ClusterStatisticsStatusPartialNoData captures enum value "partial_no_data"
	ClusterStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// ClusterStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	ClusterStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// ClusterStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	ClusterStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// ClusterStatisticsStatusNegativeDelta captures enum value "negative_delta"
	ClusterStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// not_found
	// END DEBUGGING
	// ClusterStatisticsStatusNotFound captures enum value "not_found"
	ClusterStatisticsStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// ClusterStatisticsStatusBackfilledData captures enum value "backfilled_data"
	ClusterStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// ClusterStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	ClusterStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// ClusterStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	ClusterStatisticsStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// ClusterStatistics
	// ClusterStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// ClusterStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	ClusterStatisticsStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *ClusterStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster statistics based on the context it is used
func (m *ClusterStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatistics) UnmarshalBinary(b []byte) error {
	var res ClusterStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatisticsIopsRaw The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model ClusterStatisticsIopsRaw
type ClusterStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster statistics iops raw
func (m *ClusterStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster statistics iops raw based on the context it is used
func (m *ClusterStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res ClusterStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model ClusterStatisticsLatencyRaw
type ClusterStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster statistics latency raw
func (m *ClusterStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster statistics latency raw based on the context it is used
func (m *ClusterStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res ClusterStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterStatisticsThroughputRaw Throughput bytes observed at the storage object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model ClusterStatisticsThroughputRaw
type ClusterStatisticsThroughputRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this cluster statistics throughput raw
func (m *ClusterStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster statistics throughput raw based on the context it is used
func (m *ClusterStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res ClusterStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterTimezone Provides the cluster-wide time zone information that localizes time found on messages displayed on each node's:
// * console messages;
// * logging to internal ONTAP log files; and
// * localized REST API full ISO-8601 date, time, and time zone format information.
// Machine-to-machine interfaces, such as file access protocols (NFS, CIFS), block access protocols (SAN), and other protocols
// such as Manage ONTAP (ONTAPI), use second or subsecond time values that are based on world time or UTC.
//
//
// swagger:model ClusterTimezone
type ClusterTimezone struct {

	// The ONTAP time zone name or identification in either IANA time zone format "Area/Location", or an ONTAP traditional time zone.
	// </br>
	// The initial first node in cluster setting for time zone is "Etc/UTC".
	// "Etc/UTC" is the IANA timezone "Area/Location" specifier for
	// Coordinated Universal Time (UTC), which is an offset of 0.
	// ### IANA time zone format
	// The IANA time zone, formatted as "Area/Location", is based on geographic areas that have had the same time zone offset for many years.
	// </br>
	// "Location" represents a compound name using additional forward slashes.
	// </br>
	// An example of the "Area/Location" time zone is "America/New_York" and represents most of the United States Eastern Time Zone.
	// Examples of "Area/Location" with "Location" as a compound name are "America/Argentina/Buenos_Aires" and "America/Indiana/Indianapolis".
	// ### ONTAP traditional time zone
	// Examples of the traditional time zones are "EST5EDT" for the United States Eastern Time Zone and "CET" for Central European Time Zone.
	//
	// Example: America/New_York
	Name string `json:"name,omitempty"`
}

// Validate validates this cluster timezone
func (m *ClusterTimezone) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cluster timezone based on context it is used
func (m *ClusterTimezone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterTimezone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterTimezone) UnmarshalBinary(b []byte) error {
	var res ClusterTimezone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterVersion This returns the cluster version information.  When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.
//
// swagger:model ClusterVersion
type ClusterVersion struct {

	// The full cluster version string.
	// Example: NetApp Release 9.4.0: Sun Nov 05 18:20:57 UTC 2017
	// Read Only: true
	Full string `json:"full,omitempty"`

	// The generation portion of the version.
	// Example: 9
	// Read Only: true
	Generation int64 `json:"generation,omitempty"`

	// The major portion of the version.
	// Example: 4
	// Read Only: true
	Major int64 `json:"major,omitempty"`

	// The minor portion of the version.
	// Example: 0
	// Read Only: true
	Minor int64 `json:"minor,omitempty"`
}

// Validate validates this cluster version
func (m *ClusterVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cluster version based on the context it is used
func (m *ClusterVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMajor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterVersion) contextValidateFull(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"full", "body", string(m.Full)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVersion) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVersion) contextValidateMajor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"major", "body", int64(m.Major)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVersion) contextValidateMinor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"minor", "body", int64(m.Minor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterVersion) UnmarshalBinary(b []byte) error {
	var res ClusterVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SnapmirrorTransfer SnapMirror transfer information
//
// swagger:model snapmirror_transfer
type SnapmirrorTransfer struct {

	// links
	Links *SnapmirrorTransferLinks `json:"_links,omitempty"`

	// Bytes transferred
	// Read Only: true
	BytesTransferred int64 `json:"bytes_transferred,omitempty"`

	// Amount of data transferred in bytes as recorded in the restart checkpoint.
	// Read Only: true
	CheckpointSize int64 `json:"checkpoint_size,omitempty"`

	// This is supported for transfer of restore relationship only. This specifies the list of files or LUNs to be restored. Can contain up to eight files or LUNs.
	Files []*SnapmirrorTransferFilesItems0 `json:"files,omitempty"`

	// relationship
	Relationship *SnapmirrorTransferRelationship `json:"relationship,omitempty"`

	// Name of Snapshot copy being transferred.
	// Read Only: true
	Snapshot string `json:"snapshot,omitempty"`

	// Specifies the Snapshot copy on the source to be transferred to the destination.
	SourceSnapshot string `json:"source_snapshot,omitempty"`

	// Status of the transfer. Set PATCH state to "aborted" to abort the transfer. Set PATCH state to "hard_aborted" to abort the transfer and discard the restart checkpoint.
	// Enum: [aborted failed hard_aborted queued success transferring]
	State string `json:"state,omitempty"`

	// This is supported for transfer of restore relationship only. Set this property to "false" to turn off storage efficiency for data transferred over the wire and written to the destination.
	StorageEfficiencyEnabled *bool `json:"storage_efficiency_enabled,omitempty"`

	// Throttle in KB/s. Defaults to throttle setting of the associated SnapMirror policy if set, or 0, which is interpreted as unlimited.
	Throttle int64 `json:"throttle,omitempty"`

	// uuid
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`
}

// Validate validates this snapmirror transfer
func (m *SnapmirrorTransfer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelationship(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapmirrorTransfer) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *SnapmirrorTransfer) validateFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.Files) { // not required
		return nil
	}

	for i := 0; i < len(m.Files); i++ {
		if swag.IsZero(m.Files[i]) { // not required
			continue
		}

		if m.Files[i] != nil {
			if err := m.Files[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SnapmirrorTransfer) validateRelationship(formats strfmt.Registry) error {
	if swag.IsZero(m.Relationship) { // not required
		return nil
	}

	if m.Relationship != nil {
		if err := m.Relationship.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationship")
			}
			return err
		}
	}

	return nil
}

var snapmirrorTransferTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aborted","failed","hard_aborted","queued","success","transferring"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		snapmirrorTransferTypeStatePropEnum = append(snapmirrorTransferTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// snapmirror_transfer
	// SnapmirrorTransfer
	// state
	// State
	// aborted
	// END DEBUGGING
	// SnapmirrorTransferStateAborted captures enum value "aborted"
	SnapmirrorTransferStateAborted string = "aborted"

	// BEGIN DEBUGGING
	// snapmirror_transfer
	// SnapmirrorTransfer
	// state
	// State
	// failed
	// END DEBUGGING
	// SnapmirrorTransferStateFailed captures enum value "failed"
	SnapmirrorTransferStateFailed string = "failed"

	// BEGIN DEBUGGING
	// snapmirror_transfer
	// SnapmirrorTransfer
	// state
	// State
	// hard_aborted
	// END DEBUGGING
	// SnapmirrorTransferStateHardAborted captures enum value "hard_aborted"
	SnapmirrorTransferStateHardAborted string = "hard_aborted"

	// BEGIN DEBUGGING
	// snapmirror_transfer
	// SnapmirrorTransfer
	// state
	// State
	// queued
	// END DEBUGGING
	// SnapmirrorTransferStateQueued captures enum value "queued"
	SnapmirrorTransferStateQueued string = "queued"

	// BEGIN DEBUGGING
	// snapmirror_transfer
	// SnapmirrorTransfer
	// state
	// State
	// success
	// END DEBUGGING
	// SnapmirrorTransferStateSuccess captures enum value "success"
	SnapmirrorTransferStateSuccess string = "success"

	// BEGIN DEBUGGING
	// snapmirror_transfer
	// SnapmirrorTransfer
	// state
	// State
	// transferring
	// END DEBUGGING
	// SnapmirrorTransferStateTransferring captures enum value "transferring"
	SnapmirrorTransferStateTransferring string = "transferring"
)

// prop value enum
func (m *SnapmirrorTransfer) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, snapmirrorTransferTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SnapmirrorTransfer) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *SnapmirrorTransfer) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this snapmirror transfer based on the context it is used
func (m *SnapmirrorTransfer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBytesTransferred(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCheckpointSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRelationship(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapmirrorTransfer) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *SnapmirrorTransfer) contextValidateBytesTransferred(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "bytes_transferred", "body", int64(m.BytesTransferred)); err != nil {
		return err
	}

	return nil
}

func (m *SnapmirrorTransfer) contextValidateCheckpointSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "checkpoint_size", "body", int64(m.CheckpointSize)); err != nil {
		return err
	}

	return nil
}

func (m *SnapmirrorTransfer) contextValidateFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Files); i++ {

		if m.Files[i] != nil {
			if err := m.Files[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SnapmirrorTransfer) contextValidateRelationship(ctx context.Context, formats strfmt.Registry) error {

	if m.Relationship != nil {
		if err := m.Relationship.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationship")
			}
			return err
		}
	}

	return nil
}

func (m *SnapmirrorTransfer) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot", "body", string(m.Snapshot)); err != nil {
		return err
	}

	return nil
}

func (m *SnapmirrorTransfer) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SnapmirrorTransfer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapmirrorTransfer) UnmarshalBinary(b []byte) error {
	var res SnapmirrorTransfer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SnapmirrorTransferFilesItems0 Specifies a file or LUN consisting of a source_path and an optional destination_path. If not specified, the destination_path is the same as the source_path.
//
// swagger:model SnapmirrorTransferFilesItems0
type SnapmirrorTransferFilesItems0 struct {

	// destination path
	// Example: /dirb/file2
	DestinationPath string `json:"destination_path,omitempty"`

	// source path
	// Example: /dira/file1
	SourcePath string `json:"source_path,omitempty"`
}

// Validate validates this snapmirror transfer files items0
func (m *SnapmirrorTransferFilesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this snapmirror transfer files items0 based on context it is used
func (m *SnapmirrorTransferFilesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SnapmirrorTransferFilesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapmirrorTransferFilesItems0) UnmarshalBinary(b []byte) error {
	var res SnapmirrorTransferFilesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SnapmirrorTransferLinks snapmirror transfer links
//
// swagger:model SnapmirrorTransferLinks
type SnapmirrorTransferLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this snapmirror transfer links
func (m *SnapmirrorTransferLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapmirrorTransferLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this snapmirror transfer links based on the context it is used
func (m *SnapmirrorTransferLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapmirrorTransferLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SnapmirrorTransferLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapmirrorTransferLinks) UnmarshalBinary(b []byte) error {
	var res SnapmirrorTransferLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SnapmirrorTransferRelationship snapmirror transfer relationship
//
// swagger:model SnapmirrorTransferRelationship
type SnapmirrorTransferRelationship struct {

	// destination
	Destination *SnapmirrorEndpoint `json:"destination,omitempty"`

	// Is the relationship for restore?
	Restore bool `json:"restore,omitempty"`

	// uuid
	// Example: d2d7ceea-ab52-11e8-855e-00505682a4c7
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`
}

// Validate validates this snapmirror transfer relationship
func (m *SnapmirrorTransferRelationship) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapmirrorTransferRelationship) validateDestination(formats strfmt.Registry) error {
	if swag.IsZero(m.Destination) { // not required
		return nil
	}

	if m.Destination != nil {
		if err := m.Destination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationship" + "." + "destination")
			}
			return err
		}
	}

	return nil
}

func (m *SnapmirrorTransferRelationship) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("relationship"+"."+"uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this snapmirror transfer relationship based on the context it is used
func (m *SnapmirrorTransferRelationship) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapmirrorTransferRelationship) contextValidateDestination(ctx context.Context, formats strfmt.Registry) error {

	if m.Destination != nil {
		if err := m.Destination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationship" + "." + "destination")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SnapmirrorTransferRelationship) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapmirrorTransferRelationship) UnmarshalBinary(b []byte) error {
	var res SnapmirrorTransferRelationship
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

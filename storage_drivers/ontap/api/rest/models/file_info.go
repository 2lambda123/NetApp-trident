// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FileInfo Information about a single file.
//
// swagger:model file_info
type FileInfo struct {

	// links
	Links *FileInfoLinks `json:"_links,omitempty"`

	// Last access time of the file in date-time format.
	// Example: 2019-06-12 15:00:16
	// Format: date-time
	AccessedTime *strfmt.DateTime `json:"accessed_time,omitempty"`

	// The actual number of bytes used on disk by this file.
	// Example: 4096
	BytesUsed int64 `json:"bytes_used,omitempty"`

	// Last time data or attributes changed on the file in date-time format.
	// Example: 2019-06-12 15:00:16
	// Format: date-time
	ChangedTime *strfmt.DateTime `json:"changed_time,omitempty"`

	// Creation time of the file in date-time format.
	// Example: 2019-06-12 15:00:16
	// Format: date-time
	CreationTime *strfmt.DateTime `json:"creation_time,omitempty"`

	// The integer ID of the group of the file owner.
	// Example: 30
	GroupID int64 `json:"group_id,omitempty"`

	// The number of hard links to the file.
	// Example: 1
	HardLinksCount int64 `json:"hard_links_count,omitempty"`

	// Inode generation number.
	// Example: 214753547
	InodeGeneration int64 `json:"inode_generation,omitempty"`

	// The file inode number.
	// Example: 1695
	InodeNumber int64 `json:"inode_number,omitempty"`

	// Specifies whether or not a directory is empty. A directory is considered empty if it only contains entries for "." and "..". This element is present if the file is a directory. In some special error cases, such as when the volume goes offline or when the directory is moved while retrieving this info, this field might not get set.
	// Example: false
	IsEmpty bool `json:"is_empty,omitempty"`

	// Returns "true" if the directory is a junction.
	// Example: false
	IsJunction bool `json:"is_junction,omitempty"`

	// Returns true if the file is vm-aligned. A vm-aligned file is a file that is initially padded with zero-filled data so that its actual data starts at an offset other then zero. This is done in a VM environment so that read/write operations to this file are aligned to WAFL's 4k block boundary. The amount by which the start offset is adjusted depends on the vm-align setting of the hosting volume.
	// Example: false
	IsVMAligned bool `json:"is_vm_aligned,omitempty"`

	// Last data modification time of the file in date-time format.
	// Example: 2019-06-12 15:00:16
	// Format: date-time
	ModifiedTime *strfmt.DateTime `json:"modified_time,omitempty"`

	// Name of the file.
	// Example: test_file
	Name string `json:"name,omitempty"`

	// The integer ID of the file owner.
	// Example: 54738
	OwnerID int64 `json:"owner_id,omitempty"`

	// Path of the file.
	// Example: d1/d2/d3
	Path string `json:"path,omitempty"`

	// The size of the file, in bytes.
	// Example: 200
	Size int64 `json:"size,omitempty"`

	// Type of the file.
	// Example: file
	// Enum: [file directory blockdev chardev symlink socket fifo stream lun]
	Type string `json:"type,omitempty"`

	// UNIX permissions to be viewed as an octal number. It consists of 4 digits derived by adding up bits 4 (read), 2 (write) and 1 (execute). The first digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. The second digit selects permission for the owner of the file; the third selects permissions for other users in the same group; the fourth for other users not in the group.
	// Example: 493
	UnixPermissions int64 `json:"unix_permissions,omitempty"`

	// volume
	Volume *FileInfoVolume `json:"volume,omitempty"`
}

// Validate validates this file info
func (m *FileInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChangedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfo) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *FileInfo) validateAccessedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("accessed_time", "body", "date-time", m.AccessedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FileInfo) validateChangedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ChangedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("changed_time", "body", "date-time", m.ChangedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FileInfo) validateCreationTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreationTime) { // not required
		return nil
	}

	if err := validate.FormatOf("creation_time", "body", "date-time", m.CreationTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FileInfo) validateModifiedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("modified_time", "body", "date-time", m.ModifiedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var fileInfoTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["file","directory","blockdev","chardev","symlink","socket","fifo","stream","lun"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fileInfoTypeTypePropEnum = append(fileInfoTypeTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// file
	// END RIPPY DEBUGGING
	// FileInfoTypeFile captures enum value "file"
	FileInfoTypeFile string = "file"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// directory
	// END RIPPY DEBUGGING
	// FileInfoTypeDirectory captures enum value "directory"
	FileInfoTypeDirectory string = "directory"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// blockdev
	// END RIPPY DEBUGGING
	// FileInfoTypeBlockdev captures enum value "blockdev"
	FileInfoTypeBlockdev string = "blockdev"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// chardev
	// END RIPPY DEBUGGING
	// FileInfoTypeChardev captures enum value "chardev"
	FileInfoTypeChardev string = "chardev"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// symlink
	// END RIPPY DEBUGGING
	// FileInfoTypeSymlink captures enum value "symlink"
	FileInfoTypeSymlink string = "symlink"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// socket
	// END RIPPY DEBUGGING
	// FileInfoTypeSocket captures enum value "socket"
	FileInfoTypeSocket string = "socket"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// fifo
	// END RIPPY DEBUGGING
	// FileInfoTypeFifo captures enum value "fifo"
	FileInfoTypeFifo string = "fifo"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// stream
	// END RIPPY DEBUGGING
	// FileInfoTypeStream captures enum value "stream"
	FileInfoTypeStream string = "stream"

	// BEGIN RIPPY DEBUGGING
	// file_info
	// FileInfo
	// type
	// Type
	// lun
	// END RIPPY DEBUGGING
	// FileInfoTypeLun captures enum value "lun"
	FileInfoTypeLun string = "lun"
)

// prop value enum
func (m *FileInfo) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fileInfoTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FileInfo) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *FileInfo) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file info based on the context it is used
func (m *FileInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfo) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *FileInfo) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileInfo) UnmarshalBinary(b []byte) error {
	var res FileInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileInfoLinks file info links
//
// swagger:model FileInfoLinks
type FileInfoLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file info links
func (m *FileInfoLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfoLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file info links based on the context it is used
func (m *FileInfoLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfoLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileInfoLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileInfoLinks) UnmarshalBinary(b []byte) error {
	var res FileInfoLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileInfoVolume file info volume
//
// swagger:model FileInfoVolume
type FileInfoVolume struct {

	// links
	Links *FileInfoVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this file info volume
func (m *FileInfoVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfoVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file info volume based on the context it is used
func (m *FileInfoVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfoVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileInfoVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileInfoVolume) UnmarshalBinary(b []byte) error {
	var res FileInfoVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileInfoVolumeLinks file info volume links
//
// swagger:model FileInfoVolumeLinks
type FileInfoVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file info volume links
func (m *FileInfoVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfoVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file info volume links based on the context it is used
func (m *FileInfoVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfoVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileInfoVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileInfoVolumeLinks) UnmarshalBinary(b []byte) error {
	var res FileInfoVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

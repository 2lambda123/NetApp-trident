// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SecurityConfig security config
//
// swagger:model security_config
type SecurityConfig struct {

	// links
	Links *SecurityConfigLinks `json:"_links,omitempty"`

	// fips
	Fips *SecurityConfigFips `json:"fips,omitempty"`

	// management protocols
	ManagementProtocols *SecurityConfigManagementProtocols `json:"management_protocols,omitempty"`

	// onboard key manager configurable status
	OnboardKeyManagerConfigurableStatus *SecurityConfigOnboardKeyManagerConfigurableStatus `json:"onboard_key_manager_configurable_status,omitempty"`

	// software data encryption
	SoftwareDataEncryption *SecurityConfigSoftwareDataEncryption `json:"software_data_encryption,omitempty"`

	// tls
	TLS *SecurityConfigTLS `json:"tls,omitempty"`
}

// Validate validates this security config
func (m *SecurityConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFips(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementProtocols(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnboardKeyManagerConfigurableStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareDataEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTLS(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityConfig) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) validateFips(formats strfmt.Registry) error {
	if swag.IsZero(m.Fips) { // not required
		return nil
	}

	if m.Fips != nil {
		if err := m.Fips.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fips")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) validateManagementProtocols(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementProtocols) { // not required
		return nil
	}

	if m.ManagementProtocols != nil {
		if err := m.ManagementProtocols.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_protocols")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) validateOnboardKeyManagerConfigurableStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.OnboardKeyManagerConfigurableStatus) { // not required
		return nil
	}

	if m.OnboardKeyManagerConfigurableStatus != nil {
		if err := m.OnboardKeyManagerConfigurableStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("onboard_key_manager_configurable_status")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) validateSoftwareDataEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareDataEncryption) { // not required
		return nil
	}

	if m.SoftwareDataEncryption != nil {
		if err := m.SoftwareDataEncryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_data_encryption")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) validateTLS(formats strfmt.Registry) error {
	if swag.IsZero(m.TLS) { // not required
		return nil
	}

	if m.TLS != nil {
		if err := m.TLS.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tls")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security config based on the context it is used
func (m *SecurityConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFips(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementProtocols(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOnboardKeyManagerConfigurableStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareDataEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTLS(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityConfig) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) contextValidateFips(ctx context.Context, formats strfmt.Registry) error {

	if m.Fips != nil {
		if err := m.Fips.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fips")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) contextValidateManagementProtocols(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementProtocols != nil {
		if err := m.ManagementProtocols.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_protocols")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) contextValidateOnboardKeyManagerConfigurableStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.OnboardKeyManagerConfigurableStatus != nil {
		if err := m.OnboardKeyManagerConfigurableStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("onboard_key_manager_configurable_status")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) contextValidateSoftwareDataEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.SoftwareDataEncryption != nil {
		if err := m.SoftwareDataEncryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_data_encryption")
			}
			return err
		}
	}

	return nil
}

func (m *SecurityConfig) contextValidateTLS(ctx context.Context, formats strfmt.Registry) error {

	if m.TLS != nil {
		if err := m.TLS.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tls")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityConfig) UnmarshalBinary(b []byte) error {
	var res SecurityConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityConfigFips Cluster-wide Federal Information Processing Standards (FIPS) mode information.
//
//
// swagger:model SecurityConfigFips
type SecurityConfigFips struct {

	// Indicates whether or not the software FIPS mode is enabled on the cluster. Our FIPS compliance involves configuring the use of only approved algorithms in applicable contexts (for example TLS), as well as the use of formally validated cryptographic module software implementations, where applicable. The US government documents concerning FIPS 140-2 outline the relevant security policies in detail.
	Enabled bool `json:"enabled,omitempty"`
}

// Validate validates this security config fips
func (m *SecurityConfigFips) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this security config fips based on context it is used
func (m *SecurityConfigFips) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SecurityConfigFips) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityConfigFips) UnmarshalBinary(b []byte) error {
	var res SecurityConfigFips
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityConfigLinks security config links
//
// swagger:model SecurityConfigLinks
type SecurityConfigLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this security config links
func (m *SecurityConfigLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityConfigLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this security config links based on the context it is used
func (m *SecurityConfigLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SecurityConfigLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SecurityConfigLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityConfigLinks) UnmarshalBinary(b []byte) error {
	var res SecurityConfigLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityConfigManagementProtocols Cluster-wide security protocols related information.
//
//
// swagger:model SecurityConfigManagementProtocols
type SecurityConfigManagementProtocols struct {

	// Indicates whether or not security protocol rsh is enabled on the cluster.
	RshEnabled bool `json:"rsh_enabled,omitempty"`

	// Indicates whether or not security protocol telnet is enabled on the cluster.
	TelnetEnabled bool `json:"telnet_enabled,omitempty"`
}

// Validate validates this security config management protocols
func (m *SecurityConfigManagementProtocols) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this security config management protocols based on context it is used
func (m *SecurityConfigManagementProtocols) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SecurityConfigManagementProtocols) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityConfigManagementProtocols) UnmarshalBinary(b []byte) error {
	var res SecurityConfigManagementProtocols
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityConfigOnboardKeyManagerConfigurableStatus Indicates whether the Onboard Key Manager can be configured in the cluster.
//
//
// swagger:model SecurityConfigOnboardKeyManagerConfigurableStatus
type SecurityConfigOnboardKeyManagerConfigurableStatus struct {

	// Code corresponding to the status message. Returns a 0 if the Onboard Key Manager can be configured in the cluster.
	// Example: 65537300
	Code int64 `json:"code,omitempty"`

	// Reason that Onboard Key Manager cannot be configured in the cluster.
	// Example: No platform support for volume encryption in following nodes - node1, node2.
	Message string `json:"message,omitempty"`

	// Set to true if the Onboard Key Manager can be configured in the cluster.
	Supported bool `json:"supported,omitempty"`
}

// Validate validates this security config onboard key manager configurable status
func (m *SecurityConfigOnboardKeyManagerConfigurableStatus) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this security config onboard key manager configurable status based on context it is used
func (m *SecurityConfigOnboardKeyManagerConfigurableStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SecurityConfigOnboardKeyManagerConfigurableStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityConfigOnboardKeyManagerConfigurableStatus) UnmarshalBinary(b []byte) error {
	var res SecurityConfigOnboardKeyManagerConfigurableStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityConfigSoftwareDataEncryption Cluster-wide software data encryption related information.
//
//
// swagger:model SecurityConfigSoftwareDataEncryption
type SecurityConfigSoftwareDataEncryption struct {

	// Indicates whether or not software encryption conversion is enabled on the cluster. A PATCH request initiates the conversion of all non-encrypted metadata volumes in the cluster to encrypted metadata volumes and all non-NAE aggregates to NAE aggregates. For the PATCH request to start, the cluster must have either an Onboard or an external key manager set up and the aggregates should either be empty or have only metadata volumes. No data volumes should be present in any of the aggregates in the cluster. For MetroCluster configurations, a PATCH request enables conversion on all the aggregates and metadata volumes of both local and remote clusters and is not allowed when the MetroCluster is in switchover state.
	ConversionEnabled bool `json:"conversion_enabled,omitempty"`

	// Indicates whether or not default software data at rest encryption is disabled on the cluster.
	DisabledByDefault bool `json:"disabled_by_default,omitempty"`
}

// Validate validates this security config software data encryption
func (m *SecurityConfigSoftwareDataEncryption) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this security config software data encryption based on context it is used
func (m *SecurityConfigSoftwareDataEncryption) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SecurityConfigSoftwareDataEncryption) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityConfigSoftwareDataEncryption) UnmarshalBinary(b []byte) error {
	var res SecurityConfigSoftwareDataEncryption
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SecurityConfigTLS Cluster-wide Transport Layer Security (TLS) configuration information
//
//
// swagger:model SecurityConfigTLS
type SecurityConfigTLS struct {

	// Names a cipher suite that the system can select during TLS handshakes. A list of available options can be found on the Internet Assigned Number Authority (IANA) website.
	CipherSuites []string `json:"cipher_suites,omitempty"`

	// Names a TLS protocol version that the system can select during TLS handshakes. The use of SSLv3 or TLSv1 is discouraged.
	ProtocolVersions []string `json:"protocol_versions,omitempty"`
}

// Validate validates this security config TLS
func (m *SecurityConfigTLS) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProtocolVersions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var securityConfigTlsProtocolVersionsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SSLv3","TLSv1","TLSv1.1","TLSv1.2","TLSv1.3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		securityConfigTlsProtocolVersionsItemsEnum = append(securityConfigTlsProtocolVersionsItemsEnum, v)
	}
}

func (m *SecurityConfigTLS) validateProtocolVersionsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, securityConfigTlsProtocolVersionsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SecurityConfigTLS) validateProtocolVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtocolVersions) { // not required
		return nil
	}

	for i := 0; i < len(m.ProtocolVersions); i++ {

		// value enum
		if err := m.validateProtocolVersionsItemsEnum("tls"+"."+"protocol_versions"+"."+strconv.Itoa(i), "body", m.ProtocolVersions[i]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validates this security config TLS based on context it is used
func (m *SecurityConfigTLS) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SecurityConfigTLS) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SecurityConfigTLS) UnmarshalBinary(b []byte) error {
	var res SecurityConfigTLS
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

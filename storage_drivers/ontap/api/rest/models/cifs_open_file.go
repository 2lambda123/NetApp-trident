// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CifsOpenFile Manage opened files over CIFS.
//
// swagger:model cifs_open_file
type CifsOpenFile struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// connection
	Connection *CifsOpenFileConnection `json:"connection,omitempty"`

	// The type of continuous availability protection provided to the file.
	// Opened files are continuously available if there are opened through a SMB3 client through a share with "continuously_avaliable" set to yes.
	// These open files are capable of non-disruptively recovering from take over and giveback as well as general aggregate relocation.
	// - no: the open file is not continuously available.
	// - yes: the open file is continuously available.
	//
	// Example: no
	// Read Only: true
	// Enum: [no yes]
	ContinuouslyAvailable string `json:"continuously_available,omitempty"`

	// The unique identifier for the opened file.
	// Example: 17
	Identifier int64 `json:"identifier,omitempty"`

	// node
	// Required: true
	Node *CifsOpenFileNode `json:"node"`

	// Open mode corresponding to the opened file
	// - r: Opened for read
	// - w: Opened for write
	// - d: Opened for Delete
	//
	// Example: r
	// Read Only: true
	// Enum: [r w d]
	OpenMode string `json:"open_mode,omitempty"`

	// Path from CIFS share.
	// Example: sub1\\sub2\\f4
	// Read Only: true
	Path string `json:"path,omitempty"`

	// The number of range locks granted on the file.
	// Example: 4
	// Read Only: true
	RangeLocksCount int64 `json:"range_locks_count,omitempty"`

	// session
	Session *CifsOpenFileSession `json:"session,omitempty"`

	// share
	Share *CifsOpenFileShare `json:"share,omitempty"`

	// svm
	// Required: true
	Svm *CifsOpenFileSvm `json:"svm"`

	// The type of opened file.
	// The file can be a regular file, directory, a symbolic link to an existing file/directory, or an alternate data stream.
	//
	// Example: regular
	// Read Only: true
	// Enum: [directory regular stream symlink]
	Type string `json:"type,omitempty"`

	// volume
	Volume *CifsOpenFileVolume `json:"volume,omitempty"`
}

// Validate validates this cifs open file
func (m *CifsOpenFile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContinuouslyAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSession(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShare(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFile) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) validateConnection(formats strfmt.Registry) error {
	if swag.IsZero(m.Connection) { // not required
		return nil
	}

	if m.Connection != nil {
		if err := m.Connection.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

var cifsOpenFileTypeContinuouslyAvailablePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["no","yes"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsOpenFileTypeContinuouslyAvailablePropEnum = append(cifsOpenFileTypeContinuouslyAvailablePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// continuously_available
	// ContinuouslyAvailable
	// no
	// END DEBUGGING
	// CifsOpenFileContinuouslyAvailableNo captures enum value "no"
	CifsOpenFileContinuouslyAvailableNo string = "no"

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// continuously_available
	// ContinuouslyAvailable
	// yes
	// END DEBUGGING
	// CifsOpenFileContinuouslyAvailableYes captures enum value "yes"
	CifsOpenFileContinuouslyAvailableYes string = "yes"
)

// prop value enum
func (m *CifsOpenFile) validateContinuouslyAvailableEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsOpenFileTypeContinuouslyAvailablePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsOpenFile) validateContinuouslyAvailable(formats strfmt.Registry) error {
	if swag.IsZero(m.ContinuouslyAvailable) { // not required
		return nil
	}

	// value enum
	if err := m.validateContinuouslyAvailableEnum("continuously_available", "body", m.ContinuouslyAvailable); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) validateNode(formats strfmt.Registry) error {

	if err := validate.Required("node", "body", m.Node); err != nil {
		return err
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

var cifsOpenFileTypeOpenModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["r","w","d"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsOpenFileTypeOpenModePropEnum = append(cifsOpenFileTypeOpenModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// open_mode
	// OpenMode
	// r
	// END DEBUGGING
	// CifsOpenFileOpenModeR captures enum value "r"
	CifsOpenFileOpenModeR string = "r"

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// open_mode
	// OpenMode
	// w
	// END DEBUGGING
	// CifsOpenFileOpenModeW captures enum value "w"
	CifsOpenFileOpenModeW string = "w"

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// open_mode
	// OpenMode
	// d
	// END DEBUGGING
	// CifsOpenFileOpenModeD captures enum value "d"
	CifsOpenFileOpenModeD string = "d"
)

// prop value enum
func (m *CifsOpenFile) validateOpenModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsOpenFileTypeOpenModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsOpenFile) validateOpenMode(formats strfmt.Registry) error {
	if swag.IsZero(m.OpenMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateOpenModeEnum("open_mode", "body", m.OpenMode); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) validateSession(formats strfmt.Registry) error {
	if swag.IsZero(m.Session) { // not required
		return nil
	}

	if m.Session != nil {
		if err := m.Session.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("session")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) validateShare(formats strfmt.Registry) error {
	if swag.IsZero(m.Share) { // not required
		return nil
	}

	if m.Share != nil {
		if err := m.Share.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("share")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) validateSvm(formats strfmt.Registry) error {

	if err := validate.Required("svm", "body", m.Svm); err != nil {
		return err
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

var cifsOpenFileTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["directory","regular","stream","symlink"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsOpenFileTypeTypePropEnum = append(cifsOpenFileTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// type
	// Type
	// directory
	// END DEBUGGING
	// CifsOpenFileTypeDirectory captures enum value "directory"
	CifsOpenFileTypeDirectory string = "directory"

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// type
	// Type
	// regular
	// END DEBUGGING
	// CifsOpenFileTypeRegular captures enum value "regular"
	CifsOpenFileTypeRegular string = "regular"

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// type
	// Type
	// stream
	// END DEBUGGING
	// CifsOpenFileTypeStream captures enum value "stream"
	CifsOpenFileTypeStream string = "stream"

	// BEGIN DEBUGGING
	// cifs_open_file
	// CifsOpenFile
	// type
	// Type
	// symlink
	// END DEBUGGING
	// CifsOpenFileTypeSymlink captures enum value "symlink"
	CifsOpenFileTypeSymlink string = "symlink"
)

// prop value enum
func (m *CifsOpenFile) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsOpenFileTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsOpenFile) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs open file based on the context it is used
func (m *CifsOpenFile) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContinuouslyAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpenMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePath(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRangeLocksCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSession(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShare(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFile) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) contextValidateConnection(ctx context.Context, formats strfmt.Registry) error {

	if m.Connection != nil {
		if err := m.Connection.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) contextValidateContinuouslyAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "continuously_available", "body", string(m.ContinuouslyAvailable)); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) contextValidateOpenMode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "open_mode", "body", string(m.OpenMode)); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) contextValidatePath(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "path", "body", string(m.Path)); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) contextValidateRangeLocksCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "range_locks_count", "body", int64(m.RangeLocksCount)); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) contextValidateSession(ctx context.Context, formats strfmt.Registry) error {

	if m.Session != nil {
		if err := m.Session.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("session")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) contextValidateShare(ctx context.Context, formats strfmt.Registry) error {

	if m.Share != nil {
		if err := m.Share.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("share")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *CifsOpenFile) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFile) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFile) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFile) UnmarshalBinary(b []byte) error {
	var res CifsOpenFile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileConnection cifs open file connection
//
// swagger:model CifsOpenFileConnection
type CifsOpenFileConnection struct {

	// The number of CIFS connections associated with the CIFS session.
	// Example: 3
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// The connection that is used to open the file.
	// Example: 356756
	Identifier int64 `json:"identifier,omitempty"`
}

// Validate validates this cifs open file connection
func (m *CifsOpenFileConnection) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cifs open file connection based on the context it is used
func (m *CifsOpenFileConnection) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileConnection) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connection"+"."+"count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileConnection) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileConnection) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileConnection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileNode cifs open file node
//
// swagger:model CifsOpenFileNode
type CifsOpenFileNode struct {

	// links
	Links *CifsOpenFileNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cifs open file node
func (m *CifsOpenFileNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs open file node based on the context it is used
func (m *CifsOpenFileNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileNode) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileNodeLinks cifs open file node links
//
// swagger:model CifsOpenFileNodeLinks
type CifsOpenFileNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cifs open file node links
func (m *CifsOpenFileNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs open file node links based on the context it is used
func (m *CifsOpenFileNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileNodeLinks) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileSession cifs open file session
//
// swagger:model CifsOpenFileSession
type CifsOpenFileSession struct {

	// Session under which file is opened.
	// Example: 8966666858094658000
	Identifier int64 `json:"identifier,omitempty"`
}

// Validate validates this cifs open file session
func (m *CifsOpenFileSession) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this cifs open file session based on the context it is used
func (m *CifsOpenFileSession) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileSession) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileSession) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileSession
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileShare cifs open file share
//
// swagger:model CifsOpenFileShare
type CifsOpenFileShare struct {

	// The share mode used to open the file.
	// The share mode can be a combination of:
	//   - r: read mode
	//   - w: write mode
	//   - d: delete
	//
	// Example: r
	// Read Only: true
	// Enum: [r w d]
	Mode string `json:"mode,omitempty"`

	// CIFS share name where the file resides.
	// Example: share1
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this cifs open file share
func (m *CifsOpenFileShare) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var cifsOpenFileShareTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["r","w","d"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cifsOpenFileShareTypeModePropEnum = append(cifsOpenFileShareTypeModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// CifsOpenFileShare
	// CifsOpenFileShare
	// mode
	// Mode
	// r
	// END DEBUGGING
	// CifsOpenFileShareModeR captures enum value "r"
	CifsOpenFileShareModeR string = "r"

	// BEGIN DEBUGGING
	// CifsOpenFileShare
	// CifsOpenFileShare
	// mode
	// Mode
	// w
	// END DEBUGGING
	// CifsOpenFileShareModeW captures enum value "w"
	CifsOpenFileShareModeW string = "w"

	// BEGIN DEBUGGING
	// CifsOpenFileShare
	// CifsOpenFileShare
	// mode
	// Mode
	// d
	// END DEBUGGING
	// CifsOpenFileShareModeD captures enum value "d"
	CifsOpenFileShareModeD string = "d"
)

// prop value enum
func (m *CifsOpenFileShare) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cifsOpenFileShareTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CifsOpenFileShare) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("share"+"."+"mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cifs open file share based on the context it is used
func (m *CifsOpenFileShare) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileShare) contextValidateMode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "share"+"."+"mode", "body", string(m.Mode)); err != nil {
		return err
	}

	return nil
}

func (m *CifsOpenFileShare) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "share"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileShare) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileShare) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileShare
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileSvm cifs open file svm
//
// swagger:model CifsOpenFileSvm
type CifsOpenFileSvm struct {

	// links
	Links *CifsOpenFileSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cifs open file svm
func (m *CifsOpenFileSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs open file svm based on the context it is used
func (m *CifsOpenFileSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileSvm) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileSvmLinks cifs open file svm links
//
// swagger:model CifsOpenFileSvmLinks
type CifsOpenFileSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cifs open file svm links
func (m *CifsOpenFileSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs open file svm links based on the context it is used
func (m *CifsOpenFileSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileSvmLinks) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileVolume cifs open file volume
//
// swagger:model CifsOpenFileVolume
type CifsOpenFileVolume struct {

	// links
	Links *CifsOpenFileVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this cifs open file volume
func (m *CifsOpenFileVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs open file volume based on the context it is used
func (m *CifsOpenFileVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileVolume) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CifsOpenFileVolumeLinks cifs open file volume links
//
// swagger:model CifsOpenFileVolumeLinks
type CifsOpenFileVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this cifs open file volume links
func (m *CifsOpenFileVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cifs open file volume links based on the context it is used
func (m *CifsOpenFileVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CifsOpenFileVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CifsOpenFileVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CifsOpenFileVolumeLinks) UnmarshalBinary(b []byte) error {
	var res CifsOpenFileVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

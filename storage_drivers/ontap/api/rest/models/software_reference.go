// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SoftwareReference software reference
//
// swagger:model software_reference
type SoftwareReference struct {

	// links
	Links *SoftwareReferenceLinks `json:"_links,omitempty"`

	// User triggered action to apply to the install operation
	// Example: pause
	// Enum: [pause cancel resume]
	Action string `json:"action,omitempty"`

	// Elapsed time during the upgrade or validation operation
	// Example: 2140
	// Read Only: true
	ElapsedDuration int64 `json:"elapsed_duration,omitempty"`

	// Estimated time remaining until completion of the upgrade or validation operation.
	// Example: 5220
	// Read Only: true
	EstimatedDuration int64 `json:"estimated_duration,omitempty"`

	// metrocluster
	Metrocluster *SoftwareReferenceMetrocluster `json:"metrocluster,omitempty"`

	// List of nodes and active versions.
	// Read Only: true
	Nodes []*SoftwareNodeReference `json:"nodes,omitempty"`

	// Version being installed on the system.
	// Example: ONTAP_X_1
	// Read Only: true
	PendingVersion string `json:"pending_version,omitempty"`

	// Operational state of the upgrade
	// Example: completed
	// Read Only: true
	// Enum: [in_progress waiting paused_by_user paused_on_error completed canceled failed pause_pending cancel_pending]
	State string `json:"state,omitempty"`

	// Display status details.
	// Read Only: true
	StatusDetails []*SoftwareStatusDetailsReference `json:"status_details,omitempty"`

	// Display update progress details.
	// Read Only: true
	UpdateDetails []*SoftwareUpdateDetailsReference `json:"update_details,omitempty"`

	// List of validation warnings, errors, and advice.
	// Read Only: true
	ValidationResults []*SoftwareValidationReference `json:"validation_results,omitempty"`

	// Version of ONTAP installed and currently active on the system. During PATCH, using the 'validate_only' parameter on the request executes pre-checks, but does not perform the full installation.
	// Example: ONTAP_X
	Version string `json:"version,omitempty"`
}

// Validate validates this software reference
func (m *SoftwareReference) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetrocluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationResults(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SoftwareReference) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

var softwareReferenceTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pause","cancel","resume"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		softwareReferenceTypeActionPropEnum = append(softwareReferenceTypeActionPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// action
	// Action
	// pause
	// END RIPPY DEBUGGING
	// SoftwareReferenceActionPause captures enum value "pause"
	SoftwareReferenceActionPause string = "pause"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// action
	// Action
	// cancel
	// END RIPPY DEBUGGING
	// SoftwareReferenceActionCancel captures enum value "cancel"
	SoftwareReferenceActionCancel string = "cancel"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// action
	// Action
	// resume
	// END RIPPY DEBUGGING
	// SoftwareReferenceActionResume captures enum value "resume"
	SoftwareReferenceActionResume string = "resume"
)

// prop value enum
func (m *SoftwareReference) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, softwareReferenceTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SoftwareReference) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *SoftwareReference) validateMetrocluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Metrocluster) { // not required
		return nil
	}

	if m.Metrocluster != nil {
		if err := m.Metrocluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster")
			}
			return err
		}
	}

	return nil
}

func (m *SoftwareReference) validateNodes(formats strfmt.Registry) error {
	if swag.IsZero(m.Nodes) { // not required
		return nil
	}

	for i := 0; i < len(m.Nodes); i++ {
		if swag.IsZero(m.Nodes[i]) { // not required
			continue
		}

		if m.Nodes[i] != nil {
			if err := m.Nodes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var softwareReferenceTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["in_progress","waiting","paused_by_user","paused_on_error","completed","canceled","failed","pause_pending","cancel_pending"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		softwareReferenceTypeStatePropEnum = append(softwareReferenceTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// in_progress
	// END RIPPY DEBUGGING
	// SoftwareReferenceStateInProgress captures enum value "in_progress"
	SoftwareReferenceStateInProgress string = "in_progress"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// waiting
	// END RIPPY DEBUGGING
	// SoftwareReferenceStateWaiting captures enum value "waiting"
	SoftwareReferenceStateWaiting string = "waiting"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// paused_by_user
	// END RIPPY DEBUGGING
	// SoftwareReferenceStatePausedByUser captures enum value "paused_by_user"
	SoftwareReferenceStatePausedByUser string = "paused_by_user"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// paused_on_error
	// END RIPPY DEBUGGING
	// SoftwareReferenceStatePausedOnError captures enum value "paused_on_error"
	SoftwareReferenceStatePausedOnError string = "paused_on_error"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// completed
	// END RIPPY DEBUGGING
	// SoftwareReferenceStateCompleted captures enum value "completed"
	SoftwareReferenceStateCompleted string = "completed"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// canceled
	// END RIPPY DEBUGGING
	// SoftwareReferenceStateCanceled captures enum value "canceled"
	SoftwareReferenceStateCanceled string = "canceled"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// failed
	// END RIPPY DEBUGGING
	// SoftwareReferenceStateFailed captures enum value "failed"
	SoftwareReferenceStateFailed string = "failed"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// pause_pending
	// END RIPPY DEBUGGING
	// SoftwareReferenceStatePausePending captures enum value "pause_pending"
	SoftwareReferenceStatePausePending string = "pause_pending"

	// BEGIN RIPPY DEBUGGING
	// software_reference
	// SoftwareReference
	// state
	// State
	// cancel_pending
	// END RIPPY DEBUGGING
	// SoftwareReferenceStateCancelPending captures enum value "cancel_pending"
	SoftwareReferenceStateCancelPending string = "cancel_pending"
)

// prop value enum
func (m *SoftwareReference) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, softwareReferenceTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SoftwareReference) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *SoftwareReference) validateStatusDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.StatusDetails); i++ {
		if swag.IsZero(m.StatusDetails[i]) { // not required
			continue
		}

		if m.StatusDetails[i] != nil {
			if err := m.StatusDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("status_details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SoftwareReference) validateUpdateDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdateDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.UpdateDetails); i++ {
		if swag.IsZero(m.UpdateDetails[i]) { // not required
			continue
		}

		if m.UpdateDetails[i] != nil {
			if err := m.UpdateDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("update_details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SoftwareReference) validateValidationResults(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationResults) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationResults); i++ {
		if swag.IsZero(m.ValidationResults[i]) { // not required
			continue
		}

		if m.ValidationResults[i] != nil {
			if err := m.ValidationResults[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validation_results" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this software reference based on the context it is used
func (m *SoftwareReference) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateElapsedDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEstimatedDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetrocluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNodes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePendingVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatusDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidationResults(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SoftwareReference) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *SoftwareReference) contextValidateElapsedDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "elapsed_duration", "body", int64(m.ElapsedDuration)); err != nil {
		return err
	}

	return nil
}

func (m *SoftwareReference) contextValidateEstimatedDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "estimated_duration", "body", int64(m.EstimatedDuration)); err != nil {
		return err
	}

	return nil
}

func (m *SoftwareReference) contextValidateMetrocluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Metrocluster != nil {
		if err := m.Metrocluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster")
			}
			return err
		}
	}

	return nil
}

func (m *SoftwareReference) contextValidateNodes(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "nodes", "body", []*SoftwareNodeReference(m.Nodes)); err != nil {
		return err
	}

	for i := 0; i < len(m.Nodes); i++ {

		if m.Nodes[i] != nil {
			if err := m.Nodes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SoftwareReference) contextValidatePendingVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "pending_version", "body", string(m.PendingVersion)); err != nil {
		return err
	}

	return nil
}

func (m *SoftwareReference) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *SoftwareReference) contextValidateStatusDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status_details", "body", []*SoftwareStatusDetailsReference(m.StatusDetails)); err != nil {
		return err
	}

	for i := 0; i < len(m.StatusDetails); i++ {

		if m.StatusDetails[i] != nil {
			if err := m.StatusDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("status_details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SoftwareReference) contextValidateUpdateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "update_details", "body", []*SoftwareUpdateDetailsReference(m.UpdateDetails)); err != nil {
		return err
	}

	for i := 0; i < len(m.UpdateDetails); i++ {

		if m.UpdateDetails[i] != nil {
			if err := m.UpdateDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("update_details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SoftwareReference) contextValidateValidationResults(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "validation_results", "body", []*SoftwareValidationReference(m.ValidationResults)); err != nil {
		return err
	}

	for i := 0; i < len(m.ValidationResults); i++ {

		if m.ValidationResults[i] != nil {
			if err := m.ValidationResults[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validation_results" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SoftwareReference) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SoftwareReference) UnmarshalBinary(b []byte) error {
	var res SoftwareReference
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SoftwareReferenceLinks software reference links
//
// swagger:model SoftwareReferenceLinks
type SoftwareReferenceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this software reference links
func (m *SoftwareReferenceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SoftwareReferenceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this software reference links based on the context it is used
func (m *SoftwareReferenceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SoftwareReferenceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SoftwareReferenceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SoftwareReferenceLinks) UnmarshalBinary(b []byte) error {
	var res SoftwareReferenceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SoftwareReferenceMetrocluster software reference metrocluster
//
// swagger:model SoftwareReferenceMetrocluster
type SoftwareReferenceMetrocluster struct {

	// List of MetroCluster sites, statuses, and active ONTAP versions.
	// Read Only: true
	Clusters []*SoftwareMccReference `json:"clusters,omitempty"`

	// progress details
	ProgressDetails *SoftwareReferenceMetroclusterProgressDetails `json:"progress_details,omitempty"`

	// progress summary
	ProgressSummary *SoftwareReferenceMetroclusterProgressSummary `json:"progress_summary,omitempty"`
}

// Validate validates this software reference metrocluster
func (m *SoftwareReferenceMetrocluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClusters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgressDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgressSummary(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SoftwareReferenceMetrocluster) validateClusters(formats strfmt.Registry) error {
	if swag.IsZero(m.Clusters) { // not required
		return nil
	}

	for i := 0; i < len(m.Clusters); i++ {
		if swag.IsZero(m.Clusters[i]) { // not required
			continue
		}

		if m.Clusters[i] != nil {
			if err := m.Clusters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrocluster" + "." + "clusters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SoftwareReferenceMetrocluster) validateProgressDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.ProgressDetails) { // not required
		return nil
	}

	if m.ProgressDetails != nil {
		if err := m.ProgressDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster" + "." + "progress_details")
			}
			return err
		}
	}

	return nil
}

func (m *SoftwareReferenceMetrocluster) validateProgressSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.ProgressSummary) { // not required
		return nil
	}

	if m.ProgressSummary != nil {
		if err := m.ProgressSummary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster" + "." + "progress_summary")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this software reference metrocluster based on the context it is used
func (m *SoftwareReferenceMetrocluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClusters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgressDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgressSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SoftwareReferenceMetrocluster) contextValidateClusters(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metrocluster"+"."+"clusters", "body", []*SoftwareMccReference(m.Clusters)); err != nil {
		return err
	}

	for i := 0; i < len(m.Clusters); i++ {

		if m.Clusters[i] != nil {
			if err := m.Clusters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrocluster" + "." + "clusters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SoftwareReferenceMetrocluster) contextValidateProgressDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.ProgressDetails != nil {
		if err := m.ProgressDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster" + "." + "progress_details")
			}
			return err
		}
	}

	return nil
}

func (m *SoftwareReferenceMetrocluster) contextValidateProgressSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.ProgressSummary != nil {
		if err := m.ProgressSummary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrocluster" + "." + "progress_summary")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SoftwareReferenceMetrocluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SoftwareReferenceMetrocluster) UnmarshalBinary(b []byte) error {
	var res SoftwareReferenceMetrocluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SoftwareReferenceMetroclusterProgressDetails software reference metrocluster progress details
//
// swagger:model SoftwareReferenceMetroclusterProgressDetails
type SoftwareReferenceMetroclusterProgressDetails struct {

	// MetroCluster update progress details.
	// Example: Switchover in progress
	Message string `json:"message,omitempty"`
}

// Validate validates this software reference metrocluster progress details
func (m *SoftwareReferenceMetroclusterProgressDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this software reference metrocluster progress details based on the context it is used
func (m *SoftwareReferenceMetroclusterProgressDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *SoftwareReferenceMetroclusterProgressDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SoftwareReferenceMetroclusterProgressDetails) UnmarshalBinary(b []byte) error {
	var res SoftwareReferenceMetroclusterProgressDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SoftwareReferenceMetroclusterProgressSummary software reference metrocluster progress summary
//
// swagger:model SoftwareReferenceMetroclusterProgressSummary
type SoftwareReferenceMetroclusterProgressSummary struct {

	// MetroCluster update progress summary.
	// Example: MetroCluster updated successfully.
	Message string `json:"message,omitempty"`
}

// Validate validates this software reference metrocluster progress summary
func (m *SoftwareReferenceMetroclusterProgressSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this software reference metrocluster progress summary based on the context it is used
func (m *SoftwareReferenceMetroclusterProgressSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *SoftwareReferenceMetroclusterProgressSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SoftwareReferenceMetroclusterProgressSummary) UnmarshalBinary(b []byte) error {
	var res SoftwareReferenceMetroclusterProgressSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

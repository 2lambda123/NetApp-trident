// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Metrocluster Holds MetroCluster status and configuration parameters for the local and remote clusters. REST: /api/cluster/metrocluster
//
// swagger:model metrocluster
type Metrocluster struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// DR Pairs to create as part of a MetroCluster configure.
	DrPairs []*MetroclusterDrPairsItems0 `json:"dr_pairs,omitempty"`

	// local
	Local *MetroclusterLocal `json:"local,omitempty"`

	// List of Port specifications.
	MccipPorts []*MetroclusterMccipPortsItems0 `json:"mccip_ports,omitempty"`

	// mediator
	Mediator *MetroclusterMediator `json:"mediator,omitempty"`

	// partner cluster
	PartnerCluster *MetroclusterPartnerCluster `json:"partner_cluster,omitempty"`

	// remote
	Remote *MetroclusterRemote `json:"remote,omitempty"`
}

// Validate validates this metrocluster
func (m *Metrocluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrPairs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMccipPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMediator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartnerCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemote(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Metrocluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) validateDrPairs(formats strfmt.Registry) error {
	if swag.IsZero(m.DrPairs) { // not required
		return nil
	}

	for i := 0; i < len(m.DrPairs); i++ {
		if swag.IsZero(m.DrPairs[i]) { // not required
			continue
		}

		if m.DrPairs[i] != nil {
			if err := m.DrPairs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dr_pairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metrocluster) validateLocal(formats strfmt.Registry) error {
	if swag.IsZero(m.Local) { // not required
		return nil
	}

	if m.Local != nil {
		if err := m.Local.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) validateMccipPorts(formats strfmt.Registry) error {
	if swag.IsZero(m.MccipPorts) { // not required
		return nil
	}

	for i := 0; i < len(m.MccipPorts); i++ {
		if swag.IsZero(m.MccipPorts[i]) { // not required
			continue
		}

		if m.MccipPorts[i] != nil {
			if err := m.MccipPorts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mccip_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metrocluster) validateMediator(formats strfmt.Registry) error {
	if swag.IsZero(m.Mediator) { // not required
		return nil
	}

	if m.Mediator != nil {
		if err := m.Mediator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) validatePartnerCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.PartnerCluster) { // not required
		return nil
	}

	if m.PartnerCluster != nil {
		if err := m.PartnerCluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_cluster")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) validateRemote(formats strfmt.Registry) error {
	if swag.IsZero(m.Remote) { // not required
		return nil
	}

	if m.Remote != nil {
		if err := m.Remote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster based on the context it is used
func (m *Metrocluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrPairs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMccipPorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMediator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartnerCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemote(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Metrocluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) contextValidateDrPairs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DrPairs); i++ {

		if m.DrPairs[i] != nil {
			if err := m.DrPairs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dr_pairs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metrocluster) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if m.Local != nil {
		if err := m.Local.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) contextValidateMccipPorts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MccipPorts); i++ {

		if m.MccipPorts[i] != nil {
			if err := m.MccipPorts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mccip_ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metrocluster) contextValidateMediator(ctx context.Context, formats strfmt.Registry) error {

	if m.Mediator != nil {
		if err := m.Mediator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) contextValidatePartnerCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.PartnerCluster != nil {
		if err := m.PartnerCluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_cluster")
			}
			return err
		}
	}

	return nil
}

func (m *Metrocluster) contextValidateRemote(ctx context.Context, formats strfmt.Registry) error {

	if m.Remote != nil {
		if err := m.Remote.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Metrocluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Metrocluster) UnmarshalBinary(b []byte) error {
	var res Metrocluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDrPairsItems0 metrocluster dr pairs items0
//
// swagger:model MetroclusterDrPairsItems0
type MetroclusterDrPairsItems0 struct {

	// node
	Node *MetroclusterDrPairsItems0Node `json:"node,omitempty"`

	// partner
	Partner *MetroclusterDrPairsItems0Partner `json:"partner,omitempty"`
}

// Validate validates this metrocluster dr pairs items0
func (m *MetroclusterDrPairsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDrPairsItems0) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(m.Partner) { // not required
		return nil
	}

	if m.Partner != nil {
		if err := m.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster dr pairs items0 based on the context it is used
func (m *MetroclusterDrPairsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDrPairsItems0) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if m.Partner != nil {
		if err := m.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0) UnmarshalBinary(b []byte) error {
	var res MetroclusterDrPairsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDrPairsItems0Node Local node of the DR Group.
//
// swagger:model MetroclusterDrPairsItems0Node
type MetroclusterDrPairsItems0Node struct {

	// links
	Links *MetroclusterDrPairsItems0NodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this metrocluster dr pairs items0 node
func (m *MetroclusterDrPairsItems0Node) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0Node) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster dr pairs items0 node based on the context it is used
func (m *MetroclusterDrPairsItems0Node) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0Node) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0Node) UnmarshalBinary(b []byte) error {
	var res MetroclusterDrPairsItems0Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDrPairsItems0NodeLinks metrocluster dr pairs items0 node links
//
// swagger:model MetroclusterDrPairsItems0NodeLinks
type MetroclusterDrPairsItems0NodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster dr pairs items0 node links
func (m *MetroclusterDrPairsItems0NodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0NodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster dr pairs items0 node links based on the context it is used
func (m *MetroclusterDrPairsItems0NodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0NodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0NodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0NodeLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterDrPairsItems0NodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDrPairsItems0Partner Partner node of the DR Group.
//
// swagger:model MetroclusterDrPairsItems0Partner
type MetroclusterDrPairsItems0Partner struct {

	// links
	Links *MetroclusterDrPairsItems0PartnerLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this metrocluster dr pairs items0 partner
func (m *MetroclusterDrPairsItems0Partner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0Partner) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster dr pairs items0 partner based on the context it is used
func (m *MetroclusterDrPairsItems0Partner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0Partner) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0Partner) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0Partner) UnmarshalBinary(b []byte) error {
	var res MetroclusterDrPairsItems0Partner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDrPairsItems0PartnerLinks metrocluster dr pairs items0 partner links
//
// swagger:model MetroclusterDrPairsItems0PartnerLinks
type MetroclusterDrPairsItems0PartnerLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster dr pairs items0 partner links
func (m *MetroclusterDrPairsItems0PartnerLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0PartnerLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster dr pairs items0 partner links based on the context it is used
func (m *MetroclusterDrPairsItems0PartnerLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDrPairsItems0PartnerLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0PartnerLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDrPairsItems0PartnerLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterDrPairsItems0PartnerLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterLocal metrocluster local
//
// swagger:model MetroclusterLocal
type MetroclusterLocal struct {

	// cluster
	Cluster *MetroclusterLocalCluster `json:"cluster,omitempty"`

	// Indicates the state of the local cluster configuration.
	// Read Only: true
	// Enum: [configuration_error configured not_configured not_reachable partially_configured unknown]
	ConfigurationState string `json:"configuration_state,omitempty"`

	// Specifies the mode of operation of the local cluster.
	// Read Only: true
	// Enum: [normal not_configured not_reachable partial_switchback partial_switchover switchover unknown waiting_for_switchback]
	Mode string `json:"mode,omitempty"`

	// Specifies whether the partner cluster is reachable from the local cluster.
	// Read Only: true
	PartnerClusterReachable *bool `json:"partner_cluster_reachable,omitempty"`

	// Indicates whether or not a periodic check is enabled on the local cluster.
	// Read Only: true
	PeriodicCheckEnabled *bool `json:"periodic_check_enabled,omitempty"`
}

// Validate validates this metrocluster local
func (m *MetroclusterLocal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurationState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterLocal) validateCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Cluster) { // not required
		return nil
	}

	if m.Cluster != nil {
		if err := m.Cluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "cluster")
			}
			return err
		}
	}

	return nil
}

var metroclusterLocalTypeConfigurationStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["configuration_error","configured","not_configured","not_reachable","partially_configured","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterLocalTypeConfigurationStatePropEnum = append(metroclusterLocalTypeConfigurationStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// configuration_state
	// ConfigurationState
	// configuration_error
	// END DEBUGGING
	// MetroclusterLocalConfigurationStateConfigurationError captures enum value "configuration_error"
	MetroclusterLocalConfigurationStateConfigurationError string = "configuration_error"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// configuration_state
	// ConfigurationState
	// configured
	// END DEBUGGING
	// MetroclusterLocalConfigurationStateConfigured captures enum value "configured"
	MetroclusterLocalConfigurationStateConfigured string = "configured"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// configuration_state
	// ConfigurationState
	// not_configured
	// END DEBUGGING
	// MetroclusterLocalConfigurationStateNotConfigured captures enum value "not_configured"
	MetroclusterLocalConfigurationStateNotConfigured string = "not_configured"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// configuration_state
	// ConfigurationState
	// not_reachable
	// END DEBUGGING
	// MetroclusterLocalConfigurationStateNotReachable captures enum value "not_reachable"
	MetroclusterLocalConfigurationStateNotReachable string = "not_reachable"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// configuration_state
	// ConfigurationState
	// partially_configured
	// END DEBUGGING
	// MetroclusterLocalConfigurationStatePartiallyConfigured captures enum value "partially_configured"
	MetroclusterLocalConfigurationStatePartiallyConfigured string = "partially_configured"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// configuration_state
	// ConfigurationState
	// unknown
	// END DEBUGGING
	// MetroclusterLocalConfigurationStateUnknown captures enum value "unknown"
	MetroclusterLocalConfigurationStateUnknown string = "unknown"
)

// prop value enum
func (m *MetroclusterLocal) validateConfigurationStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterLocalTypeConfigurationStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterLocal) validateConfigurationState(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigurationState) { // not required
		return nil
	}

	// value enum
	if err := m.validateConfigurationStateEnum("local"+"."+"configuration_state", "body", m.ConfigurationState); err != nil {
		return err
	}

	return nil
}

var metroclusterLocalTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["normal","not_configured","not_reachable","partial_switchback","partial_switchover","switchover","unknown","waiting_for_switchback"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterLocalTypeModePropEnum = append(metroclusterLocalTypeModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// normal
	// END DEBUGGING
	// MetroclusterLocalModeNormal captures enum value "normal"
	MetroclusterLocalModeNormal string = "normal"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// not_configured
	// END DEBUGGING
	// MetroclusterLocalModeNotConfigured captures enum value "not_configured"
	MetroclusterLocalModeNotConfigured string = "not_configured"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// not_reachable
	// END DEBUGGING
	// MetroclusterLocalModeNotReachable captures enum value "not_reachable"
	MetroclusterLocalModeNotReachable string = "not_reachable"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// partial_switchback
	// END DEBUGGING
	// MetroclusterLocalModePartialSwitchback captures enum value "partial_switchback"
	MetroclusterLocalModePartialSwitchback string = "partial_switchback"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// partial_switchover
	// END DEBUGGING
	// MetroclusterLocalModePartialSwitchover captures enum value "partial_switchover"
	MetroclusterLocalModePartialSwitchover string = "partial_switchover"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// switchover
	// END DEBUGGING
	// MetroclusterLocalModeSwitchover captures enum value "switchover"
	MetroclusterLocalModeSwitchover string = "switchover"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// unknown
	// END DEBUGGING
	// MetroclusterLocalModeUnknown captures enum value "unknown"
	MetroclusterLocalModeUnknown string = "unknown"

	// BEGIN DEBUGGING
	// MetroclusterLocal
	// MetroclusterLocal
	// mode
	// Mode
	// waiting_for_switchback
	// END DEBUGGING
	// MetroclusterLocalModeWaitingForSwitchback captures enum value "waiting_for_switchback"
	MetroclusterLocalModeWaitingForSwitchback string = "waiting_for_switchback"
)

// prop value enum
func (m *MetroclusterLocal) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterLocalTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterLocal) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("local"+"."+"mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster local based on the context it is used
func (m *MetroclusterLocal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurationState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartnerClusterReachable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeriodicCheckEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterLocal) contextValidateCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Cluster != nil {
		if err := m.Cluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "cluster")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterLocal) contextValidateConfigurationState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "local"+"."+"configuration_state", "body", string(m.ConfigurationState)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterLocal) contextValidateMode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "local"+"."+"mode", "body", string(m.Mode)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterLocal) contextValidatePartnerClusterReachable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "local"+"."+"partner_cluster_reachable", "body", m.PartnerClusterReachable); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterLocal) contextValidatePeriodicCheckEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "local"+"."+"periodic_check_enabled", "body", m.PeriodicCheckEnabled); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterLocal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterLocal) UnmarshalBinary(b []byte) error {
	var res MetroclusterLocal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterLocalCluster metrocluster local cluster
//
// swagger:model MetroclusterLocalCluster
type MetroclusterLocalCluster struct {

	// links
	Links *MetroclusterLocalClusterLinks `json:"_links,omitempty"`

	// name
	// Example: cluster1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`
}

// Validate validates this metrocluster local cluster
func (m *MetroclusterLocalCluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterLocalCluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterLocalCluster) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("local"+"."+"cluster"+"."+"uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster local cluster based on the context it is used
func (m *MetroclusterLocalCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterLocalCluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterLocalCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterLocalCluster) UnmarshalBinary(b []byte) error {
	var res MetroclusterLocalCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterLocalClusterLinks metrocluster local cluster links
//
// swagger:model MetroclusterLocalClusterLinks
type MetroclusterLocalClusterLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster local cluster links
func (m *MetroclusterLocalClusterLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterLocalClusterLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster local cluster links based on the context it is used
func (m *MetroclusterLocalClusterLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterLocalClusterLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterLocalClusterLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterLocalClusterLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterLocalClusterLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMccipPortsItems0 Port configuration specification.
// l3_config information is only needed when configuring a MetroCluster IP for use in a layer 3 network.
//
//
// swagger:model MetroclusterMccipPortsItems0
type MetroclusterMccipPortsItems0 struct {

	// l3 config
	L3Config *MetroclusterMccipPortsItems0L3Config `json:"l3_config,omitempty"`

	// Port name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *MetroclusterMccipPortsItems0Node `json:"node,omitempty"`

	// Port UUID
	UUID string `json:"uuid,omitempty"`

	// VLAN ID
	// Example: 200
	// Maximum: 4095
	// Minimum: 10
	VlanID int64 `json:"vlan_id,omitempty"`
}

// Validate validates this metrocluster mccip ports items0
func (m *MetroclusterMccipPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateL3Config(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlanID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0) validateL3Config(formats strfmt.Registry) error {
	if swag.IsZero(m.L3Config) { // not required
		return nil
	}

	if m.L3Config != nil {
		if err := m.L3Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("l3_config")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterMccipPortsItems0) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterMccipPortsItems0) validateVlanID(formats strfmt.Registry) error {
	if swag.IsZero(m.VlanID) { // not required
		return nil
	}

	if err := validate.MinimumInt("vlan_id", "body", m.VlanID, 10, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vlan_id", "body", m.VlanID, 4095, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster mccip ports items0 based on the context it is used
func (m *MetroclusterMccipPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateL3Config(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0) contextValidateL3Config(ctx context.Context, formats strfmt.Registry) error {

	if m.L3Config != nil {
		if err := m.L3Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("l3_config")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterMccipPortsItems0) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0) UnmarshalBinary(b []byte) error {
	var res MetroclusterMccipPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMccipPortsItems0L3Config metrocluster mccip ports items0 l3 config
//
// swagger:model MetroclusterMccipPortsItems0L3Config
type MetroclusterMccipPortsItems0L3Config struct {

	// ipv4 interface
	IPV4Interface *MetroclusterMccipPortsItems0L3ConfigIPV4Interface `json:"ipv4_interface,omitempty"`
}

// Validate validates this metrocluster mccip ports items0 l3 config
func (m *MetroclusterMccipPortsItems0L3Config) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIPV4Interface(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0L3Config) validateIPV4Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV4Interface) { // not required
		return nil
	}

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("l3_config" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster mccip ports items0 l3 config based on the context it is used
func (m *MetroclusterMccipPortsItems0L3Config) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIPV4Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0L3Config) contextValidateIPV4Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("l3_config" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0L3Config) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0L3Config) UnmarshalBinary(b []byte) error {
	var res MetroclusterMccipPortsItems0L3Config
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMccipPortsItems0L3ConfigIPV4Interface Object to setup an interface along with its default router.
//
// swagger:model MetroclusterMccipPortsItems0L3ConfigIPV4Interface
type MetroclusterMccipPortsItems0L3ConfigIPV4Interface struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this metrocluster mccip ports items0 l3 config IP v4 interface
func (m *MetroclusterMccipPortsItems0L3ConfigIPV4Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0L3ConfigIPV4Interface) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("l3_config" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster mccip ports items0 l3 config IP v4 interface based on the context it is used
func (m *MetroclusterMccipPortsItems0L3ConfigIPV4Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0L3ConfigIPV4Interface) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("l3_config" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0L3ConfigIPV4Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0L3ConfigIPV4Interface) UnmarshalBinary(b []byte) error {
	var res MetroclusterMccipPortsItems0L3ConfigIPV4Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMccipPortsItems0Node Node information
//
// swagger:model MetroclusterMccipPortsItems0Node
type MetroclusterMccipPortsItems0Node struct {

	// links
	Links *MetroclusterMccipPortsItems0NodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this metrocluster mccip ports items0 node
func (m *MetroclusterMccipPortsItems0Node) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0Node) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster mccip ports items0 node based on the context it is used
func (m *MetroclusterMccipPortsItems0Node) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0Node) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0Node) UnmarshalBinary(b []byte) error {
	var res MetroclusterMccipPortsItems0Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMccipPortsItems0NodeLinks metrocluster mccip ports items0 node links
//
// swagger:model MetroclusterMccipPortsItems0NodeLinks
type MetroclusterMccipPortsItems0NodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster mccip ports items0 node links
func (m *MetroclusterMccipPortsItems0NodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0NodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster mccip ports items0 node links based on the context it is used
func (m *MetroclusterMccipPortsItems0NodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMccipPortsItems0NodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0NodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMccipPortsItems0NodeLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterMccipPortsItems0NodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMediator Mediator information
//
// swagger:model MetroclusterMediator
type MetroclusterMediator struct {

	// CA certificate for ONTAP Mediator. This is optional if the certificate is already installed.
	CaCertificate string `json:"ca_certificate,omitempty"`

	// dr group
	DrGroup *MetroclusterMediatorDrGroup `json:"dr_group,omitempty"`

	// The IP address of the mediator.
	// Example: 10.10.10.7
	IPAddress string `json:"ip_address,omitempty"`

	// The password used to connect to the REST server on the mediator.
	// Example: mypassword
	// Format: password
	Password strfmt.Password `json:"password,omitempty"`

	// peer cluster
	PeerCluster *MetroclusterMediatorPeerCluster `json:"peer_cluster,omitempty"`

	// Indicates the mediator connectivity status of the peer cluster. Possible values are connected, unreachable, unknown.
	// Example: connected
	// Read Only: true
	PeerMediatorConnectivity string `json:"peer_mediator_connectivity,omitempty"`

	// The REST server's port number on the mediator.
	// Example: 31784
	Port *int64 `json:"port,omitempty"`

	// Indicates the connectivity status of the mediator.
	// Example: true
	// Read Only: true
	Reachable *bool `json:"reachable,omitempty"`

	// The username used to connect to the REST server on the mediator.
	// Example: myusername
	User string `json:"user,omitempty"`

	// The unique identifier for the mediator service.
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this metrocluster mediator
func (m *MetroclusterMediator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDrGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeerCluster(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMediator) validateDrGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.DrGroup) { // not required
		return nil
	}

	if m.DrGroup != nil {
		if err := m.DrGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "dr_group")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterMediator) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.FormatOf("mediator"+"."+"password", "body", "password", m.Password.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterMediator) validatePeerCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.PeerCluster) { // not required
		return nil
	}

	if m.PeerCluster != nil {
		if err := m.PeerCluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "peer_cluster")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster mediator based on the context it is used
func (m *MetroclusterMediator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDrGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeerCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeerMediatorConnectivity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReachable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMediator) contextValidateDrGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.DrGroup != nil {
		if err := m.DrGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "dr_group")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterMediator) contextValidatePeerCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.PeerCluster != nil {
		if err := m.PeerCluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "peer_cluster")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterMediator) contextValidatePeerMediatorConnectivity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mediator"+"."+"peer_mediator_connectivity", "body", string(m.PeerMediatorConnectivity)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterMediator) contextValidateReachable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mediator"+"."+"reachable", "body", m.Reachable); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterMediator) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mediator"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMediator) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMediator) UnmarshalBinary(b []byte) error {
	var res MetroclusterMediator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMediatorDrGroup DR group reference.
//
// swagger:model MetroclusterMediatorDrGroup
type MetroclusterMediatorDrGroup struct {

	// DR Group ID
	// Read Only: true
	ID int64 `json:"id,omitempty"`
}

// Validate validates this metrocluster mediator dr group
func (m *MetroclusterMediatorDrGroup) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster mediator dr group based on the context it is used
func (m *MetroclusterMediatorDrGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMediatorDrGroup) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mediator"+"."+"dr_group"+"."+"id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMediatorDrGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMediatorDrGroup) UnmarshalBinary(b []byte) error {
	var res MetroclusterMediatorDrGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMediatorPeerCluster The peer cluster that the mediator service is used for.
//
// swagger:model MetroclusterMediatorPeerCluster
type MetroclusterMediatorPeerCluster struct {

	// links
	Links *MetroclusterMediatorPeerClusterLinks `json:"_links,omitempty"`

	// name
	// Example: cluster2
	Name string `json:"name,omitempty"`

	// uuid
	// Example: ebe27c49-1adf-4496-8335-ab862aebebf2
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this metrocluster mediator peer cluster
func (m *MetroclusterMediatorPeerCluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMediatorPeerCluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "peer_cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster mediator peer cluster based on the context it is used
func (m *MetroclusterMediatorPeerCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMediatorPeerCluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "peer_cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMediatorPeerCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMediatorPeerCluster) UnmarshalBinary(b []byte) error {
	var res MetroclusterMediatorPeerCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterMediatorPeerClusterLinks metrocluster mediator peer cluster links
//
// swagger:model MetroclusterMediatorPeerClusterLinks
type MetroclusterMediatorPeerClusterLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster mediator peer cluster links
func (m *MetroclusterMediatorPeerClusterLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMediatorPeerClusterLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "peer_cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster mediator peer cluster links based on the context it is used
func (m *MetroclusterMediatorPeerClusterLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterMediatorPeerClusterLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mediator" + "." + "peer_cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterMediatorPeerClusterLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterMediatorPeerClusterLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterMediatorPeerClusterLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterPartnerCluster Partner cluster information.
//
// swagger:model MetroclusterPartnerCluster
type MetroclusterPartnerCluster struct {

	// links
	Links *MetroclusterPartnerClusterLinks `json:"_links,omitempty"`

	// name
	// Example: cluster1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`
}

// Validate validates this metrocluster partner cluster
func (m *MetroclusterPartnerCluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterPartnerCluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterPartnerCluster) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("partner_cluster"+"."+"uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster partner cluster based on the context it is used
func (m *MetroclusterPartnerCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterPartnerCluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterPartnerCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterPartnerCluster) UnmarshalBinary(b []byte) error {
	var res MetroclusterPartnerCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterPartnerClusterLinks metrocluster partner cluster links
//
// swagger:model MetroclusterPartnerClusterLinks
type MetroclusterPartnerClusterLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster partner cluster links
func (m *MetroclusterPartnerClusterLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterPartnerClusterLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster partner cluster links based on the context it is used
func (m *MetroclusterPartnerClusterLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterPartnerClusterLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterPartnerClusterLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterPartnerClusterLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterPartnerClusterLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterRemote metrocluster remote
//
// swagger:model MetroclusterRemote
type MetroclusterRemote struct {

	// cluster
	Cluster *MetroclusterRemoteCluster `json:"cluster,omitempty"`

	// Indicates the state of the remote cluster configuration.
	// Read Only: true
	// Enum: [configuration_error configured not_configured not_reachable partially_configured unknown]
	ConfigurationState string `json:"configuration_state,omitempty"`

	// Specifies the mode of operation of the remote cluster.
	// Read Only: true
	// Enum: [normal not_configured not_reachable partial_switchback partial_switchover switchover unknown waiting_for_switchback]
	Mode string `json:"mode,omitempty"`

	// Indicates whether or not a periodic check is enabled on the remote cluster.
	// Read Only: true
	PeriodicCheckEnabled *bool `json:"periodic_check_enabled,omitempty"`
}

// Validate validates this metrocluster remote
func (m *MetroclusterRemote) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurationState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterRemote) validateCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Cluster) { // not required
		return nil
	}

	if m.Cluster != nil {
		if err := m.Cluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "cluster")
			}
			return err
		}
	}

	return nil
}

var metroclusterRemoteTypeConfigurationStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["configuration_error","configured","not_configured","not_reachable","partially_configured","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterRemoteTypeConfigurationStatePropEnum = append(metroclusterRemoteTypeConfigurationStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// configuration_state
	// ConfigurationState
	// configuration_error
	// END DEBUGGING
	// MetroclusterRemoteConfigurationStateConfigurationError captures enum value "configuration_error"
	MetroclusterRemoteConfigurationStateConfigurationError string = "configuration_error"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// configuration_state
	// ConfigurationState
	// configured
	// END DEBUGGING
	// MetroclusterRemoteConfigurationStateConfigured captures enum value "configured"
	MetroclusterRemoteConfigurationStateConfigured string = "configured"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// configuration_state
	// ConfigurationState
	// not_configured
	// END DEBUGGING
	// MetroclusterRemoteConfigurationStateNotConfigured captures enum value "not_configured"
	MetroclusterRemoteConfigurationStateNotConfigured string = "not_configured"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// configuration_state
	// ConfigurationState
	// not_reachable
	// END DEBUGGING
	// MetroclusterRemoteConfigurationStateNotReachable captures enum value "not_reachable"
	MetroclusterRemoteConfigurationStateNotReachable string = "not_reachable"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// configuration_state
	// ConfigurationState
	// partially_configured
	// END DEBUGGING
	// MetroclusterRemoteConfigurationStatePartiallyConfigured captures enum value "partially_configured"
	MetroclusterRemoteConfigurationStatePartiallyConfigured string = "partially_configured"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// configuration_state
	// ConfigurationState
	// unknown
	// END DEBUGGING
	// MetroclusterRemoteConfigurationStateUnknown captures enum value "unknown"
	MetroclusterRemoteConfigurationStateUnknown string = "unknown"
)

// prop value enum
func (m *MetroclusterRemote) validateConfigurationStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterRemoteTypeConfigurationStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterRemote) validateConfigurationState(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigurationState) { // not required
		return nil
	}

	// value enum
	if err := m.validateConfigurationStateEnum("remote"+"."+"configuration_state", "body", m.ConfigurationState); err != nil {
		return err
	}

	return nil
}

var metroclusterRemoteTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["normal","not_configured","not_reachable","partial_switchback","partial_switchover","switchover","unknown","waiting_for_switchback"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterRemoteTypeModePropEnum = append(metroclusterRemoteTypeModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// normal
	// END DEBUGGING
	// MetroclusterRemoteModeNormal captures enum value "normal"
	MetroclusterRemoteModeNormal string = "normal"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// not_configured
	// END DEBUGGING
	// MetroclusterRemoteModeNotConfigured captures enum value "not_configured"
	MetroclusterRemoteModeNotConfigured string = "not_configured"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// not_reachable
	// END DEBUGGING
	// MetroclusterRemoteModeNotReachable captures enum value "not_reachable"
	MetroclusterRemoteModeNotReachable string = "not_reachable"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// partial_switchback
	// END DEBUGGING
	// MetroclusterRemoteModePartialSwitchback captures enum value "partial_switchback"
	MetroclusterRemoteModePartialSwitchback string = "partial_switchback"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// partial_switchover
	// END DEBUGGING
	// MetroclusterRemoteModePartialSwitchover captures enum value "partial_switchover"
	MetroclusterRemoteModePartialSwitchover string = "partial_switchover"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// switchover
	// END DEBUGGING
	// MetroclusterRemoteModeSwitchover captures enum value "switchover"
	MetroclusterRemoteModeSwitchover string = "switchover"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// unknown
	// END DEBUGGING
	// MetroclusterRemoteModeUnknown captures enum value "unknown"
	MetroclusterRemoteModeUnknown string = "unknown"

	// BEGIN DEBUGGING
	// MetroclusterRemote
	// MetroclusterRemote
	// mode
	// Mode
	// waiting_for_switchback
	// END DEBUGGING
	// MetroclusterRemoteModeWaitingForSwitchback captures enum value "waiting_for_switchback"
	MetroclusterRemoteModeWaitingForSwitchback string = "waiting_for_switchback"
)

// prop value enum
func (m *MetroclusterRemote) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterRemoteTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterRemote) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("remote"+"."+"mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster remote based on the context it is used
func (m *MetroclusterRemote) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurationState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeriodicCheckEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterRemote) contextValidateCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Cluster != nil {
		if err := m.Cluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "cluster")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterRemote) contextValidateConfigurationState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "remote"+"."+"configuration_state", "body", string(m.ConfigurationState)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterRemote) contextValidateMode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "remote"+"."+"mode", "body", string(m.Mode)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterRemote) contextValidatePeriodicCheckEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "remote"+"."+"periodic_check_enabled", "body", m.PeriodicCheckEnabled); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterRemote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterRemote) UnmarshalBinary(b []byte) error {
	var res MetroclusterRemote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterRemoteCluster metrocluster remote cluster
//
// swagger:model MetroclusterRemoteCluster
type MetroclusterRemoteCluster struct {

	// links
	Links *MetroclusterRemoteClusterLinks `json:"_links,omitempty"`

	// name
	// Example: cluster1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`
}

// Validate validates this metrocluster remote cluster
func (m *MetroclusterRemoteCluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterRemoteCluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterRemoteCluster) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("remote"+"."+"cluster"+"."+"uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster remote cluster based on the context it is used
func (m *MetroclusterRemoteCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterRemoteCluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterRemoteCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterRemoteCluster) UnmarshalBinary(b []byte) error {
	var res MetroclusterRemoteCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterRemoteClusterLinks metrocluster remote cluster links
//
// swagger:model MetroclusterRemoteClusterLinks
type MetroclusterRemoteClusterLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster remote cluster links
func (m *MetroclusterRemoteClusterLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterRemoteClusterLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster remote cluster links based on the context it is used
func (m *MetroclusterRemoteClusterLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterRemoteClusterLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote" + "." + "cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterRemoteClusterLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterRemoteClusterLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterRemoteClusterLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

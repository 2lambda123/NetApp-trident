// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NodeResponse node response
//
// swagger:model node_response
type NodeResponse struct {

	// links
	Links *NodeResponseLinks `json:"_links,omitempty"`

	// num records
	NumRecords int64 `json:"num_records,omitempty"`

	// records
	Records []*NodeResponseRecordsItems0 `json:"records,omitempty"`
}

// Validate validates this node response
func (m *NodeResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecords(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponse) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponse) validateRecords(formats strfmt.Registry) error {
	if swag.IsZero(m.Records) { // not required
		return nil
	}

	for i := 0; i < len(m.Records); i++ {
		if swag.IsZero(m.Records[i]) { // not required
			continue
		}

		if m.Records[i] != nil {
			if err := m.Records[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("records" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this node response based on the context it is used
func (m *NodeResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecords(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponse) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponse) contextValidateRecords(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Records); i++ {

		if m.Records[i] != nil {
			if err := m.Records[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("records" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponse) UnmarshalBinary(b []byte) error {
	var res NodeResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseLinks node response links
//
// swagger:model NodeResponseLinks
type NodeResponseLinks struct {

	// next
	Next *Href `json:"next,omitempty"`

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response links
func (m *NodeResponseLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseLinks) validateNext(formats strfmt.Registry) error {
	if swag.IsZero(m.Next) { // not required
		return nil
	}

	if m.Next != nil {
		if err := m.Next.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response links based on the context it is used
func (m *NodeResponseLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseLinks) contextValidateNext(ctx context.Context, formats strfmt.Registry) error {

	if m.Next != nil {
		if err := m.Next.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseLinks) UnmarshalBinary(b []byte) error {
	var res NodeResponseLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0 Complete node information
//
// swagger:model NodeResponseRecordsItems0
type NodeResponseRecordsItems0 struct {

	// links
	Links *NodeResponseRecordsItems0Links `json:"_links,omitempty"`

	// cluster interface
	ClusterInterface *NodeResponseRecordsItems0ClusterInterface `json:"cluster_interface,omitempty"`

	// cluster interfaces
	// Read Only: true
	ClusterInterfaces []*NodeResponseRecordsItems0ClusterInterfacesItems0 `json:"cluster_interfaces,omitempty"`

	// controller
	Controller *NodeResponseRecordsItems0Controller `json:"controller,omitempty"`

	// The current or "wall clock" time of the node in ISO-8601 date, time, and time zone format.
	// The ISO-8601 date and time are localized based on the ONTAP cluster's timezone setting.
	//
	// Example: 2019-04-17 15:49:26
	// Read Only: true
	// Format: date-time
	Date *strfmt.DateTime `json:"date,omitempty"`

	// ha
	Ha *NodeResponseRecordsItems0Ha `json:"ha,omitempty"`

	// location
	// Example: rack 2 row 5
	Location string `json:"location,omitempty"`

	// management interface
	ManagementInterface *NodeResponseRecordsItems0ManagementInterface `json:"management_interface,omitempty"`

	// management interfaces
	// Read Only: true
	ManagementInterfaces []*NodeResponseRecordsItems0ManagementInterfacesItems0 `json:"management_interfaces,omitempty"`

	// Possible values:
	// * <i>available</i> - A node is detected on the internal cluster network and can be added to the cluster.  Nodes that have a membership of "available" are not returned when a GET request is called when the cluster exists. Provide a query on the "membership" property for <i>available</i> to scan for nodes on the cluster network. Nodes that have a membership of "available" are returned automatically before a cluster is created.
	// * <i>joining</i> - Joining nodes are in the process of being added to the cluster. The node might be progressing through the steps to become a member or might have failed. The job to add the node or create the cluster provides details on the current progress of the node.
	// * <i>member</i> - Nodes that are members have successfully joined the cluster.
	//
	// Read Only: true
	// Enum: [available joining member]
	Membership string `json:"membership,omitempty"`

	// model
	// Example: FAS3070
	// Read Only: true
	Model string `json:"model,omitempty"`

	// name
	// Example: node-01
	Name string `json:"name,omitempty"`

	// serial number
	// Example: 4048820-60-9
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// service processor
	ServiceProcessor *NodeResponseRecordsItems0ServiceProcessor `json:"service_processor,omitempty"`

	// State of the node:
	// * <i>up</i> - Node is up and operational.
	// * <i>booting</i> - Node is booting up.
	// * <i>down</i> - Node has stopped or is dumping core.
	// * <i>taken_over</i> - Node has been taken over by its HA partner and is not yet waiting for giveback.
	// * <i>waiting_for_giveback</i> - Node has been taken over by its HA partner and is waiting for the HA partner to giveback disks.
	// * <i>degraded</i> - Node has one or more critical services offline.
	// * <i>unknown</i> - Node or its HA partner cannot be contacted and there is no information on the node's state.
	//
	// Read Only: true
	// Enum: [up booting down taken_over waiting_for_giveback degraded unknown]
	State string `json:"state,omitempty"`

	// system id
	// Example: 537035403
	// Read Only: true
	SystemID string `json:"system_id,omitempty"`

	// OEM system machine type.
	// Example: 7Y56-CTOWW1
	// Read Only: true
	SystemMachineType string `json:"system_machine_type,omitempty"`

	// The total time, in seconds, that the node has been up.
	// Example: 300536
	// Read Only: true
	Uptime int64 `json:"uptime,omitempty"`

	// uuid
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`

	// OEM vendor serial number.
	// Example: 791603000068
	// Read Only: true
	VendorSerialNumber string `json:"vendor_serial_number,omitempty"`

	// version
	Version *NodeResponseRecordsItems0Version `json:"version,omitempty"`

	// vm
	VM *NodeResponseRecordsItems0VM `json:"vm,omitempty"`
}

// Validate validates this node response records items0
func (m *NodeResponseRecordsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateController(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHa(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMembership(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceProcessor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVM(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateClusterInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterface) { // not required
		return nil
	}

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateClusterInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {
		if swag.IsZero(m.ClusterInterfaces[i]) { // not required
			continue
		}

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateController(formats strfmt.Registry) error {
	if swag.IsZero(m.Controller) { // not required
		return nil
	}

	if m.Controller != nil {
		if err := m.Controller.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date-time", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateHa(formats strfmt.Registry) error {
	if swag.IsZero(m.Ha) { // not required
		return nil
	}

	if m.Ha != nil {
		if err := m.Ha.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateManagementInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterface) { // not required
		return nil
	}

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateManagementInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {
		if swag.IsZero(m.ManagementInterfaces[i]) { // not required
			continue
		}

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var nodeResponseRecordsItems0TypeMembershipPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["available","joining","member"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0TypeMembershipPropEnum = append(nodeResponseRecordsItems0TypeMembershipPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// membership
	// Membership
	// available
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0MembershipAvailable captures enum value "available"
	NodeResponseRecordsItems0MembershipAvailable string = "available"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// membership
	// Membership
	// joining
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0MembershipJoining captures enum value "joining"
	NodeResponseRecordsItems0MembershipJoining string = "joining"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// membership
	// Membership
	// member
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0MembershipMember captures enum value "member"
	NodeResponseRecordsItems0MembershipMember string = "member"
)

// prop value enum
func (m *NodeResponseRecordsItems0) validateMembershipEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0TypeMembershipPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0) validateMembership(formats strfmt.Registry) error {
	if swag.IsZero(m.Membership) { // not required
		return nil
	}

	// value enum
	if err := m.validateMembershipEnum("membership", "body", m.Membership); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateServiceProcessor(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceProcessor) { // not required
		return nil
	}

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","booting","down","taken_over","waiting_for_giveback","degraded","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0TypeStatePropEnum = append(nodeResponseRecordsItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// up
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0StateUp captures enum value "up"
	NodeResponseRecordsItems0StateUp string = "up"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// booting
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0StateBooting captures enum value "booting"
	NodeResponseRecordsItems0StateBooting string = "booting"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// down
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0StateDown captures enum value "down"
	NodeResponseRecordsItems0StateDown string = "down"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// taken_over
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0StateTakenOver captures enum value "taken_over"
	NodeResponseRecordsItems0StateTakenOver string = "taken_over"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// waiting_for_giveback
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0StateWaitingForGiveback captures enum value "waiting_for_giveback"
	NodeResponseRecordsItems0StateWaitingForGiveback string = "waiting_for_giveback"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// degraded
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0StateDegraded captures enum value "degraded"
	NodeResponseRecordsItems0StateDegraded string = "degraded"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0
	// NodeResponseRecordsItems0
	// state
	// State
	// unknown
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0StateUnknown captures enum value "unknown"
	NodeResponseRecordsItems0StateUnknown string = "unknown"
)

// prop value enum
func (m *NodeResponseRecordsItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) validateVM(formats strfmt.Registry) error {
	if swag.IsZero(m.VM) { // not required
		return nil
	}

	if m.VM != nil {
		if err := m.VM.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 based on the context it is used
func (m *NodeResponseRecordsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateController(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHa(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMembership(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceProcessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemMachineType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUptime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVendorSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVM(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateClusterInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterInterface != nil {
		if err := m.ClusterInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateClusterInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster_interfaces", "body", []*NodeResponseRecordsItems0ClusterInterfacesItems0(m.ClusterInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ClusterInterfaces); i++ {

		if m.ClusterInterfaces[i] != nil {
			if err := m.ClusterInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateController(ctx context.Context, formats strfmt.Registry) error {

	if m.Controller != nil {
		if err := m.Controller.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateDate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "date", "body", m.Date); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateHa(ctx context.Context, formats strfmt.Registry) error {

	if m.Ha != nil {
		if err := m.Ha.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateManagementInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementInterface != nil {
		if err := m.ManagementInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateManagementInterfaces(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "management_interfaces", "body", []*NodeResponseRecordsItems0ManagementInterfacesItems0(m.ManagementInterfaces)); err != nil {
		return err
	}

	for i := 0; i < len(m.ManagementInterfaces); i++ {

		if m.ManagementInterfaces[i] != nil {
			if err := m.ManagementInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateMembership(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "membership", "body", string(m.Membership)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateServiceProcessor(ctx context.Context, formats strfmt.Registry) error {

	if m.ServiceProcessor != nil {
		if err := m.ServiceProcessor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateSystemID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_id", "body", string(m.SystemID)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateSystemMachineType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "system_machine_type", "body", string(m.SystemMachineType)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateUptime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uptime", "body", int64(m.Uptime)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateVendorSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vendor_serial_number", "body", string(m.VendorSerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0) contextValidateVM(ctx context.Context, formats strfmt.Registry) error {

	if m.VM != nil {
		if err := m.VM.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterface The cluster network IP address of the node to be added.
//
// swagger:model NodeResponseRecordsItems0ClusterInterface
type NodeResponseRecordsItems0ClusterInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this node response records items0 cluster interface
func (m *NodeResponseRecordsItems0ClusterInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interface based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterfacesItems0 Network interface
//
// swagger:model NodeResponseRecordsItems0ClusterInterfacesItems0
type NodeResponseRecordsItems0ClusterInterfacesItems0 struct {

	// links
	Links *NodeResponseRecordsItems0ClusterInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *NodeResponseRecordsItems0ClusterInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface.
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 cluster interfaces items0
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interfaces items0 based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterfacesItems0IP IP information
//
// swagger:model NodeResponseRecordsItems0ClusterInterfacesItems0IP
type NodeResponseRecordsItems0ClusterInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this node response records items0 cluster interfaces items0 IP
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interfaces items0 IP based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ClusterInterfacesItems0Links node response records items0 cluster interfaces items0 links
//
// swagger:model NodeResponseRecordsItems0ClusterInterfacesItems0Links
type NodeResponseRecordsItems0ClusterInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 cluster interfaces items0 links
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 cluster interfaces items0 links based on the context it is used
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ClusterInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ClusterInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Controller Controller information
//
// swagger:model NodeResponseRecordsItems0Controller
type NodeResponseRecordsItems0Controller struct {

	// A list of Flash-Cache devices. Only returned when requested by name.
	// Read Only: true
	FlashCache []*NodeResponseRecordsItems0ControllerFlashCacheItems0 `json:"flash_cache,omitempty"`

	// List of FRUs on the node. Only returned when requested by name.
	Frus []*NodeResponseRecordsItems0ControllerFrusItems0 `json:"frus,omitempty"`

	// Specifies whether the hardware is currently operating outside of its recommended temperature range. The hardware shuts down if the temperature exceeds critical thresholds.
	// Read Only: true
	// Enum: [over normal]
	OverTemperature string `json:"over_temperature,omitempty"`
}

// Validate validates this node response records items0 controller
func (m *NodeResponseRecordsItems0Controller) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFlashCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverTemperature(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateFlashCache(formats strfmt.Registry) error {
	if swag.IsZero(m.FlashCache) { // not required
		return nil
	}

	for i := 0; i < len(m.FlashCache); i++ {
		if swag.IsZero(m.FlashCache[i]) { // not required
			continue
		}

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateFrus(formats strfmt.Registry) error {
	if swag.IsZero(m.Frus) { // not required
		return nil
	}

	for i := 0; i < len(m.Frus); i++ {
		if swag.IsZero(m.Frus[i]) { // not required
			continue
		}

		if m.Frus[i] != nil {
			if err := m.Frus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["over","normal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum = append(nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0Controller
	// NodeResponseRecordsItems0Controller
	// over_temperature
	// OverTemperature
	// over
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerOverTemperatureOver captures enum value "over"
	NodeResponseRecordsItems0ControllerOverTemperatureOver string = "over"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0Controller
	// NodeResponseRecordsItems0Controller
	// over_temperature
	// OverTemperature
	// normal
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerOverTemperatureNormal captures enum value "normal"
	NodeResponseRecordsItems0ControllerOverTemperatureNormal string = "normal"
)

// prop value enum
func (m *NodeResponseRecordsItems0Controller) validateOverTemperatureEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerTypeOverTemperaturePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0Controller) validateOverTemperature(formats strfmt.Registry) error {
	if swag.IsZero(m.OverTemperature) { // not required
		return nil
	}

	// value enum
	if err := m.validateOverTemperatureEnum("controller"+"."+"over_temperature", "body", m.OverTemperature); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 controller based on the context it is used
func (m *NodeResponseRecordsItems0Controller) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFlashCache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverTemperature(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateFlashCache(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"flash_cache", "body", []*NodeResponseRecordsItems0ControllerFlashCacheItems0(m.FlashCache)); err != nil {
		return err
	}

	for i := 0; i < len(m.FlashCache); i++ {

		if m.FlashCache[i] != nil {
			if err := m.FlashCache[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "flash_cache" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateFrus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Frus); i++ {

		if m.Frus[i] != nil {
			if err := m.Frus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controller" + "." + "frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Controller) contextValidateOverTemperature(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "controller"+"."+"over_temperature", "body", string(m.OverTemperature)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Controller) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Controller) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Controller
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFlashCacheItems0 node response records items0 controller flash cache items0
//
// swagger:model NodeResponseRecordsItems0ControllerFlashCacheItems0
type NodeResponseRecordsItems0ControllerFlashCacheItems0 struct {

	// Size in bytes
	// Example: 1024000000000
	// Read Only: true
	Capacity int64 `json:"capacity,omitempty"`

	// firmware version
	// Example: NA05
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// hardware revision
	// Example: A1
	// Read Only: true
	HardwareRevision string `json:"hardware_revision,omitempty"`

	// model
	// Example: X1970A
	// Read Only: true
	Model string `json:"model,omitempty"`

	// part number
	// Example: 119-00207
	// Read Only: true
	PartNumber string `json:"part_number,omitempty"`

	// serial number
	// Example: A22P5061550000187
	// Read Only: true
	SerialNumber string `json:"serial_number,omitempty"`

	// slot
	// Example: 6-1
	// Read Only: true
	Slot string `json:"slot,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok erasing erased failed removed]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 controller flash cache items0
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","erasing","erased","failed","removed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum = append(nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateOk captures enum value "ok"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// erasing
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateErasing captures enum value "erasing"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateErasing string = "erasing"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// erased
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateErased captures enum value "erased"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateErased string = "erased"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// failed
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateFailed captures enum value "failed"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateFailed string = "failed"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// NodeResponseRecordsItems0ControllerFlashCacheItems0
	// state
	// State
	// removed
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFlashCacheItems0StateRemoved captures enum value "removed"
	NodeResponseRecordsItems0ControllerFlashCacheItems0StateRemoved string = "removed"
)

// prop value enum
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerFlashCacheItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 controller flash cache items0 based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHardwareRevision(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSlot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateCapacity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "capacity", "body", int64(m.Capacity)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateHardwareRevision(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "hardware_revision", "body", string(m.HardwareRevision)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model", "body", string(m.Model)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidatePartNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "part_number", "body", string(m.PartNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateSlot(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "slot", "body", string(m.Slot)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFlashCacheItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFlashCacheItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ControllerFrusItems0 node response records items0 controller frus items0
//
// swagger:model NodeResponseRecordsItems0ControllerFrusItems0
type NodeResponseRecordsItems0ControllerFrusItems0 struct {

	// id
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// state
	// Read Only: true
	// Enum: [ok error]
	State string `json:"state,omitempty"`

	// type
	// Read Only: true
	// Enum: [fan psu pcie disk nvs dimm controller]
	Type string `json:"type,omitempty"`
}

// Validate validates this node response records items0 controller frus items0
func (m *NodeResponseRecordsItems0ControllerFrusItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum = append(nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0StateOk captures enum value "ok"
	NodeResponseRecordsItems0ControllerFrusItems0StateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// state
	// State
	// error
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0StateError captures enum value "error"
	NodeResponseRecordsItems0ControllerFrusItems0StateError string = "error"
)

// prop value enum
func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerFrusItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fan","psu","pcie","disk","nvs","dimm","controller"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum = append(nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// fan
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeFan captures enum value "fan"
	NodeResponseRecordsItems0ControllerFrusItems0TypeFan string = "fan"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// psu
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypePsu captures enum value "psu"
	NodeResponseRecordsItems0ControllerFrusItems0TypePsu string = "psu"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// pcie
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypePcie captures enum value "pcie"
	NodeResponseRecordsItems0ControllerFrusItems0TypePcie string = "pcie"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// disk
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeDisk captures enum value "disk"
	NodeResponseRecordsItems0ControllerFrusItems0TypeDisk string = "disk"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// nvs
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeNvs captures enum value "nvs"
	NodeResponseRecordsItems0ControllerFrusItems0TypeNvs string = "nvs"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// dimm
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeDimm captures enum value "dimm"
	NodeResponseRecordsItems0ControllerFrusItems0TypeDimm string = "dimm"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0
	// NodeResponseRecordsItems0ControllerFrusItems0
	// type
	// Type
	// controller
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ControllerFrusItems0TypeController captures enum value "controller"
	NodeResponseRecordsItems0ControllerFrusItems0TypeController string = "controller"
)

// prop value enum
func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ControllerFrusItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 controller frus items0 based on the context it is used
func (m *NodeResponseRecordsItems0ControllerFrusItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ControllerFrusItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFrusItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ControllerFrusItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ControllerFrusItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Ha node response records items0 ha
//
// swagger:model NodeResponseRecordsItems0Ha
type NodeResponseRecordsItems0Ha struct {

	// Specifies whether giveback is automatically initiated when the node that owns the storage is ready.
	// Read Only: true
	AutoGiveback *bool `json:"auto_giveback,omitempty"`

	// Specifies whether or not storage failover is enabled.
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// giveback
	Giveback *NodeResponseRecordsItems0HaGiveback `json:"giveback,omitempty"`

	// Nodes in this node's High Availability (HA) group.
	// Read Only: true
	Partners []*NodeResponseRecordsItems0HaPartnersItems0 `json:"partners,omitempty"`

	// ports
	// Read Only: true
	Ports []*NodeResponseRecordsItems0HaPortsItems0 `json:"ports,omitempty"`

	// takeover
	Takeover *NodeResponseRecordsItems0HaTakeover `json:"takeover,omitempty"`
}

// Validate validates this node response records items0 ha
func (m *NodeResponseRecordsItems0Ha) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGiveback(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartners(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTakeover(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Ha) validateGiveback(formats strfmt.Registry) error {
	if swag.IsZero(m.Giveback) { // not required
		return nil
	}

	if m.Giveback != nil {
		if err := m.Giveback.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) validatePartners(formats strfmt.Registry) error {
	if swag.IsZero(m.Partners) { // not required
		return nil
	}

	for i := 0; i < len(m.Partners); i++ {
		if swag.IsZero(m.Partners[i]) { // not required
			continue
		}

		if m.Partners[i] != nil {
			if err := m.Partners[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) validateTakeover(formats strfmt.Registry) error {
	if swag.IsZero(m.Takeover) { // not required
		return nil
	}

	if m.Takeover != nil {
		if err := m.Takeover.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha based on the context it is used
func (m *NodeResponseRecordsItems0Ha) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGiveback(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartners(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTakeover(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateAutoGiveback(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"auto_giveback", "body", m.AutoGiveback); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateGiveback(ctx context.Context, formats strfmt.Registry) error {

	if m.Giveback != nil {
		if err := m.Giveback.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidatePartners(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"partners", "body", []*NodeResponseRecordsItems0HaPartnersItems0(m.Partners)); err != nil {
		return err
	}

	for i := 0; i < len(m.Partners); i++ {

		if m.Partners[i] != nil {
			if err := m.Partners[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "partners" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ha"+"."+"ports", "body", []*NodeResponseRecordsItems0HaPortsItems0(m.Ports)); err != nil {
		return err
	}

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ha" + "." + "ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NodeResponseRecordsItems0Ha) contextValidateTakeover(ctx context.Context, formats strfmt.Registry) error {

	if m.Takeover != nil {
		if err := m.Takeover.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Ha) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Ha) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Ha
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGiveback Represents the state of the node that is giving storage back to its HA partner.
//
// swagger:model NodeResponseRecordsItems0HaGiveback
type NodeResponseRecordsItems0HaGiveback struct {

	// failure
	Failure *NodeResponseRecordsItems0HaGivebackFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [nothing_to_giveback not_attempted in_progress failed]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 ha giveback
func (m *NodeResponseRecordsItems0HaGiveback) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0HaGivebackTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["nothing_to_giveback","not_attempted","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaGivebackTypeStatePropEnum = append(nodeResponseRecordsItems0HaGivebackTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// nothing_to_giveback
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateNothingToGiveback captures enum value "nothing_to_giveback"
	NodeResponseRecordsItems0HaGivebackStateNothingToGiveback string = "nothing_to_giveback"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// not_attempted
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateNotAttempted captures enum value "not_attempted"
	NodeResponseRecordsItems0HaGivebackStateNotAttempted string = "not_attempted"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// in_progress
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateInProgress captures enum value "in_progress"
	NodeResponseRecordsItems0HaGivebackStateInProgress string = "in_progress"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGiveback
	// NodeResponseRecordsItems0HaGiveback
	// state
	// State
	// failed
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaGivebackStateFailed captures enum value "failed"
	NodeResponseRecordsItems0HaGivebackStateFailed string = "failed"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaGiveback) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaGivebackTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"giveback"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha giveback based on the context it is used
func (m *NodeResponseRecordsItems0HaGiveback) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaGiveback) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "giveback" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGiveback) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGiveback) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGiveback
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaGivebackFailure Indicates the failure code and message.
//
// swagger:model NodeResponseRecordsItems0HaGivebackFailure
type NodeResponseRecordsItems0HaGivebackFailure struct {

	// Message code
	// Example: 852126
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate giveback. Run the \"storage failover show-giveback\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this node response records items0 ha giveback failure
func (m *NodeResponseRecordsItems0HaGivebackFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 ha giveback failure based on the context it is used
func (m *NodeResponseRecordsItems0HaGivebackFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaGivebackFailure) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaGivebackFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaPartnersItems0 node response records items0 ha partners items0
//
// swagger:model NodeResponseRecordsItems0HaPartnersItems0
type NodeResponseRecordsItems0HaPartnersItems0 struct {

	// links
	Links *NodeResponseRecordsItems0HaPartnersItems0Links `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 ha partners items0
func (m *NodeResponseRecordsItems0HaPartnersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha partners items0 based on the context it is used
func (m *NodeResponseRecordsItems0HaPartnersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaPartnersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaPartnersItems0Links node response records items0 ha partners items0 links
//
// swagger:model NodeResponseRecordsItems0HaPartnersItems0Links
type NodeResponseRecordsItems0HaPartnersItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 ha partners items0 links
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 ha partners items0 links based on the context it is used
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPartnersItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPartnersItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaPartnersItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaPortsItems0 node response records items0 ha ports items0
//
// swagger:model NodeResponseRecordsItems0HaPortsItems0
type NodeResponseRecordsItems0HaPortsItems0 struct {

	// HA port number
	// Example: 0
	// Read Only: true
	Number int64 `json:"number,omitempty"`

	// HA port state:
	// * <i>down</i> - Logical HA link is down.
	// * <i>initialized</i> - Logical HA link is initialized. The physical link is up, but the subnet manager hasn’t started to configure the port.
	// * <i>armed</i> - Logical HA link is armed. The physical link is up and the subnet manager started but did not yet complete configuring the port.
	// * <i>active</i> - Logical HA link is active.
	// * <i>reserved</i> - Logical HA link is active, but the physical link is down.
	//
	// Example: active
	// Read Only: true
	// Enum: [down initialized armed active reserved]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 ha ports items0
func (m *NodeResponseRecordsItems0HaPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["down","initialized","armed","active","reserved"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum = append(nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// down
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateDown captures enum value "down"
	NodeResponseRecordsItems0HaPortsItems0StateDown string = "down"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// initialized
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateInitialized captures enum value "initialized"
	NodeResponseRecordsItems0HaPortsItems0StateInitialized string = "initialized"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// armed
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateArmed captures enum value "armed"
	NodeResponseRecordsItems0HaPortsItems0StateArmed string = "armed"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// active
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateActive captures enum value "active"
	NodeResponseRecordsItems0HaPortsItems0StateActive string = "active"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0
	// NodeResponseRecordsItems0HaPortsItems0
	// state
	// State
	// reserved
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaPortsItems0StateReserved captures enum value "reserved"
	NodeResponseRecordsItems0HaPortsItems0StateReserved string = "reserved"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaPortsItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaPortsItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPortsItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha ports items0 based on the context it is used
func (m *NodeResponseRecordsItems0HaPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaPortsItems0) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "number", "body", int64(m.Number)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0HaPortsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaPortsItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaTakeover This represents the state of the node that is taking over storage from its HA partner.
//
// swagger:model NodeResponseRecordsItems0HaTakeover
type NodeResponseRecordsItems0HaTakeover struct {

	// failure
	Failure *NodeResponseRecordsItems0HaTakeoverFailure `json:"failure,omitempty"`

	// state
	// Example: failed
	// Enum: [not_possible not_attempted in_takeover in_progress failed]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 ha takeover
func (m *NodeResponseRecordsItems0HaTakeover) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaTakeover) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_possible","not_attempted","in_takeover","in_progress","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum = append(nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// not_possible
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateNotPossible captures enum value "not_possible"
	NodeResponseRecordsItems0HaTakeoverStateNotPossible string = "not_possible"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// not_attempted
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateNotAttempted captures enum value "not_attempted"
	NodeResponseRecordsItems0HaTakeoverStateNotAttempted string = "not_attempted"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// in_takeover
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateInTakeover captures enum value "in_takeover"
	NodeResponseRecordsItems0HaTakeoverStateInTakeover string = "in_takeover"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// in_progress
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateInProgress captures enum value "in_progress"
	NodeResponseRecordsItems0HaTakeoverStateInProgress string = "in_progress"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeover
	// NodeResponseRecordsItems0HaTakeover
	// state
	// State
	// failed
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0HaTakeoverStateFailed captures enum value "failed"
	NodeResponseRecordsItems0HaTakeoverStateFailed string = "failed"
)

// prop value enum
func (m *NodeResponseRecordsItems0HaTakeover) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0HaTakeoverTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaTakeover) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("ha"+"."+"takeover"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 ha takeover based on the context it is used
func (m *NodeResponseRecordsItems0HaTakeover) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0HaTakeover) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ha" + "." + "takeover" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeover) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeover) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaTakeover
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0HaTakeoverFailure Indicates the failure code and message.
//
// swagger:model NodeResponseRecordsItems0HaTakeoverFailure
type NodeResponseRecordsItems0HaTakeoverFailure struct {

	// Message code
	// Example: 852130
	Code int64 `json:"code,omitempty"`

	// Detailed message based on the state.
	// Example: Failed to initiate takeover. Run the \"storage failover show-takeover\" command for more information.
	Message string `json:"message,omitempty"`
}

// Validate validates this node response records items0 ha takeover failure
func (m *NodeResponseRecordsItems0HaTakeoverFailure) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 ha takeover failure based on the context it is used
func (m *NodeResponseRecordsItems0HaTakeoverFailure) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeoverFailure) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0HaTakeoverFailure) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0HaTakeoverFailure
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Links node response records items0 links
//
// swagger:model NodeResponseRecordsItems0Links
type NodeResponseRecordsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 links
func (m *NodeResponseRecordsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 links based on the context it is used
func (m *NodeResponseRecordsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterface The management interface of the node to be added. The subnet mask is set based on the management interface of the cluster or the managment interfaces of other nodes.
//
// swagger:model NodeResponseRecordsItems0ManagementInterface
type NodeResponseRecordsItems0ManagementInterface struct {

	// ip
	IP *NodeSetupIP `json:"ip,omitempty"`
}

// Validate validates this node response records items0 management interface
func (m *NodeResponseRecordsItems0ManagementInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 management interface based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("management_interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterfacesItems0 Network interface
//
// swagger:model NodeResponseRecordsItems0ManagementInterfacesItems0
type NodeResponseRecordsItems0ManagementInterfacesItems0 struct {

	// links
	Links *NodeResponseRecordsItems0ManagementInterfacesItems0Links `json:"_links,omitempty"`

	// ip
	IP *NodeResponseRecordsItems0ManagementInterfacesItems0IP `json:"ip,omitempty"`

	// The name of the interface.
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this node response records items0 management interfaces items0
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 management interfaces items0 based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterfacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterfacesItems0IP IP information
//
// swagger:model NodeResponseRecordsItems0ManagementInterfacesItems0IP
type NodeResponseRecordsItems0ManagementInterfacesItems0IP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this node response records items0 management interfaces items0 IP
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 management interfaces items0 IP based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0IP) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterfacesItems0IP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ManagementInterfacesItems0Links node response records items0 management interfaces items0 links
//
// swagger:model NodeResponseRecordsItems0ManagementInterfacesItems0Links
type NodeResponseRecordsItems0ManagementInterfacesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this node response records items0 management interfaces items0 links
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this node response records items0 management interfaces items0 links based on the context it is used
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ManagementInterfacesItems0Links) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ManagementInterfacesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessor node response records items0 service processor
//
// swagger:model NodeResponseRecordsItems0ServiceProcessor
type NodeResponseRecordsItems0ServiceProcessor struct {

	// Set to "true" to use DHCP to configure an IPv4 interface.
	DhcpEnabled bool `json:"dhcp_enabled,omitempty"`

	// The version of firmware installed.
	// Read Only: true
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// ipv4 interface
	IPV4Interface *NodeResponseRecordsItems0ServiceProcessorIPV4Interface `json:"ipv4_interface,omitempty"`

	// ipv6 interface
	IPV6Interface *NodeResponseRecordsItems0ServiceProcessorIPV6Interface `json:"ipv6_interface,omitempty"`

	// link status
	// Read Only: true
	// Enum: [up down disabled unknown]
	LinkStatus string `json:"link_status,omitempty"`

	// mac address
	// Read Only: true
	MacAddress string `json:"mac_address,omitempty"`

	// state
	// Read Only: true
	// Enum: [online offline degraded rebooting unknown updating node_offline sp_daemon_offline]
	State string `json:"state,omitempty"`
}

// Validate validates this node response records items0 service processor
func (m *NodeResponseRecordsItems0ServiceProcessor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIPV4Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV6Interface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateIPV4Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV4Interface) { // not required
		return nil
	}

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateIPV6Interface(formats strfmt.Registry) error {
	if swag.IsZero(m.IPV6Interface) { // not required
		return nil
	}

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

var nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down","disabled","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum = append(nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// up
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusUp captures enum value "up"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusUp string = "up"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// down
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusDown captures enum value "down"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusDown string = "down"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// disabled
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusDisabled captures enum value "disabled"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusDisabled string = "disabled"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// link_status
	// LinkStatus
	// unknown
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorLinkStatusUnknown captures enum value "unknown"
	NodeResponseRecordsItems0ServiceProcessorLinkStatusUnknown string = "unknown"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessor) validateLinkStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorTypeLinkStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateLinkStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.LinkStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkStatusEnum("service_processor"+"."+"link_status", "body", m.LinkStatus); err != nil {
		return err
	}

	return nil
}

var nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","offline","degraded","rebooting","unknown","updating","node_offline","sp_daemon_offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum = append(nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// online
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateOnline captures enum value "online"
	NodeResponseRecordsItems0ServiceProcessorStateOnline string = "online"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// offline
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateOffline captures enum value "offline"
	NodeResponseRecordsItems0ServiceProcessorStateOffline string = "offline"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// degraded
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateDegraded captures enum value "degraded"
	NodeResponseRecordsItems0ServiceProcessorStateDegraded string = "degraded"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// rebooting
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateRebooting captures enum value "rebooting"
	NodeResponseRecordsItems0ServiceProcessorStateRebooting string = "rebooting"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// unknown
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateUnknown captures enum value "unknown"
	NodeResponseRecordsItems0ServiceProcessorStateUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// updating
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateUpdating captures enum value "updating"
	NodeResponseRecordsItems0ServiceProcessorStateUpdating string = "updating"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// node_offline
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateNodeOffline captures enum value "node_offline"
	NodeResponseRecordsItems0ServiceProcessorStateNodeOffline string = "node_offline"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessor
	// NodeResponseRecordsItems0ServiceProcessor
	// state
	// State
	// sp_daemon_offline
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0ServiceProcessorStateSpDaemonOffline captures enum value "sp_daemon_offline"
	NodeResponseRecordsItems0ServiceProcessorStateSpDaemonOffline string = "sp_daemon_offline"
)

// prop value enum
func (m *NodeResponseRecordsItems0ServiceProcessor) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0ServiceProcessorTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("service_processor"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 service processor based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFirmwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV4Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPV6Interface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinkStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateFirmwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"firmware_version", "body", string(m.FirmwareVersion)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateIPV4Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV4Interface != nil {
		if err := m.IPV4Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv4_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateIPV6Interface(ctx context.Context, formats strfmt.Registry) error {

	if m.IPV6Interface != nil {
		if err := m.IPV6Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_processor" + "." + "ipv6_interface")
			}
			return err
		}
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateLinkStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"link_status", "body", string(m.LinkStatus)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateMacAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"mac_address", "body", string(m.MacAddress)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessor) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_processor"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessor) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorIPV4Interface Object to setup an interface along with its default router.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorIPV4Interface
type NodeResponseRecordsItems0ServiceProcessorIPV4Interface struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this node response records items0 service processor IP v4 interface
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 service processor IP v4 interface based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv4_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV4Interface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorIPV4Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0ServiceProcessorIPV6Interface Object to setup an interface along with its default router.
//
// swagger:model NodeResponseRecordsItems0ServiceProcessorIPV6Interface
type NodeResponseRecordsItems0ServiceProcessorIPV6Interface struct {

	// IPv4 or IPv6 address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// The IPv4 or IPv6 address of the default router.
	// Example: 10.1.1.1
	Gateway string `json:"gateway,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this node response records items0 service processor IP v6 interface
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv6_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 service processor IP v6 interface based on the context it is used
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_processor" + "." + "ipv6_interface" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0ServiceProcessorIPV6Interface) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0ServiceProcessorIPV6Interface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0VM node response records items0 VM
//
// swagger:model NodeResponseRecordsItems0VM
type NodeResponseRecordsItems0VM struct {

	// Cloud provider where the VM is hosted.
	// Read Only: true
	// Enum: [GoogleCloud AWS_S3 Azure_Cloud]
	ProviderType string `json:"provider_type,omitempty"`
}

// Validate validates this node response records items0 VM
func (m *NodeResponseRecordsItems0VM) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProviderType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nodeResponseRecordsItems0VmTypeProviderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GoogleCloud","AWS_S3","Azure_Cloud"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nodeResponseRecordsItems0VmTypeProviderTypePropEnum = append(nodeResponseRecordsItems0VmTypeProviderTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0VM
	// NodeResponseRecordsItems0VM
	// provider_type
	// ProviderType
	// GoogleCloud
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0VMProviderTypeGoogleCloud captures enum value "GoogleCloud"
	NodeResponseRecordsItems0VMProviderTypeGoogleCloud string = "GoogleCloud"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0VM
	// NodeResponseRecordsItems0VM
	// provider_type
	// ProviderType
	// AWS_S3
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0VMProviderTypeAWSS3 captures enum value "AWS_S3"
	NodeResponseRecordsItems0VMProviderTypeAWSS3 string = "AWS_S3"

	// BEGIN RIPPY DEBUGGING
	// NodeResponseRecordsItems0VM
	// NodeResponseRecordsItems0VM
	// provider_type
	// ProviderType
	// Azure_Cloud
	// END RIPPY DEBUGGING
	// NodeResponseRecordsItems0VMProviderTypeAzureCloud captures enum value "Azure_Cloud"
	NodeResponseRecordsItems0VMProviderTypeAzureCloud string = "Azure_Cloud"
)

// prop value enum
func (m *NodeResponseRecordsItems0VM) validateProviderTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nodeResponseRecordsItems0VmTypeProviderTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NodeResponseRecordsItems0VM) validateProviderType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProviderType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProviderTypeEnum("vm"+"."+"provider_type", "body", m.ProviderType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this node response records items0 VM based on the context it is used
func (m *NodeResponseRecordsItems0VM) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProviderType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0VM) contextValidateProviderType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vm"+"."+"provider_type", "body", string(m.ProviderType)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0VM) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0VM) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0VM
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NodeResponseRecordsItems0Version This returns the cluster version information.  When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.
//
// swagger:model NodeResponseRecordsItems0Version
type NodeResponseRecordsItems0Version struct {

	// The full cluster version string.
	// Example: NetApp Release 9.4.0: Sun Nov 05 18:20:57 UTC 2017
	// Read Only: true
	Full string `json:"full,omitempty"`

	// The generation portion of the version.
	// Example: 9
	// Read Only: true
	Generation int64 `json:"generation,omitempty"`

	// The major portion of the version.
	// Example: 4
	// Read Only: true
	Major int64 `json:"major,omitempty"`

	// The minor portion of the version.
	// Example: 0
	// Read Only: true
	Minor int64 `json:"minor,omitempty"`
}

// Validate validates this node response records items0 version
func (m *NodeResponseRecordsItems0Version) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this node response records items0 version based on the context it is used
func (m *NodeResponseRecordsItems0Version) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMajor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateFull(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"full", "body", string(m.Full)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateGeneration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"generation", "body", int64(m.Generation)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateMajor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"major", "body", int64(m.Major)); err != nil {
		return err
	}

	return nil
}

func (m *NodeResponseRecordsItems0Version) contextValidateMinor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version"+"."+"minor", "body", int64(m.Minor)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Version) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NodeResponseRecordsItems0Version) UnmarshalBinary(b []byte) error {
	var res NodeResponseRecordsItems0Version
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

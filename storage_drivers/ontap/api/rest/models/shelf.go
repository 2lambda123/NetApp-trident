// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Shelf shelf
//
// swagger:model shelf
type Shelf struct {

	// bays
	Bays []*ShelfBaysItems0 `json:"bays,omitempty"`

	// connection type
	// Example: sas
	// Enum: [unknown fc sas nvme]
	ConnectionType string `json:"connection_type,omitempty"`

	// disk count
	// Example: 12
	DiskCount int64 `json:"disk_count,omitempty"`

	// drawers
	Drawers []*ShelfDrawersItems0 `json:"drawers,omitempty"`

	// frus
	Frus []*ShelfFrusItems0 `json:"frus,omitempty"`

	// id
	// Example: 1
	ID string `json:"id,omitempty"`

	// internal
	Internal bool `json:"internal,omitempty"`

	// model
	// Example: DS2246
	Model string `json:"model,omitempty"`

	// module type
	// Example: iom6
	// Enum: [unknown iom6 iom6e iom12 iom12e iom12f nsm100 psm3e]
	ModuleType string `json:"module_type,omitempty"`

	// name
	// Example: 1.1
	Name string `json:"name,omitempty"`

	// paths
	Paths []*ShelfPathsItems0 `json:"paths,omitempty"`

	// ports
	Ports []*ShelfPortsItems0 `json:"ports,omitempty"`

	// serial number
	// Example: SHFMS1514000895
	SerialNumber string `json:"serial_number,omitempty"`

	// state
	// Example: ok
	// Enum: [unknown ok error]
	State string `json:"state,omitempty"`

	// uid
	// Example: 7777841915827391056
	UID string `json:"uid,omitempty"`
}

// Validate validates this shelf
func (m *Shelf) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBays(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrawers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModuleType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaths(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Shelf) validateBays(formats strfmt.Registry) error {
	if swag.IsZero(m.Bays) { // not required
		return nil
	}

	for i := 0; i < len(m.Bays); i++ {
		if swag.IsZero(m.Bays[i]) { // not required
			continue
		}

		if m.Bays[i] != nil {
			if err := m.Bays[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bays" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var shelfTypeConnectionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","fc","sas","nvme"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfTypeConnectionTypePropEnum = append(shelfTypeConnectionTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// connection_type
	// ConnectionType
	// unknown
	// END RIPPY DEBUGGING
	// ShelfConnectionTypeUnknown captures enum value "unknown"
	ShelfConnectionTypeUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// connection_type
	// ConnectionType
	// fc
	// END RIPPY DEBUGGING
	// ShelfConnectionTypeFc captures enum value "fc"
	ShelfConnectionTypeFc string = "fc"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// connection_type
	// ConnectionType
	// sas
	// END RIPPY DEBUGGING
	// ShelfConnectionTypeSas captures enum value "sas"
	ShelfConnectionTypeSas string = "sas"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// connection_type
	// ConnectionType
	// nvme
	// END RIPPY DEBUGGING
	// ShelfConnectionTypeNvme captures enum value "nvme"
	ShelfConnectionTypeNvme string = "nvme"
)

// prop value enum
func (m *Shelf) validateConnectionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfTypeConnectionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Shelf) validateConnectionType(formats strfmt.Registry) error {
	if swag.IsZero(m.ConnectionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateConnectionTypeEnum("connection_type", "body", m.ConnectionType); err != nil {
		return err
	}

	return nil
}

func (m *Shelf) validateDrawers(formats strfmt.Registry) error {
	if swag.IsZero(m.Drawers) { // not required
		return nil
	}

	for i := 0; i < len(m.Drawers); i++ {
		if swag.IsZero(m.Drawers[i]) { // not required
			continue
		}

		if m.Drawers[i] != nil {
			if err := m.Drawers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("drawers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shelf) validateFrus(formats strfmt.Registry) error {
	if swag.IsZero(m.Frus) { // not required
		return nil
	}

	for i := 0; i < len(m.Frus); i++ {
		if swag.IsZero(m.Frus[i]) { // not required
			continue
		}

		if m.Frus[i] != nil {
			if err := m.Frus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var shelfTypeModuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","iom6","iom6e","iom12","iom12e","iom12f","nsm100","psm3e"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfTypeModuleTypePropEnum = append(shelfTypeModuleTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// unknown
	// END RIPPY DEBUGGING
	// ShelfModuleTypeUnknown captures enum value "unknown"
	ShelfModuleTypeUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// iom6
	// END RIPPY DEBUGGING
	// ShelfModuleTypeIom6 captures enum value "iom6"
	ShelfModuleTypeIom6 string = "iom6"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// iom6e
	// END RIPPY DEBUGGING
	// ShelfModuleTypeIom6e captures enum value "iom6e"
	ShelfModuleTypeIom6e string = "iom6e"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// iom12
	// END RIPPY DEBUGGING
	// ShelfModuleTypeIom12 captures enum value "iom12"
	ShelfModuleTypeIom12 string = "iom12"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// iom12e
	// END RIPPY DEBUGGING
	// ShelfModuleTypeIom12e captures enum value "iom12e"
	ShelfModuleTypeIom12e string = "iom12e"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// iom12f
	// END RIPPY DEBUGGING
	// ShelfModuleTypeIom12f captures enum value "iom12f"
	ShelfModuleTypeIom12f string = "iom12f"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// nsm100
	// END RIPPY DEBUGGING
	// ShelfModuleTypeNsm100 captures enum value "nsm100"
	ShelfModuleTypeNsm100 string = "nsm100"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// module_type
	// ModuleType
	// psm3e
	// END RIPPY DEBUGGING
	// ShelfModuleTypePsm3e captures enum value "psm3e"
	ShelfModuleTypePsm3e string = "psm3e"
)

// prop value enum
func (m *Shelf) validateModuleTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfTypeModuleTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Shelf) validateModuleType(formats strfmt.Registry) error {
	if swag.IsZero(m.ModuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateModuleTypeEnum("module_type", "body", m.ModuleType); err != nil {
		return err
	}

	return nil
}

func (m *Shelf) validatePaths(formats strfmt.Registry) error {
	if swag.IsZero(m.Paths) { // not required
		return nil
	}

	for i := 0; i < len(m.Paths); i++ {
		if swag.IsZero(m.Paths[i]) { // not required
			continue
		}

		if m.Paths[i] != nil {
			if err := m.Paths[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("paths" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shelf) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var shelfTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfTypeStatePropEnum = append(shelfTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// state
	// State
	// unknown
	// END RIPPY DEBUGGING
	// ShelfStateUnknown captures enum value "unknown"
	ShelfStateUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// ShelfStateOk captures enum value "ok"
	ShelfStateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// shelf
	// Shelf
	// state
	// State
	// error
	// END RIPPY DEBUGGING
	// ShelfStateError captures enum value "error"
	ShelfStateError string = "error"
)

// prop value enum
func (m *Shelf) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Shelf) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this shelf based on the context it is used
func (m *Shelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBays(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrawers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaths(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Shelf) contextValidateBays(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Bays); i++ {

		if m.Bays[i] != nil {
			if err := m.Bays[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bays" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shelf) contextValidateDrawers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Drawers); i++ {

		if m.Drawers[i] != nil {
			if err := m.Drawers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("drawers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shelf) contextValidateFrus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Frus); i++ {

		if m.Frus[i] != nil {
			if err := m.Frus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("frus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shelf) contextValidatePaths(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Paths); i++ {

		if m.Paths[i] != nil {
			if err := m.Paths[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("paths" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Shelf) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Shelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Shelf) UnmarshalBinary(b []byte) error {
	var res Shelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfBaysItems0 shelf bays items0
//
// swagger:model ShelfBaysItems0
type ShelfBaysItems0 struct {

	// has disk
	HasDisk bool `json:"has_disk,omitempty"`

	// id
	// Example: 0
	ID int64 `json:"id,omitempty"`

	// state
	// Example: ok
	// Enum: [unknown ok error]
	State string `json:"state,omitempty"`

	// type
	// Example: single_disk
	// Enum: [unknown single_disk multi_lun]
	Type string `json:"type,omitempty"`
}

// Validate validates this shelf bays items0
func (m *ShelfBaysItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var shelfBaysItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfBaysItems0TypeStatePropEnum = append(shelfBaysItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfBaysItems0
	// ShelfBaysItems0
	// state
	// State
	// unknown
	// END RIPPY DEBUGGING
	// ShelfBaysItems0StateUnknown captures enum value "unknown"
	ShelfBaysItems0StateUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// ShelfBaysItems0
	// ShelfBaysItems0
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// ShelfBaysItems0StateOk captures enum value "ok"
	ShelfBaysItems0StateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ShelfBaysItems0
	// ShelfBaysItems0
	// state
	// State
	// error
	// END RIPPY DEBUGGING
	// ShelfBaysItems0StateError captures enum value "error"
	ShelfBaysItems0StateError string = "error"
)

// prop value enum
func (m *ShelfBaysItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfBaysItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfBaysItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var shelfBaysItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","single_disk","multi_lun"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfBaysItems0TypeTypePropEnum = append(shelfBaysItems0TypeTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfBaysItems0
	// ShelfBaysItems0
	// type
	// Type
	// unknown
	// END RIPPY DEBUGGING
	// ShelfBaysItems0TypeUnknown captures enum value "unknown"
	ShelfBaysItems0TypeUnknown string = "unknown"

	// BEGIN RIPPY DEBUGGING
	// ShelfBaysItems0
	// ShelfBaysItems0
	// type
	// Type
	// single_disk
	// END RIPPY DEBUGGING
	// ShelfBaysItems0TypeSingleDisk captures enum value "single_disk"
	ShelfBaysItems0TypeSingleDisk string = "single_disk"

	// BEGIN RIPPY DEBUGGING
	// ShelfBaysItems0
	// ShelfBaysItems0
	// type
	// Type
	// multi_lun
	// END RIPPY DEBUGGING
	// ShelfBaysItems0TypeMultiLun captures enum value "multi_lun"
	ShelfBaysItems0TypeMultiLun string = "multi_lun"
)

// prop value enum
func (m *ShelfBaysItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfBaysItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfBaysItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this shelf bays items0 based on context it is used
func (m *ShelfBaysItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ShelfBaysItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfBaysItems0) UnmarshalBinary(b []byte) error {
	var res ShelfBaysItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfDrawersItems0 shelf drawers items0
//
// swagger:model ShelfDrawersItems0
type ShelfDrawersItems0 struct {

	// closed
	Closed bool `json:"closed,omitempty"`

	// disk count
	// Example: 12
	DiskCount int64 `json:"disk_count,omitempty"`

	// error
	Error string `json:"error,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// part number
	// Example: 111-03071
	PartNumber string `json:"part_number,omitempty"`

	// serial number
	// Example: 21604008263
	SerialNumber string `json:"serial_number,omitempty"`

	// state
	// Example: ok
	// Enum: [ok error]
	State string `json:"state,omitempty"`
}

// Validate validates this shelf drawers items0
func (m *ShelfDrawersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var shelfDrawersItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfDrawersItems0TypeStatePropEnum = append(shelfDrawersItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfDrawersItems0
	// ShelfDrawersItems0
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// ShelfDrawersItems0StateOk captures enum value "ok"
	ShelfDrawersItems0StateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ShelfDrawersItems0
	// ShelfDrawersItems0
	// state
	// State
	// error
	// END RIPPY DEBUGGING
	// ShelfDrawersItems0StateError captures enum value "error"
	ShelfDrawersItems0StateError string = "error"
)

// prop value enum
func (m *ShelfDrawersItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfDrawersItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfDrawersItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this shelf drawers items0 based on context it is used
func (m *ShelfDrawersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ShelfDrawersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfDrawersItems0) UnmarshalBinary(b []byte) error {
	var res ShelfDrawersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfFrusItems0 shelf frus items0
//
// swagger:model ShelfFrusItems0
type ShelfFrusItems0 struct {

	// firmware version
	// Example: 191
	FirmwareVersion string `json:"firmware_version,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// part number
	// Example: 111-00690+A2
	PartNumber string `json:"part_number,omitempty"`

	// serial number
	// Example: 8000166294
	SerialNumber string `json:"serial_number,omitempty"`

	// state
	// Example: error
	// Enum: [ok error]
	State string `json:"state,omitempty"`

	// type
	// Example: module
	// Enum: [module psu]
	Type string `json:"type,omitempty"`
}

// Validate validates this shelf frus items0
func (m *ShelfFrusItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var shelfFrusItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfFrusItems0TypeStatePropEnum = append(shelfFrusItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfFrusItems0
	// ShelfFrusItems0
	// state
	// State
	// ok
	// END RIPPY DEBUGGING
	// ShelfFrusItems0StateOk captures enum value "ok"
	ShelfFrusItems0StateOk string = "ok"

	// BEGIN RIPPY DEBUGGING
	// ShelfFrusItems0
	// ShelfFrusItems0
	// state
	// State
	// error
	// END RIPPY DEBUGGING
	// ShelfFrusItems0StateError captures enum value "error"
	ShelfFrusItems0StateError string = "error"
)

// prop value enum
func (m *ShelfFrusItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfFrusItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfFrusItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var shelfFrusItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["module","psu"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfFrusItems0TypeTypePropEnum = append(shelfFrusItems0TypeTypePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfFrusItems0
	// ShelfFrusItems0
	// type
	// Type
	// module
	// END RIPPY DEBUGGING
	// ShelfFrusItems0TypeModule captures enum value "module"
	ShelfFrusItems0TypeModule string = "module"

	// BEGIN RIPPY DEBUGGING
	// ShelfFrusItems0
	// ShelfFrusItems0
	// type
	// Type
	// psu
	// END RIPPY DEBUGGING
	// ShelfFrusItems0TypePsu captures enum value "psu"
	ShelfFrusItems0TypePsu string = "psu"
)

// prop value enum
func (m *ShelfFrusItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfFrusItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfFrusItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this shelf frus items0 based on context it is used
func (m *ShelfFrusItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ShelfFrusItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfFrusItems0) UnmarshalBinary(b []byte) error {
	var res ShelfFrusItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfPathsItems0 Storage port
//
// swagger:model ShelfPathsItems0
type ShelfPathsItems0 struct {

	// links
	Links *ShelfPathsItems0Links `json:"_links,omitempty"`

	// name
	// Example: 2a
	Name string `json:"name,omitempty"`

	// node
	Node *ShelfPathsItems0Node `json:"node,omitempty"`
}

// Validate validates this shelf paths items0
func (m *ShelfPathsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ShelfPathsItems0) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this shelf paths items0 based on the context it is used
func (m *ShelfPathsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ShelfPathsItems0) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ShelfPathsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfPathsItems0) UnmarshalBinary(b []byte) error {
	var res ShelfPathsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfPathsItems0Links shelf paths items0 links
//
// swagger:model ShelfPathsItems0Links
type ShelfPathsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this shelf paths items0 links
func (m *ShelfPathsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this shelf paths items0 links based on the context it is used
func (m *ShelfPathsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ShelfPathsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfPathsItems0Links) UnmarshalBinary(b []byte) error {
	var res ShelfPathsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfPathsItems0Node shelf paths items0 node
//
// swagger:model ShelfPathsItems0Node
type ShelfPathsItems0Node struct {

	// links
	Links *ShelfPathsItems0NodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this shelf paths items0 node
func (m *ShelfPathsItems0Node) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0Node) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this shelf paths items0 node based on the context it is used
func (m *ShelfPathsItems0Node) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0Node) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ShelfPathsItems0Node) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfPathsItems0Node) UnmarshalBinary(b []byte) error {
	var res ShelfPathsItems0Node
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfPathsItems0NodeLinks shelf paths items0 node links
//
// swagger:model ShelfPathsItems0NodeLinks
type ShelfPathsItems0NodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this shelf paths items0 node links
func (m *ShelfPathsItems0NodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0NodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this shelf paths items0 node links based on the context it is used
func (m *ShelfPathsItems0NodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPathsItems0NodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ShelfPathsItems0NodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfPathsItems0NodeLinks) UnmarshalBinary(b []byte) error {
	var res ShelfPathsItems0NodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfPortsItems0 shelf ports items0
//
// swagger:model ShelfPortsItems0
type ShelfPortsItems0 struct {

	// cable
	Cable *ShelfPortsItems0Cable `json:"cable,omitempty"`

	// designator
	// Example: square
	// Enum: [circle square 1 2 3 4]
	Designator string `json:"designator,omitempty"`

	// id
	// Example: 0
	ID int64 `json:"id,omitempty"`

	// internal
	Internal bool `json:"internal,omitempty"`

	// mac address
	MacAddress string `json:"mac_address,omitempty"`

	// module id
	// Example: a
	// Enum: [a b]
	ModuleID string `json:"module_id,omitempty"`

	// remote
	Remote *ShelfPortsItems0Remote `json:"remote,omitempty"`

	// state
	// Example: connected
	// Enum: [connected disconnected error]
	State string `json:"state,omitempty"`

	// wwn
	// Example: 500A0980000B6C3F
	Wwn string `json:"wwn,omitempty"`
}

// Validate validates this shelf ports items0
func (m *ShelfPortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDesignator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModuleID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemote(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPortsItems0) validateCable(formats strfmt.Registry) error {
	if swag.IsZero(m.Cable) { // not required
		return nil
	}

	if m.Cable != nil {
		if err := m.Cable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cable")
			}
			return err
		}
	}

	return nil
}

var shelfPortsItems0TypeDesignatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["circle","square","1","2","3","4"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfPortsItems0TypeDesignatorPropEnum = append(shelfPortsItems0TypeDesignatorPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// designator
	// Designator
	// circle
	// END RIPPY DEBUGGING
	// ShelfPortsItems0DesignatorCircle captures enum value "circle"
	ShelfPortsItems0DesignatorCircle string = "circle"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// designator
	// Designator
	// square
	// END RIPPY DEBUGGING
	// ShelfPortsItems0DesignatorSquare captures enum value "square"
	ShelfPortsItems0DesignatorSquare string = "square"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// designator
	// Designator
	// 1
	// END RIPPY DEBUGGING
	// ShelfPortsItems0DesignatorNr1 captures enum value "1"
	ShelfPortsItems0DesignatorNr1 string = "1"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// designator
	// Designator
	// 2
	// END RIPPY DEBUGGING
	// ShelfPortsItems0DesignatorNr2 captures enum value "2"
	ShelfPortsItems0DesignatorNr2 string = "2"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// designator
	// Designator
	// 3
	// END RIPPY DEBUGGING
	// ShelfPortsItems0DesignatorNr3 captures enum value "3"
	ShelfPortsItems0DesignatorNr3 string = "3"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// designator
	// Designator
	// 4
	// END RIPPY DEBUGGING
	// ShelfPortsItems0DesignatorNr4 captures enum value "4"
	ShelfPortsItems0DesignatorNr4 string = "4"
)

// prop value enum
func (m *ShelfPortsItems0) validateDesignatorEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfPortsItems0TypeDesignatorPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfPortsItems0) validateDesignator(formats strfmt.Registry) error {
	if swag.IsZero(m.Designator) { // not required
		return nil
	}

	// value enum
	if err := m.validateDesignatorEnum("designator", "body", m.Designator); err != nil {
		return err
	}

	return nil
}

var shelfPortsItems0TypeModuleIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["a","b"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfPortsItems0TypeModuleIDPropEnum = append(shelfPortsItems0TypeModuleIDPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// module_id
	// ModuleID
	// a
	// END RIPPY DEBUGGING
	// ShelfPortsItems0ModuleIDA captures enum value "a"
	ShelfPortsItems0ModuleIDA string = "a"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// module_id
	// ModuleID
	// b
	// END RIPPY DEBUGGING
	// ShelfPortsItems0ModuleIDB captures enum value "b"
	ShelfPortsItems0ModuleIDB string = "b"
)

// prop value enum
func (m *ShelfPortsItems0) validateModuleIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfPortsItems0TypeModuleIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfPortsItems0) validateModuleID(formats strfmt.Registry) error {
	if swag.IsZero(m.ModuleID) { // not required
		return nil
	}

	// value enum
	if err := m.validateModuleIDEnum("module_id", "body", m.ModuleID); err != nil {
		return err
	}

	return nil
}

func (m *ShelfPortsItems0) validateRemote(formats strfmt.Registry) error {
	if swag.IsZero(m.Remote) { // not required
		return nil
	}

	if m.Remote != nil {
		if err := m.Remote.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote")
			}
			return err
		}
	}

	return nil
}

var shelfPortsItems0TypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["connected","disconnected","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shelfPortsItems0TypeStatePropEnum = append(shelfPortsItems0TypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// state
	// State
	// connected
	// END RIPPY DEBUGGING
	// ShelfPortsItems0StateConnected captures enum value "connected"
	ShelfPortsItems0StateConnected string = "connected"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// state
	// State
	// disconnected
	// END RIPPY DEBUGGING
	// ShelfPortsItems0StateDisconnected captures enum value "disconnected"
	ShelfPortsItems0StateDisconnected string = "disconnected"

	// BEGIN RIPPY DEBUGGING
	// ShelfPortsItems0
	// ShelfPortsItems0
	// state
	// State
	// error
	// END RIPPY DEBUGGING
	// ShelfPortsItems0StateError captures enum value "error"
	ShelfPortsItems0StateError string = "error"
)

// prop value enum
func (m *ShelfPortsItems0) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shelfPortsItems0TypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShelfPortsItems0) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this shelf ports items0 based on the context it is used
func (m *ShelfPortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemote(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShelfPortsItems0) contextValidateCable(ctx context.Context, formats strfmt.Registry) error {

	if m.Cable != nil {
		if err := m.Cable.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cable")
			}
			return err
		}
	}

	return nil
}

func (m *ShelfPortsItems0) contextValidateRemote(ctx context.Context, formats strfmt.Registry) error {

	if m.Remote != nil {
		if err := m.Remote.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remote")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ShelfPortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfPortsItems0) UnmarshalBinary(b []byte) error {
	var res ShelfPortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfPortsItems0Cable shelf ports items0 cable
//
// swagger:model ShelfPortsItems0Cable
type ShelfPortsItems0Cable struct {

	// identifier
	// Example: 500a0980000b6c3f-50000d1703544b80
	Identifier string `json:"identifier,omitempty"`

	// length
	// Example: 2m
	Length string `json:"length,omitempty"`

	// part number
	// Example: 112-00431+A0
	PartNumber string `json:"part_number,omitempty"`

	// serial number
	// Example: 616930439
	SerialNumber string `json:"serial_number,omitempty"`
}

// Validate validates this shelf ports items0 cable
func (m *ShelfPortsItems0Cable) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this shelf ports items0 cable based on context it is used
func (m *ShelfPortsItems0Cable) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ShelfPortsItems0Cable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfPortsItems0Cable) UnmarshalBinary(b []byte) error {
	var res ShelfPortsItems0Cable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ShelfPortsItems0Remote shelf ports items0 remote
//
// swagger:model ShelfPortsItems0Remote
type ShelfPortsItems0Remote struct {

	// chassis
	Chassis string `json:"chassis,omitempty"`

	// mac address
	MacAddress string `json:"mac_address,omitempty"`

	// phy
	// Example: 12
	Phy string `json:"phy,omitempty"`

	// port
	Port string `json:"port,omitempty"`

	// wwn
	// Example: 50000D1703544B80
	Wwn string `json:"wwn,omitempty"`
}

// Validate validates this shelf ports items0 remote
func (m *ShelfPortsItems0Remote) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this shelf ports items0 remote based on context it is used
func (m *ShelfPortsItems0Remote) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ShelfPortsItems0Remote) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShelfPortsItems0Remote) UnmarshalBinary(b []byte) error {
	var res ShelfPortsItems0Remote
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

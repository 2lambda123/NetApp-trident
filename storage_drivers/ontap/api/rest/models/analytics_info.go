// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// AnalyticsInfo File system analytics information summarizing all descendents of a specific directory.
//
// swagger:model analytics_info
type AnalyticsInfo struct {

	// by accessed time
	ByAccessedTime *AnalyticsInfoByAccessedTime `json:"by_accessed_time,omitempty"`

	// by modified time
	ByModifiedTime *AnalyticsInfoByModifiedTime `json:"by_modified_time,omitempty"`

	// Number of bytes used on-disk
	// Example: 15436648448
	BytesUsed int64 `json:"bytes_used,omitempty"`

	// Number of descendants
	// Example: 21134
	FileCount int64 `json:"file_count,omitempty"`

	// Number of sub directories
	// Example: 35
	SubdirCount int64 `json:"subdir_count,omitempty"`
}

// Validate validates this analytics info
func (m *AnalyticsInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateByAccessedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateByModifiedTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfo) validateByAccessedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ByAccessedTime) { // not required
		return nil
	}

	if m.ByAccessedTime != nil {
		if err := m.ByAccessedTime.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_accessed_time")
			}
			return err
		}
	}

	return nil
}

func (m *AnalyticsInfo) validateByModifiedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ByModifiedTime) { // not required
		return nil
	}

	if m.ByModifiedTime != nil {
		if err := m.ByModifiedTime.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_modified_time")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this analytics info based on the context it is used
func (m *AnalyticsInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateByAccessedTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateByModifiedTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfo) contextValidateByAccessedTime(ctx context.Context, formats strfmt.Registry) error {

	if m.ByAccessedTime != nil {
		if err := m.ByAccessedTime.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_accessed_time")
			}
			return err
		}
	}

	return nil
}

func (m *AnalyticsInfo) contextValidateByModifiedTime(ctx context.Context, formats strfmt.Registry) error {

	if m.ByModifiedTime != nil {
		if err := m.ByModifiedTime.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_modified_time")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AnalyticsInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AnalyticsInfo) UnmarshalBinary(b []byte) error {
	var res AnalyticsInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AnalyticsInfoByAccessedTime File system analytics information, broken down by date of last access.
//
// swagger:model AnalyticsInfoByAccessedTime
type AnalyticsInfoByAccessedTime struct {

	// bytes used
	BytesUsed *AnalyticsInfoByAccessedTimeBytesUsed `json:"bytes_used,omitempty"`
}

// Validate validates this analytics info by accessed time
func (m *AnalyticsInfoByAccessedTime) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBytesUsed(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByAccessedTime) validateBytesUsed(formats strfmt.Registry) error {
	if swag.IsZero(m.BytesUsed) { // not required
		return nil
	}

	if m.BytesUsed != nil {
		if err := m.BytesUsed.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_accessed_time" + "." + "bytes_used")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this analytics info by accessed time based on the context it is used
func (m *AnalyticsInfoByAccessedTime) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBytesUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByAccessedTime) contextValidateBytesUsed(ctx context.Context, formats strfmt.Registry) error {

	if m.BytesUsed != nil {
		if err := m.BytesUsed.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_accessed_time" + "." + "bytes_used")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AnalyticsInfoByAccessedTime) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AnalyticsInfoByAccessedTime) UnmarshalBinary(b []byte) error {
	var res AnalyticsInfoByAccessedTime
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AnalyticsInfoByAccessedTimeBytesUsed Number of bytes used on-disk, broken down by date of last access.
//
// swagger:model AnalyticsInfoByAccessedTimeBytesUsed
type AnalyticsInfoByAccessedTimeBytesUsed struct {

	// labels
	Labels AnalyticsHistogramByTimeLabels `json:"labels,omitempty"`

	// The newest time label with a non-zero histogram value.
	NewestLabel AnalyticsHistogramTimeLabel `json:"newest_label,omitempty"`

	// The oldest time label with a non-zero histogram value.
	OldestLabel AnalyticsHistogramTimeLabel `json:"oldest_label,omitempty"`

	// Percentages for this histogram
	// Example: ["0.1","11.24","0.18","15.75","0.75","83.5","0"]
	Percentages []float64 `json:"percentages,omitempty"`

	// Values for this histogram
	// Example: ["15925248","1735569408","27672576","2430595072","116105216","12889948160","0"]
	Values []int64 `json:"values,omitempty"`
}

// Validate validates this analytics info by accessed time bytes used
func (m *AnalyticsInfoByAccessedTimeBytesUsed) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewestLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOldestLabel(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByAccessedTimeBytesUsed) validateLabels(formats strfmt.Registry) error {
	if swag.IsZero(m.Labels) { // not required
		return nil
	}

	if err := m.Labels.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_accessed_time" + "." + "bytes_used" + "." + "labels")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByAccessedTimeBytesUsed) validateNewestLabel(formats strfmt.Registry) error {
	if swag.IsZero(m.NewestLabel) { // not required
		return nil
	}

	if err := m.NewestLabel.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_accessed_time" + "." + "bytes_used" + "." + "newest_label")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByAccessedTimeBytesUsed) validateOldestLabel(formats strfmt.Registry) error {
	if swag.IsZero(m.OldestLabel) { // not required
		return nil
	}

	if err := m.OldestLabel.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_accessed_time" + "." + "bytes_used" + "." + "oldest_label")
		}
		return err
	}

	return nil
}

// ContextValidate validate this analytics info by accessed time bytes used based on the context it is used
func (m *AnalyticsInfoByAccessedTimeBytesUsed) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNewestLabel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOldestLabel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByAccessedTimeBytesUsed) contextValidateLabels(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Labels.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_accessed_time" + "." + "bytes_used" + "." + "labels")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByAccessedTimeBytesUsed) contextValidateNewestLabel(ctx context.Context, formats strfmt.Registry) error {

	if err := m.NewestLabel.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_accessed_time" + "." + "bytes_used" + "." + "newest_label")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByAccessedTimeBytesUsed) contextValidateOldestLabel(ctx context.Context, formats strfmt.Registry) error {

	if err := m.OldestLabel.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_accessed_time" + "." + "bytes_used" + "." + "oldest_label")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AnalyticsInfoByAccessedTimeBytesUsed) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AnalyticsInfoByAccessedTimeBytesUsed) UnmarshalBinary(b []byte) error {
	var res AnalyticsInfoByAccessedTimeBytesUsed
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AnalyticsInfoByModifiedTime File system analytics information, broken down by date of last modification.
//
// swagger:model AnalyticsInfoByModifiedTime
type AnalyticsInfoByModifiedTime struct {

	// bytes used
	BytesUsed *AnalyticsInfoByModifiedTimeBytesUsed `json:"bytes_used,omitempty"`
}

// Validate validates this analytics info by modified time
func (m *AnalyticsInfoByModifiedTime) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBytesUsed(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByModifiedTime) validateBytesUsed(formats strfmt.Registry) error {
	if swag.IsZero(m.BytesUsed) { // not required
		return nil
	}

	if m.BytesUsed != nil {
		if err := m.BytesUsed.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_modified_time" + "." + "bytes_used")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this analytics info by modified time based on the context it is used
func (m *AnalyticsInfoByModifiedTime) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBytesUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByModifiedTime) contextValidateBytesUsed(ctx context.Context, formats strfmt.Registry) error {

	if m.BytesUsed != nil {
		if err := m.BytesUsed.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("by_modified_time" + "." + "bytes_used")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AnalyticsInfoByModifiedTime) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AnalyticsInfoByModifiedTime) UnmarshalBinary(b []byte) error {
	var res AnalyticsInfoByModifiedTime
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AnalyticsInfoByModifiedTimeBytesUsed Number of bytes used on-disk, broken down by date of last modification.
//
// swagger:model AnalyticsInfoByModifiedTimeBytesUsed
type AnalyticsInfoByModifiedTimeBytesUsed struct {

	// labels
	Labels AnalyticsHistogramByTimeLabels `json:"labels,omitempty"`

	// The newest time label with a non-zero histogram value.
	NewestLabel AnalyticsHistogramTimeLabel `json:"newest_label,omitempty"`

	// The oldest time label with a non-zero histogram value.
	OldestLabel AnalyticsHistogramTimeLabel `json:"oldest_label,omitempty"`

	// Percentages for this histogram
	// Example: ["0.1","11.24","0.18","15.75","0.75","83.5","0"]
	Percentages []float64 `json:"percentages,omitempty"`

	// Values for this histogram
	// Example: ["15925248","1735569408","27672576","2430595072","116105216","12889948160","0"]
	Values []int64 `json:"values,omitempty"`
}

// Validate validates this analytics info by modified time bytes used
func (m *AnalyticsInfoByModifiedTimeBytesUsed) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewestLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOldestLabel(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByModifiedTimeBytesUsed) validateLabels(formats strfmt.Registry) error {
	if swag.IsZero(m.Labels) { // not required
		return nil
	}

	if err := m.Labels.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_modified_time" + "." + "bytes_used" + "." + "labels")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByModifiedTimeBytesUsed) validateNewestLabel(formats strfmt.Registry) error {
	if swag.IsZero(m.NewestLabel) { // not required
		return nil
	}

	if err := m.NewestLabel.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_modified_time" + "." + "bytes_used" + "." + "newest_label")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByModifiedTimeBytesUsed) validateOldestLabel(formats strfmt.Registry) error {
	if swag.IsZero(m.OldestLabel) { // not required
		return nil
	}

	if err := m.OldestLabel.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_modified_time" + "." + "bytes_used" + "." + "oldest_label")
		}
		return err
	}

	return nil
}

// ContextValidate validate this analytics info by modified time bytes used based on the context it is used
func (m *AnalyticsInfoByModifiedTimeBytesUsed) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNewestLabel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOldestLabel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyticsInfoByModifiedTimeBytesUsed) contextValidateLabels(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Labels.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_modified_time" + "." + "bytes_used" + "." + "labels")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByModifiedTimeBytesUsed) contextValidateNewestLabel(ctx context.Context, formats strfmt.Registry) error {

	if err := m.NewestLabel.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_modified_time" + "." + "bytes_used" + "." + "newest_label")
		}
		return err
	}

	return nil
}

func (m *AnalyticsInfoByModifiedTimeBytesUsed) contextValidateOldestLabel(ctx context.Context, formats strfmt.Registry) error {

	if err := m.OldestLabel.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("by_modified_time" + "." + "bytes_used" + "." + "oldest_label")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AnalyticsInfoByModifiedTimeBytesUsed) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AnalyticsInfoByModifiedTimeBytesUsed) UnmarshalBinary(b []byte) error {
	var res AnalyticsInfoByModifiedTimeBytesUsed
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

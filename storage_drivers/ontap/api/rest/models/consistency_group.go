// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ConsistencyGroup consistency group
//
// swagger:model consistency_group
type ConsistencyGroup struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// A consistency group is a mutually exclusive aggregation of volumes or other consistency groups. A consistency group can only be associated with one direct parent consistency group.
	//
	// Max Items: 5
	// Min Items: 0
	// Unique: true
	ConsistencyGroups []*ConsistencyGroupConsistencyGroupsItems0 `json:"consistency_groups,omitempty"`

	// The LUNs array can be used to create or modify LUNs in a consistency group on a new or existing volume that is a member of the consistency group. LUNs are considered members of a consistency group if they are located on a volume that is a member of the consistency group.
	//
	// Max Items: 16
	// Min Items: 0
	// Unique: true
	Luns []*ConsistencyGroupLunsItems0 `json:"luns,omitempty"`

	// Name of the consistency group. The consistency group name must be unique within an SVM.<br/>
	// If not provided and the consistency group contains only one volume, the name will be generated based on the volume name. If the consistency group contains more than one volume, the name is required.
	//
	Name string `json:"name,omitempty"`

	// An NVMe namespace is a collection of addressable logical blocks presented to hosts connected to the SVM using the NVMe over Fabrics protocol.
	// In ONTAP, an NVMe namespace is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
	// An NVMe namespace is created to a specified size using thin or thick provisioning as determined by the volume on which it is created. NVMe namespaces support being cloned. An NVMe namespace cannot be renamed, resized, or moved to a different volume. NVMe namespaces do not support the assignment of a QoS policy for performance management, but a QoS policy can be assigned to the volume containing the namespace. See the NVMe namespace object model to learn more about each of the properties supported by the NVMe namespace REST API.<br/>
	// An NVMe namespace must be mapped to an NVMe subsystem to grant access to the subsystem's hosts. Hosts can then access the NVMe namespace and perform I/O using the NVMe over Fabrics protocol.
	//
	// Max Items: 16
	// Min Items: 0
	// Unique: true
	Namespaces []*ConsistencyGroupNamespacesItems0 `json:"namespaces,omitempty"`

	// parent consistency group
	ParentConsistencyGroup *ConsistencyGroupParentConsistencyGroup `json:"parent_consistency_group,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupProvisioningOptionsType `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupQosType `json:"qos,omitempty"`

	// Indicates whether or not replication has been enabled on this consistency group.
	//
	Replicated bool `json:"replicated,omitempty"`

	// Indicates whether or not this consistency group is the source for replication.
	//
	ReplicationSource bool `json:"replication_source,omitempty"`

	// restore to
	RestoreTo *ConsistencyGroupRestoreTo `json:"restore_to,omitempty"`

	// The Snapshot copy policy of the consistency group.<br/>
	// This is the dedicated consistency group Snapshot copy policy, not an aggregation of the volume granular Snapshot copy policy.
	//
	SnapshotPolicy *SnapshotPolicyReference `json:"snapshot_policy,omitempty"`

	// space
	Space *ConsistencyGroupSpaceType `json:"space,omitempty"`

	// svm
	Svm *ConsistencyGroupSvm `json:"svm,omitempty"`

	// tiering
	Tiering *ConsistencyGroupTieringType `json:"tiering,omitempty"`

	// The unique identifier of the consistency group. The UUID is generated by ONTAP when the consistency group is created.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`

	// A consistency group is a mutually exclusive aggregation of volumes or other consistency groups. A volume can only be associated with one direct parent consistency group.<br/>
	// The volumes array can be used to create new volumes in the consistency group, add existing volumes to the consistency group, or modify existing volumes that are already members of the consistency group.<br/>
	// The total number of volumes across all child consistency groups contained in a consistency group is constrained by the same limit.
	//
	// Max Items: 80
	// Min Items: 0
	// Unique: true
	Volumes []*ConsistencyGroupVolumesItems0 `json:"volumes,omitempty"`
}

// Validate validates this consistency group
func (m *ConsistencyGroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsistencyGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLuns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentConsistencyGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroup) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateConsistencyGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ConsistencyGroups) { // not required
		return nil
	}

	iConsistencyGroupsSize := int64(len(m.ConsistencyGroups))

	if err := validate.MinItems("consistency_groups", "body", iConsistencyGroupsSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("consistency_groups", "body", iConsistencyGroupsSize, 5); err != nil {
		return err
	}

	if err := validate.UniqueItems("consistency_groups", "body", m.ConsistencyGroups); err != nil {
		return err
	}

	for i := 0; i < len(m.ConsistencyGroups); i++ {
		if swag.IsZero(m.ConsistencyGroups[i]) { // not required
			continue
		}

		if m.ConsistencyGroups[i] != nil {
			if err := m.ConsistencyGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroup) validateLuns(formats strfmt.Registry) error {
	if swag.IsZero(m.Luns) { // not required
		return nil
	}

	iLunsSize := int64(len(m.Luns))

	if err := validate.MinItems("luns", "body", iLunsSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("luns", "body", iLunsSize, 16); err != nil {
		return err
	}

	if err := validate.UniqueItems("luns", "body", m.Luns); err != nil {
		return err
	}

	for i := 0; i < len(m.Luns); i++ {
		if swag.IsZero(m.Luns[i]) { // not required
			continue
		}

		if m.Luns[i] != nil {
			if err := m.Luns[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("luns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroup) validateNamespaces(formats strfmt.Registry) error {
	if swag.IsZero(m.Namespaces) { // not required
		return nil
	}

	iNamespacesSize := int64(len(m.Namespaces))

	if err := validate.MinItems("namespaces", "body", iNamespacesSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("namespaces", "body", iNamespacesSize, 16); err != nil {
		return err
	}

	if err := validate.UniqueItems("namespaces", "body", m.Namespaces); err != nil {
		return err
	}

	for i := 0; i < len(m.Namespaces); i++ {
		if swag.IsZero(m.Namespaces[i]) { // not required
			continue
		}

		if m.Namespaces[i] != nil {
			if err := m.Namespaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("namespaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroup) validateParentConsistencyGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentConsistencyGroup) { // not required
		return nil
	}

	if m.ParentConsistencyGroup != nil {
		if err := m.ParentConsistencyGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateRestoreTo(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreTo) { // not required
		return nil
	}

	if m.RestoreTo != nil {
		if err := m.RestoreTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	iVolumesSize := int64(len(m.Volumes))

	if err := validate.MinItems("volumes", "body", iVolumesSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("volumes", "body", iVolumesSize, 80); err != nil {
		return err
	}

	if err := validate.UniqueItems("volumes", "body", m.Volumes); err != nil {
		return err
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this consistency group based on the context it is used
func (m *ConsistencyGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConsistencyGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLuns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNamespaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParentConsistencyGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestoreTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroup) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateConsistencyGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ConsistencyGroups); i++ {

		if m.ConsistencyGroups[i] != nil {
			if err := m.ConsistencyGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroup) contextValidateLuns(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Luns); i++ {

		if m.Luns[i] != nil {
			if err := m.Luns[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("luns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroup) contextValidateNamespaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Namespaces); i++ {

		if m.Namespaces[i] != nil {
			if err := m.Namespaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("namespaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroup) contextValidateParentConsistencyGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentConsistencyGroup != nil {
		if err := m.ParentConsistencyGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateRestoreTo(ctx context.Context, formats strfmt.Registry) error {

	if m.RestoreTo != nil {
		if err := m.RestoreTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroup) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroup) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0 consistency group consistency groups items0
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0
type ConsistencyGroupConsistencyGroupsItems0 struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The LUNs array can be used to create or modify LUNs in a consistency group on a new or existing volume that is a member of the consistency group. LUNs are considered members of a consistency group if they are located on a volume that is a member of the consistency group.
	//
	// Max Items: 16
	// Min Items: 0
	// Unique: true
	Luns []*ConsistencyGroupConsistencyGroupsItems0LunsItems0 `json:"luns,omitempty"`

	// Name of the consistency group. The consistency group name must be unique within an SVM.<br/>
	// If not provided and the consistency group contains only one volume, the name will be generated based on the volume name. If the consistency group contains more than one volume, the name is required.
	//
	Name string `json:"name,omitempty"`

	// An NVMe namespace is a collection of addressable logical blocks presented to hosts connected to the SVM using the NVMe over Fabrics protocol.
	// In ONTAP, an NVMe namespace is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
	// An NVMe namespace is created to a specified size using thin or thick provisioning as determined by the volume on which it is created. NVMe namespaces support being cloned. An NVMe namespace cannot be renamed, resized, or moved to a different volume. NVMe namespaces do not support the assignment of a QoS policy for performance management, but a QoS policy can be assigned to the volume containing the namespace. See the NVMe namespace object model to learn more about each of the properties supported by the NVMe namespace REST API.<br/>
	// An NVMe namespace must be mapped to an NVMe subsystem to grant access to the subsystem's hosts. Hosts can then access the NVMe namespace and perform I/O using the NVMe over Fabrics protocol.
	//
	// Max Items: 16
	// Min Items: 0
	// Unique: true
	Namespaces []*ConsistencyGroupConsistencyGroupsItems0NamespacesItems0 `json:"namespaces,omitempty"`

	// parent consistency group
	ParentConsistencyGroup *ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup `json:"parent_consistency_group,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupConsistencyGroupsItems0Qos `json:"qos,omitempty"`

	// restore to
	RestoreTo *ConsistencyGroupConsistencyGroupsItems0RestoreTo `json:"restore_to,omitempty"`

	// The Snapshot copy policy of the consistency group.<br/>
	// This is the dedicated consistency group Snapshot copy policy, not an aggregation of the volume granular Snapshot copy policy.
	//
	SnapshotPolicy *SnapshotPolicyReference `json:"snapshot_policy,omitempty"`

	// space
	Space *ConsistencyGroupConsistencyGroupsItems0Space `json:"space,omitempty"`

	// svm
	Svm *ConsistencyGroupConsistencyGroupsItems0Svm `json:"svm,omitempty"`

	// tiering
	Tiering *ConsistencyGroupConsistencyGroupsItems0Tiering `json:"tiering,omitempty"`

	// The unique identifier of the consistency group. The UUID is generated by ONTAP when the consistency group is created.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`

	// A consistency group is a mutually exclusive aggregation of volumes or other consistency groups. A volume can only be associated with one direct parent consistency group.<br/>
	// The volumes array can be used to create new volumes in the consistency group, add existing volumes to the consistency group, or modify existing volumes that are already members of the consistency group.<br/>
	// The total number of volumes across all child consistency groups contained in a consistency group is constrained by the same limit.
	//
	// Max Items: 80
	// Min Items: 0
	// Unique: true
	Volumes []*ConsistencyGroupConsistencyGroupsItems0VolumesItems0 `json:"volumes,omitempty"`
}

// Validate validates this consistency group consistency groups items0
func (m *ConsistencyGroupConsistencyGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLuns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentConsistencyGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateLuns(formats strfmt.Registry) error {
	if swag.IsZero(m.Luns) { // not required
		return nil
	}

	iLunsSize := int64(len(m.Luns))

	if err := validate.MinItems("luns", "body", iLunsSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("luns", "body", iLunsSize, 16); err != nil {
		return err
	}

	if err := validate.UniqueItems("luns", "body", m.Luns); err != nil {
		return err
	}

	for i := 0; i < len(m.Luns); i++ {
		if swag.IsZero(m.Luns[i]) { // not required
			continue
		}

		if m.Luns[i] != nil {
			if err := m.Luns[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("luns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateNamespaces(formats strfmt.Registry) error {
	if swag.IsZero(m.Namespaces) { // not required
		return nil
	}

	iNamespacesSize := int64(len(m.Namespaces))

	if err := validate.MinItems("namespaces", "body", iNamespacesSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("namespaces", "body", iNamespacesSize, 16); err != nil {
		return err
	}

	if err := validate.UniqueItems("namespaces", "body", m.Namespaces); err != nil {
		return err
	}

	for i := 0; i < len(m.Namespaces); i++ {
		if swag.IsZero(m.Namespaces[i]) { // not required
			continue
		}

		if m.Namespaces[i] != nil {
			if err := m.Namespaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("namespaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateParentConsistencyGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentConsistencyGroup) { // not required
		return nil
	}

	if m.ParentConsistencyGroup != nil {
		if err := m.ParentConsistencyGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateRestoreTo(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreTo) { // not required
		return nil
	}

	if m.RestoreTo != nil {
		if err := m.RestoreTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	iVolumesSize := int64(len(m.Volumes))

	if err := validate.MinItems("volumes", "body", iVolumesSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("volumes", "body", iVolumesSize, 80); err != nil {
		return err
	}

	if err := validate.UniqueItems("volumes", "body", m.Volumes); err != nil {
		return err
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLuns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNamespaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParentConsistencyGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestoreTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateLuns(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Luns); i++ {

		if m.Luns[i] != nil {
			if err := m.Luns[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("luns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateNamespaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Namespaces); i++ {

		if m.Namespaces[i] != nil {
			if err := m.Namespaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("namespaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateParentConsistencyGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentConsistencyGroup != nil {
		if err := m.ParentConsistencyGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateRestoreTo(ctx context.Context, formats strfmt.Registry) error {

	if m.RestoreTo != nil {
		if err := m.RestoreTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0 A LUN is the logical representation of storage in a storage area network (SAN).<br/>
// In ONTAP, a LUN is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
// A LUN can be created to a specified size using thin or thick provisioning. A LUN can then be renamed, resized, cloned, and moved to a different volume. LUNs support the assignment of a quality of service (QoS) policy for performance management or a QoS policy can be assigned to the volume containing the LUN. See the LUN object model to learn more about each of the properties supported by the LUN REST API.<br/>
// A LUN must be mapped to an initiator group to grant access to the initiator group's initiators (client hosts). Initiators can then access the LUN and perform I/O over a Fibre Channel (FC) fabric using the Fibre Channel Protocol or a TCP/IP network using iSCSI.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0
type ConsistencyGroupConsistencyGroupsItems0LunsItems0 struct {

	// clone
	Clone *ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone `json:"clone,omitempty"`

	// A configurable comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// The time the LUN was created.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"create_time,omitempty"`

	// The enabled state of the LUN. LUNs can be disabled to prevent access to the LUN. Certain error conditions also cause the LUN to become disabled. If the LUN is disabled, you can consult the `state` property to determine if the LUN is administratively disabled (_offline_) or has become disabled as a result of an error. A LUN in an error condition can be brought online by setting the `enabled` property to _true_ or brought administratively offline by setting the `enabled` property to _false_. Upon creation, a LUN is enabled by default. Valid in PATCH.
	//
	Enabled bool `json:"enabled,omitempty"`

	// An array of LUN maps.<br/>
	// A LUN map is an association between a LUN and an initiator group. When a LUN is mapped to an initiator group, the initiator group's initiators are granted access to the LUN. The relationship between a LUN and an initiator group is many LUNs to many initiator groups.
	//
	LunMaps []*ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0 `json:"lun_maps,omitempty"`

	// The fully qualified path name of the LUN composed of the "/vol" prefix, the volume name, the qtree name (optional), and the base name of the LUN. Valid in POST and PATCH.
	//
	// Example: /vol/volume1/lun1
	Name string `json:"name,omitempty"`

	// The operating system type of the LUN.<br/>
	// Required in POST when creating a LUN that is not a clone of another. Disallowed in POST when creating a LUN clone.
	//
	// Enum: [aix hpux hyper_v linux netware openvms solaris solaris_efi vmware windows windows_2008 windows_gpt xen]
	OsType string `json:"os_type,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos `json:"qos,omitempty"`

	// The LUN serial number. The serial number is generated by ONTAP when the LUN is created.
	//
	// Read Only: true
	// Max Length: 12
	// Min Length: 12
	SerialNumber string `json:"serial_number,omitempty"`

	// space
	Space *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space `json:"space,omitempty"`

	// The unique identifier of the LUN.  The UUID is generated by ONTAP when the LUN is created.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLunMaps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateClone(formats strfmt.Registry) error {
	if swag.IsZero(m.Clone) { // not required
		return nil
	}

	if m.Clone != nil {
		if err := m.Clone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateCreateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("create_time", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateLunMaps(formats strfmt.Registry) error {
	if swag.IsZero(m.LunMaps) { // not required
		return nil
	}

	for i := 0; i < len(m.LunMaps); i++ {
		if swag.IsZero(m.LunMaps[i]) { // not required
			continue
		}

		if m.LunMaps[i] != nil {
			if err := m.LunMaps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var consistencyGroupConsistencyGroupsItems0LunsItems0TypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","hpux","hyper_v","linux","netware","openvms","solaris","solaris_efi","vmware","windows","windows_2008","windows_gpt","xen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0LunsItems0TypeOsTypePropEnum = append(consistencyGroupConsistencyGroupsItems0LunsItems0TypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeAix captures enum value "aix"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// hpux
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeHpux captures enum value "hpux"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeHpux string = "hpux"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// hyper_v
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeHyperv captures enum value "hyper_v"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeHyperv string = "hyper_v"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeLinux captures enum value "linux"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// netware
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeNetware captures enum value "netware"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeNetware string = "netware"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// openvms
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeOpenvms captures enum value "openvms"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeOpenvms string = "openvms"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// solaris
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeSolaris captures enum value "solaris"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeSolaris string = "solaris"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// solaris_efi
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeSolarisEfi captures enum value "solaris_efi"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeSolarisEfi string = "solaris_efi"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeVmware captures enum value "vmware"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeWindows captures enum value "windows"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeWindows string = "windows"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// windows_2008
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeWindows2008 captures enum value "windows_2008"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeWindows2008 string = "windows_2008"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// windows_gpt
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeWindowsGpt captures enum value "windows_gpt"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeWindowsGpt string = "windows_gpt"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0
	// os_type
	// OsType
	// xen
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeXen captures enum value "xen"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0OsTypeXen string = "xen"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0LunsItems0TypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateSerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.SerialNumber) { // not required
		return nil
	}

	if err := validate.MinLength("serial_number", "body", m.SerialNumber, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("serial_number", "body", m.SerialNumber, 12); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLunMaps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateClone(ctx context.Context, formats strfmt.Registry) error {

	if m.Clone != nil {
		if err := m.Clone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", m.CreateTime); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateLunMaps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LunMaps); i++ {

		if m.LunMaps[i] != nil {
			if err := m.LunMaps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone This sub-object is used in POST to create a new LUN as a clone of an existing LUN, or PATCH to overwrite an existing LUN as a clone of another. Setting a property in this sub-object indicates that a LUN clone is desired. Consider the following other properties when cloning a LUN: `auto_delete`, `qos_policy`, `space.guarantee.requested` and `space.scsi_thin_provisioning_support_enabled`.<br/>
// When used in a PATCH, the patched LUN's data is over-written as a clone of the source and the following properties are preserved from the patched LUN unless otherwise specified as part of the PATCH: `class`, `auto_delete`, `lun_maps`, `serial_number`, `status.state`, and `uuid`.<br/>
// Persistent reservations for the patched LUN are also preserved.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone
type ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone struct {

	// source
	Source *ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource `json:"source,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 clone
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 clone based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0Clone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource The source LUN for a LUN clone operation. This can be specified using property `clone.source.uuid` or `clone.source.name`. If both properties are supplied, they must refer to the same LUN.<br/>
// Valid in POST to create a new LUN as a clone of the source.<br/>
// Valid in PATCH to overwrite an existing LUN's data as a clone of another.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource
type ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource struct {

	// The fully qualified path name of the clone source LUN composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN. Valid in POST and PATCH.
	//
	// Example: /vol/volume1/lun1
	Name string `json:"name,omitempty"`

	// The unique identifier of the clone source LUN. Valid in POST and PATCH.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 clone source
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group consistency groups items0 luns items0 clone source based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0CloneSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0 A LUN map is an association between a LUN and an initiator group.<br/>
// When a LUN is mapped to an initiator group, the initiator group's initiators are granted access to the LUN. The relationship between a LUN and an initiator group is many LUNs to many initiator groups.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0
type ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0 struct {

	// igroup
	Igroup *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup `json:"igroup,omitempty"`

	// The logical unit number assigned to the LUN when mapped to the specified initiator group. The number is used to identify the LUN to initiators in the initiator group when communicating through the Fibre Channel Protocol or iSCSI. Optional in POST; if no value is provided, ONTAP assigns the lowest available value.
	//
	LogicalUnitNumber int64 `json:"logical_unit_number,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 lun maps items0
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIgroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0) validateIgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Igroup) { // not required
		return nil
	}

	if m.Igroup != nil {
		if err := m.Igroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 lun maps items0 based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0) contextValidateIgroup(ctx context.Context, formats strfmt.Registry) error {

	if m.Igroup != nil {
		if err := m.Igroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup The initiator group that directly owns the initiator, which is where modification of the initiator is supported. This property will only be populated when the initiator is a member of a nested initiator group.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
type ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup struct {

	// A comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Separate igroup definitions to include in this igroup.
	//
	Igroups []*ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0 `json:"igroups,omitempty"`

	// The initiators that are members of the group.
	//
	Initiators []*ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0 `json:"initiators,omitempty"`

	// The name of the initiator group. Required in POST; optional in PATCH.
	//
	// Example: igroup1
	// Max Length: 96
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// The host operating system of the initiator group. All initiators in the group should be hosts of the same operating system. Required in POST; optional in PATCH.
	//
	// Enum: [aix hpux hyper_v linux netware openvms solaris vmware windows xen]
	OsType string `json:"os_type,omitempty"`

	// The protocols supported by the initiator group. This restricts the type of initiators that can be added to the initiator group. Optional in POST; if not supplied, this defaults to _mixed_.<br/>
	// The protocol of an initiator group cannot be changed after creation of the group.
	//
	// Enum: [fcp iscsi mixed]
	Protocol *string `json:"protocol,omitempty"`

	// The unique identifier of the initiator group.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 lun maps items0 igroup
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitiators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("igroup"+"."+"comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("igroup"+"."+"comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateIgroups(formats strfmt.Registry) error {
	if swag.IsZero(m.Igroups) { // not required
		return nil
	}

	for i := 0; i < len(m.Igroups); i++ {
		if swag.IsZero(m.Igroups[i]) { // not required
			continue
		}

		if m.Igroups[i] != nil {
			if err := m.Igroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "igroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateInitiators(formats strfmt.Registry) error {
	if swag.IsZero(m.Initiators) { // not required
		return nil
	}

	for i := 0; i < len(m.Initiators); i++ {
		if swag.IsZero(m.Initiators[i]) { // not required
			continue
		}

		if m.Initiators[i] != nil {
			if err := m.Initiators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "initiators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("igroup"+"."+"name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("igroup"+"."+"name", "body", m.Name, 96); err != nil {
		return err
	}

	return nil
}

var consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","hpux","hyper_v","linux","netware","openvms","solaris","vmware","windows","xen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeOsTypePropEnum = append(consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeAix captures enum value "aix"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// hpux
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeHpux captures enum value "hpux"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeHpux string = "hpux"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// hyper_v
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeHyperv captures enum value "hyper_v"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeHyperv string = "hyper_v"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeLinux captures enum value "linux"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// netware
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeNetware captures enum value "netware"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeNetware string = "netware"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// openvms
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeOpenvms captures enum value "openvms"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeOpenvms string = "openvms"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// solaris
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeSolaris captures enum value "solaris"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeSolaris string = "solaris"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeVmware captures enum value "vmware"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeWindows captures enum value "windows"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeWindows string = "windows"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// xen
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeXen captures enum value "xen"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupOsTypeXen string = "xen"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("igroup"+"."+"os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

var consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fcp","iscsi","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeProtocolPropEnum = append(consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeProtocolPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// protocol
	// Protocol
	// fcp
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupProtocolFcp captures enum value "fcp"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupProtocolFcp string = "fcp"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// protocol
	// Protocol
	// iscsi
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupProtocolIscsi captures enum value "iscsi"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupProtocolIscsi string = "iscsi"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	// protocol
	// Protocol
	// mixed
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupProtocolMixed captures enum value "mixed"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupProtocolMixed string = "mixed"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("igroup"+"."+"protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 lun maps items0 igroup based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIgroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInitiators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) contextValidateIgroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Igroups); i++ {

		if m.Igroups[i] != nil {
			if err := m.Igroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "igroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) contextValidateInitiators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Initiators); i++ {

		if m.Initiators[i] != nil {
			if err := m.Initiators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "initiators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "igroup"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0Igroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0 consistency group consistency groups items0 luns items0 lun maps items0 igroup igroups items0
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0
type ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0 struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The name of the initiator group.
	//
	// Example: igroup1
	// Max Length: 96
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// The unique identifier of the initiator group.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 lun maps items0 igroup igroups items0
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 96); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 lun maps items0 igroup igroups items0 based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupIgroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0 The initiators that are members of the initiator group.
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0
type ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0 struct {

	// A comment available for use by the administrator.
	//
	// Example: my comment
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Name of initiator that is a member of the initiator group.
	//
	// Example: iqn.1998-01.com.corp.iscsi:name1
	Name string `json:"name,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 lun maps items0 igroup initiators items0
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group consistency groups items0 luns items0 lun maps items0 igroup initiators items0 based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0LunMapsItems0IgroupInitiatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions
type ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions struct {

	// Operation to perform
	// Enum: [create]
	Action string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count int64 `json:"count,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 provisioning options
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptionsTypeActionPropEnum = append(consistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptionsActionCreate string = "create"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group consistency groups items0 luns items0 provisioning options based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0ProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos consistency group consistency groups items0 luns items0 qos
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos
type ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos struct {

	// policy
	Policy *ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy `json:"policy,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 qos
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 qos based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0Qos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy The QoS policy
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy
type ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 qos policy
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 qos policy based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0Space The storage space related properties of the LUN.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0Space
type ConsistencyGroupConsistencyGroupsItems0LunsItems0Space struct {

	// guarantee
	Guarantee *ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee `json:"guarantee,omitempty"`

	// The total provisioned size of the LUN. The LUN size can be increased but not reduced using the REST interface.
	// The maximum and minimum sizes listed here are the absolute maximum and absolute minimum sizes, in bytes. The actual minimum and maxiumum sizes vary depending on the ONTAP version, ONTAP platform, and the available space in the containing volume and aggregate.
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	// Example: 1073741824
	// Maximum: 1.40737488355328e+14
	// Minimum: 4096
	Size int64 `json:"size,omitempty"`

	// The amount of space consumed by the main data stream of the LUN.<br/>
	// This value is the total space consumed in the volume by the LUN, including filesystem overhead, but excluding prefix and suffix streams. Due to internal filesystem overhead and the many ways SAN filesystems and applications utilize blocks within a LUN, this value does not necessarily reflect actual consumption/availability from the perspective of the filesystem or application. Without specific knowledge of how the LUN blocks are utilized outside of ONTAP, this property should not be used as an indicator for an out-of-space condition.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	Used int64 `json:"used,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 space
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGuarantee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space) validateGuarantee(formats strfmt.Registry) error {
	if swag.IsZero(m.Guarantee) { // not required
		return nil
	}

	if m.Guarantee != nil {
		if err := m.Guarantee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := validate.MinimumInt("space"+"."+"size", "body", m.Size, 4096, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("space"+"."+"size", "body", m.Size, 1.40737488355328e+14, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 luns items0 space based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGuarantee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space) contextValidateGuarantee(ctx context.Context, formats strfmt.Registry) error {

	if m.Guarantee != nil {
		if err := m.Guarantee.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0Space) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0Space
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee Properties that request and report the space guarantee for the LUN.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee
type ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee struct {

	// The requested space reservation policy for the LUN. If _true_, a space reservation is requested for the LUN; if _false_, the LUN is thin provisioned. Guaranteeing a space reservation request for a LUN requires that the volume in which the LUN resides is also space reserved and that the fractional reserve for the volume is 100%. Valid in POST and PATCH.
	//
	Requested *bool `json:"requested,omitempty"`

	// Reports if the LUN is space guaranteed.<br/>
	// If _true_, a space guarantee is requested and the containing volume and aggregate support the request. If _false_, a space guarantee is not requested or a space guarantee is requested and either the containing volume or aggregate do not support the request.
	//
	Reserved bool `json:"reserved,omitempty"`
}

// Validate validates this consistency group consistency groups items0 luns items0 space guarantee
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group consistency groups items0 luns items0 space guarantee based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0LunsItems0SpaceGuarantee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0 An NVMe namespace is a collection of addressable logical blocks presented to hosts connected to the storage virtual machine using the NVMe over Fabrics protocol.<br/>
// In ONTAP, an NVMe namespace is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
// An NVMe namespace is created to a specified size using thin or thick provisioning as determined by the volume on which it is created. NVMe namespaces support being cloned. An NVMe namespace cannot be renamed, resized, or moved to a different volume. NVMe namespaces do not support the assignment of a QoS policy for performance management, but a QoS policy can be assigned to the volume containing the namespace. See the NVMe namespace object model to learn more about each of the properties supported by the NVMe namespace REST API.<br/>
// An NVMe namespace must be mapped to an NVMe subsystem to grant access to the subsystem's hosts. Hosts can then access the NVMe namespace and perform I/O using the NVMe over Fabrics protocol.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
type ConsistencyGroupConsistencyGroupsItems0NamespacesItems0 struct {

	// This property marks the NVMe namespace for auto deletion when the volume containing the namespace runs out of space. This is most commonly set on namespace clones.<br/>
	// When set to _true_, the NVMe namespace becomes eligible for automatic deletion when the volume runs out of space. Auto deletion only occurs when the volume containing the namespace is also configured for auto deletion and free space in the volume decreases below a particular threshold.<br/>
	// This property is optional in POST and PATCH. The default value for a new NVMe namespace is _false_.<br/>
	// There is an added cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// A configurable comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// The time the NVMe namespace was created.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"create_time,omitempty"`

	// The enabled state of the NVMe namespace. Certain error conditions cause the namespace to become disabled. If the namespace is disabled, you can check the `state` property to determine what error disabled the namespace. An NVMe namespace is enabled automatically when it is created.
	//
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// The fully qualified path name of the NVMe namespace composed of a "/vol" prefix, the volume name, the (optional) qtree name and base name of the namespace. Valid in POST.<br/>
	// NVMe namespaces do not support rename, or movement between volumes.
	//
	// Example: /vol/volume1/qtree1/namespace1
	Name string `json:"name,omitempty"`

	// The operating system type of the NVMe namespace.<br/>
	// Required in POST when creating an NVMe namespace that is not a clone of another. Disallowed in POST when creating a namespace clone.
	//
	// Enum: [aix linux vmware windows]
	OsType string `json:"os_type,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions `json:"provisioning_options,omitempty"`

	// The NVMe subsystem with which the NVMe namespace is associated. A namespace can be mapped to zero (0) or one (1) subsystems.<br/>
	// There is an added cost to retrieving property values for `subsystem_map`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter.
	//
	SubsystemMap []*ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0 `json:"subsystem_map,omitempty"`

	// The unique identifier of the NVMe namespace.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 namespaces items0
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubsystemMap(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) validateCreateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("create_time", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var consistencyGroupConsistencyGroupsItems0NamespacesItems0TypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","linux","vmware","windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0NamespacesItems0TypeOsTypePropEnum = append(consistencyGroupConsistencyGroupsItems0NamespacesItems0TypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeAix captures enum value "aix"
	ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeLinux captures enum value "linux"
	ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeVmware captures enum value "vmware"
	ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeWindows captures enum value "windows"
	ConsistencyGroupConsistencyGroupsItems0NamespacesItems0OsTypeWindows string = "windows"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0NamespacesItems0TypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) validateSubsystemMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SubsystemMap) { // not required
		return nil
	}

	for i := 0; i < len(m.SubsystemMap); i++ {
		if swag.IsZero(m.SubsystemMap[i]) { // not required
			continue
		}

		if m.SubsystemMap[i] != nil {
			if err := m.SubsystemMap[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subsystem_map" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 namespaces items0 based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubsystemMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", m.CreateTime); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) contextValidateSubsystemMap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SubsystemMap); i++ {

		if m.SubsystemMap[i] != nil {
			if err := m.SubsystemMap[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subsystem_map" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0NamespacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions
type ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions struct {

	// Operation to perform
	// Enum: [create]
	Action string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count int64 `json:"count,omitempty"`
}

// Validate validates this consistency group consistency groups items0 namespaces items0 provisioning options
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptionsTypeActionPropEnum = append(consistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptionsActionCreate string = "create"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group consistency groups items0 namespaces items0 provisioning options based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0NamespacesItems0ProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0 The NVMe subsystem with which the NVMe namespace is associated. A namespace can be mapped to zero (0) or one (1) subsystems.<br/>
// There is an added cost to retrieving property values for `subsystem_map`.
// They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0
type ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0 struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The Asymmetric Namespace Access Group ID (ANAGRPID) of the NVMe namespace.<br/>
	// The format for an ANAGRPID is 8 hexadecimal digits (zero-filled) followed by a lower case "h".
	//
	// Example: 00103050h
	Anagrpid string `json:"anagrpid,omitempty"`

	// The NVMe namespace identifier. This is an identifier used by an NVMe controller to provide access to the NVMe namespace.<br/>
	// The format for an NVMe namespace identifier is 8 hexadecimal digits (zero-filled) followed by a lower case "h".
	//
	// Example: 00000001h
	Nsid string `json:"nsid,omitempty"`

	// The NVMe subsystem to which the NVMe namespace is mapped.
	//
	Subsystem *NvmeSubsystemReference `json:"subsystem,omitempty"`
}

// Validate validates this consistency group consistency groups items0 namespaces items0 subsystem map items0
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubsystem(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) validateSubsystem(formats strfmt.Registry) error {
	if swag.IsZero(m.Subsystem) { // not required
		return nil
	}

	if m.Subsystem != nil {
		if err := m.Subsystem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subsystem")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 namespaces items0 subsystem map items0 based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubsystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) contextValidateSubsystem(ctx context.Context, formats strfmt.Registry) error {

	if m.Subsystem != nil {
		if err := m.Subsystem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subsystem")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0NamespacesItems0SubsystemMapItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup The parent consistency group.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup
type ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The name of the consistency group.
	// Example: my_consistency_group
	Name string `json:"name,omitempty"`

	// The unique identifier of the consistency group.
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 parent consistency group
func (m *ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 parent consistency group based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0ParentConsistencyGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions
type ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions struct {

	// Operation to perform
	// Enum: [create]
	Action string `json:"action,omitempty"`

	// storage service
	StorageService *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService `json:"storage_service,omitempty"`
}

// Validate validates this consistency group consistency groups items0 provisioning options
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0ProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0ProvisioningOptionsTypeActionPropEnum = append(consistencyGroupConsistencyGroupsItems0ProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsActionCreate string = "create"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0ProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 provisioning options based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0ProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService Determines the placement of any storage object created during this operation.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
type ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService struct {

	// Storage service name. If not specified, the default value is the most performant for the platform.
	//
	// Enum: [extreme performance value]
	Name string `json:"name,omitempty"`
}

// Validate validates this consistency group consistency groups items0 provisioning options storage service
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceTypeNamePropEnum = append(consistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
	// name
	// Name
	// extreme
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceNameExtreme captures enum value "extreme"
	ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceNameExtreme string = "extreme"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
	// name
	// Name
	// performance
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceNamePerformance captures enum value "performance"
	ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceNamePerformance string = "performance"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
	// name
	// Name
	// value
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceNameValue captures enum value "value"
	ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceNameValue string = "value"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("provisioning_options"+"."+"storage_service"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group consistency groups items0 provisioning options storage service based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0ProvisioningOptionsStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0Qos consistency group consistency groups items0 qos
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0Qos
type ConsistencyGroupConsistencyGroupsItems0Qos struct {

	// policy
	Policy *ConsistencyGroupConsistencyGroupsItems0QosPolicy `json:"policy,omitempty"`
}

// Validate validates this consistency group consistency groups items0 qos
func (m *ConsistencyGroupConsistencyGroupsItems0Qos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0Qos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 qos based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0Qos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0Qos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Qos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Qos) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0Qos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0QosPolicy The QoS policy
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0QosPolicy
type ConsistencyGroupConsistencyGroupsItems0QosPolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 qos policy
func (m *ConsistencyGroupConsistencyGroupsItems0QosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0QosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 qos policy based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0QosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0QosPolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0RestoreTo Use to restore a consistency group to a previous Snapshot copy
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0RestoreTo
type ConsistencyGroupConsistencyGroupsItems0RestoreTo struct {

	// snapshot
	Snapshot *ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot `json:"snapshot,omitempty"`
}

// Validate validates this consistency group consistency groups items0 restore to
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0RestoreTo) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 restore to based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0RestoreTo) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {
		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreTo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreTo) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0RestoreTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot A consistency group's Snapshot copy
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot
type ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot struct {

	// The name of the consistency group's Snapshot copy to restore to.
	Name string `json:"name,omitempty"`

	// The UUID of the consistency group's Snapshot copy to restore to.
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 restore to snapshot
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group consistency groups items0 restore to snapshot based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0RestoreToSnapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0Space Space information for the consistency group.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0Space
type ConsistencyGroupConsistencyGroupsItems0Space struct {

	// The amount of space available in the consistency group, in bytes.<br/>
	//
	// Example: 5737418
	Available int64 `json:"available,omitempty"`

	// The total provisioned size of the consistency group, in bytes.<br/>
	//
	// Example: 1073741824
	Size int64 `json:"size,omitempty"`

	// The amount of space consumed in the consistency group, in bytes.<br/>
	//
	// Example: 5737418
	Used int64 `json:"used,omitempty"`
}

// Validate validates this consistency group consistency groups items0 space
func (m *ConsistencyGroupConsistencyGroupsItems0Space) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group consistency groups items0 space based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0Space) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Space) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Space) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0Space
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0Svm The Storage Virtual Machine (SVM) in which the consistency group is located.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0Svm
type ConsistencyGroupConsistencyGroupsItems0Svm struct {

	// links
	Links *ConsistencyGroupConsistencyGroupsItems0SvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 svm
func (m *ConsistencyGroupConsistencyGroupsItems0Svm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0Svm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 svm based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0Svm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0Svm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Svm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Svm) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0Svm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0SvmLinks consistency group consistency groups items0 svm links
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0SvmLinks
type ConsistencyGroupConsistencyGroupsItems0SvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this consistency group consistency groups items0 svm links
func (m *ConsistencyGroupConsistencyGroupsItems0SvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0SvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 svm links based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0SvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0SvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0SvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0SvmLinks) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0SvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0Tiering The tiering placement and policy definitions for volumes in this consistency group.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0Tiering
type ConsistencyGroupConsistencyGroupsItems0Tiering struct {

	// Storage tiering placement rules for the object.
	// Enum: [allowed best_effort disallowed required]
	Control string `json:"control,omitempty"`

	// Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold.
	// <br>FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br/>all &dash; Allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br/>auto &dash; Allows tiering of both snapshot and active file system user data to the cloud store<br/>none &dash; Volume blocks are not be tiered to the cloud store.<br/>snapshot_only &dash; Allows tiering of only the volume Snapshot copies not associated with the active file system.
	// <br>The default tiering policy is "snapshot-only" for a FlexVol volume and "none" for a FlexGroup volume. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy it is 31 days.
	//
	// Enum: [all auto backup none snapshot_only]
	Policy string `json:"policy,omitempty"`
}

// Validate validates this consistency group consistency groups items0 tiering
func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0TieringTypeControlPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["allowed","best_effort","disallowed","required"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0TieringTypeControlPropEnum = append(consistencyGroupConsistencyGroupsItems0TieringTypeControlPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// control
	// Control
	// allowed
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringControlAllowed captures enum value "allowed"
	ConsistencyGroupConsistencyGroupsItems0TieringControlAllowed string = "allowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// control
	// Control
	// best_effort
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringControlBestEffort captures enum value "best_effort"
	ConsistencyGroupConsistencyGroupsItems0TieringControlBestEffort string = "best_effort"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// control
	// Control
	// disallowed
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringControlDisallowed captures enum value "disallowed"
	ConsistencyGroupConsistencyGroupsItems0TieringControlDisallowed string = "disallowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// control
	// Control
	// required
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringControlRequired captures enum value "required"
	ConsistencyGroupConsistencyGroupsItems0TieringControlRequired string = "required"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) validateControlEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0TieringTypeControlPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) validateControl(formats strfmt.Registry) error {
	if swag.IsZero(m.Control) { // not required
		return nil
	}

	// value enum
	if err := m.validateControlEnum("tiering"+"."+"control", "body", m.Control); err != nil {
		return err
	}

	return nil
}

var consistencyGroupConsistencyGroupsItems0TieringTypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0TieringTypePolicyPropEnum = append(consistencyGroupConsistencyGroupsItems0TieringTypePolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// policy
	// Policy
	// all
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringPolicyAll captures enum value "all"
	ConsistencyGroupConsistencyGroupsItems0TieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// policy
	// Policy
	// auto
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringPolicyAuto captures enum value "auto"
	ConsistencyGroupConsistencyGroupsItems0TieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// policy
	// Policy
	// backup
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringPolicyBackup captures enum value "backup"
	ConsistencyGroupConsistencyGroupsItems0TieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// policy
	// Policy
	// none
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringPolicyNone captures enum value "none"
	ConsistencyGroupConsistencyGroupsItems0TieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0Tiering
	// policy
	// Policy
	// snapshot_only
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0TieringPolicySnapshotOnly captures enum value "snapshot_only"
	ConsistencyGroupConsistencyGroupsItems0TieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0TieringTypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyEnum("tiering"+"."+"policy", "body", m.Policy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group consistency groups items0 tiering based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0Tiering) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0Tiering
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0VolumesItems0 consistency group consistency groups items0 volumes items0
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0VolumesItems0
type ConsistencyGroupConsistencyGroupsItems0VolumesItems0 struct {

	// A comment for the volume. Valid in POST or PATCH.
	// Max Length: 1023
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Language encoding setting for volume. If no language is specified, the volume inherits its SVM language encoding setting.
	// Enum: [ar ar.utf_8 c c.utf_8 cs cs.utf_8 da da.utf_8 de de.utf_8 en en.utf_8 en_us en_us.utf_8 es es.utf_8 fi fi.utf_8 fr fr.utf_8 he he.utf_8 hr hr.utf_8 hu hu.utf_8 it it.utf_8 ja ja.utf_8 ja_jp.932 ja_jp.932.utf_8 ja_jp.pck ja_jp.pck.utf_8 ja_jp.pck_v2 ja_jp.pck_v2.utf_8 ja_v1 ja_v1.utf_8 ko ko.utf_8 nl nl.utf_8 no no.utf_8 pl pl.utf_8 pt pt.utf_8 ro ro.utf_8 ru ru.utf_8 sk sk.utf_8 sl sl.utf_8 sv sv.utf_8 tr tr.utf_8 utf8mb4 zh zh.gbk zh.gbk.utf_8 zh.utf_8 zh_tw zh_tw.big5 zh_tw.big5.utf_8 zh_tw.utf_8]
	Language string `json:"language,omitempty"`

	// Volume name. The name of volume must start with an alphabetic character (a to z or A to Z) or an underscore (_). The name must be 197 or fewer characters in length for FlexGroups, and 203 or fewer characters in length for all other types of volumes. Volume names must be unique within an SVM. Required on POST.
	// Example: vol_cs_dept
	// Max Length: 203
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos `json:"qos,omitempty"`

	// The Snapshot copy policy for this volume.
	//
	SnapshotPolicy *SnapshotPolicyReference `json:"snapshot_policy,omitempty"`

	// space
	Space *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space `json:"space,omitempty"`

	// tiering
	Tiering *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering `json:"tiering,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 volumes items0
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 1023); err != nil {
		return err
	}

	return nil
}

var consistencyGroupConsistencyGroupsItems0VolumesItems0TypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","ar.utf_8","c","c.utf_8","cs","cs.utf_8","da","da.utf_8","de","de.utf_8","en","en.utf_8","en_us","en_us.utf_8","es","es.utf_8","fi","fi.utf_8","fr","fr.utf_8","he","he.utf_8","hr","hr.utf_8","hu","hu.utf_8","it","it.utf_8","ja","ja.utf_8","ja_jp.932","ja_jp.932.utf_8","ja_jp.pck","ja_jp.pck.utf_8","ja_jp.pck_v2","ja_jp.pck_v2.utf_8","ja_v1","ja_v1.utf_8","ko","ko.utf_8","nl","nl.utf_8","no","no.utf_8","pl","pl.utf_8","pt","pt.utf_8","ro","ro.utf_8","ru","ru.utf_8","sk","sk.utf_8","sl","sl.utf_8","sv","sv.utf_8","tr","tr.utf_8","utf8mb4","zh","zh.gbk","zh.gbk.utf_8","zh.utf_8","zh_tw","zh_tw.big5","zh_tw.big5.utf_8","zh_tw.utf_8"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0VolumesItems0TypeLanguagePropEnum = append(consistencyGroupConsistencyGroupsItems0VolumesItems0TypeLanguagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ar
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageAr captures enum value "ar"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageAr string = "ar"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ar.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageArDotUTF8 captures enum value "ar.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageArDotUTF8 string = "ar.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// c
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageC captures enum value "c"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageC string = "c"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// c.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageCDotUTF8 captures enum value "c.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageCDotUTF8 string = "c.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// cs
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageCs captures enum value "cs"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageCs string = "cs"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// cs.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageCsDotUTF8 captures enum value "cs.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageCsDotUTF8 string = "cs.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// da
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDa captures enum value "da"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDa string = "da"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// da.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDaDotUTF8 captures enum value "da.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDaDotUTF8 string = "da.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// de
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDe captures enum value "de"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDe string = "de"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// de.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDeDotUTF8 captures enum value "de.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageDeDotUTF8 string = "de.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// en
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEn captures enum value "en"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEn string = "en"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// en.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEnDotUTF8 captures enum value "en.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEnDotUTF8 string = "en.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// en_us
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEnUs captures enum value "en_us"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEnUs string = "en_us"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// en_us.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEnUsDotUTF8 captures enum value "en_us.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEnUsDotUTF8 string = "en_us.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// es
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEs captures enum value "es"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEs string = "es"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// es.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEsDotUTF8 captures enum value "es.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageEsDotUTF8 string = "es.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// fi
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFi captures enum value "fi"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFi string = "fi"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// fi.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFiDotUTF8 captures enum value "fi.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFiDotUTF8 string = "fi.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// fr
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFr captures enum value "fr"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFr string = "fr"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// fr.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFrDotUTF8 captures enum value "fr.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageFrDotUTF8 string = "fr.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// he
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHe captures enum value "he"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHe string = "he"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// he.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHeDotUTF8 captures enum value "he.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHeDotUTF8 string = "he.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// hr
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHr captures enum value "hr"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHr string = "hr"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// hr.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHrDotUTF8 captures enum value "hr.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHrDotUTF8 string = "hr.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// hu
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHu captures enum value "hu"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHu string = "hu"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// hu.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHuDotUTF8 captures enum value "hu.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageHuDotUTF8 string = "hu.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// it
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageIt captures enum value "it"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageIt string = "it"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// it.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageItDotUTF8 captures enum value "it.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageItDotUTF8 string = "it.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJa captures enum value "ja"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJa string = "ja"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaDotUTF8 captures enum value "ja.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaDotUTF8 string = "ja.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_jp.932
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDot932 captures enum value "ja_jp.932"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDot932 string = "ja_jp.932"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_jp.932.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDot932DotUTF8 captures enum value "ja_jp.932.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDot932DotUTF8 string = "ja_jp.932.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_jp.pck
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPck captures enum value "ja_jp.pck"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPck string = "ja_jp.pck"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_jp.pck.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPckDotUTF8 captures enum value "ja_jp.pck.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPckDotUTF8 string = "ja_jp.pck.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_jp.pck_v2
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPckV2 captures enum value "ja_jp.pck_v2"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPckV2 string = "ja_jp.pck_v2"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_jp.pck_v2.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPckV2DotUTF8 captures enum value "ja_jp.pck_v2.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaJpDotPckV2DotUTF8 string = "ja_jp.pck_v2.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_v1
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaV1 captures enum value "ja_v1"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaV1 string = "ja_v1"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ja_v1.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaV1DotUTF8 captures enum value "ja_v1.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageJaV1DotUTF8 string = "ja_v1.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ko
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageKo captures enum value "ko"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageKo string = "ko"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ko.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageKoDotUTF8 captures enum value "ko.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageKoDotUTF8 string = "ko.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// nl
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNl captures enum value "nl"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNl string = "nl"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// nl.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNlDotUTF8 captures enum value "nl.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNlDotUTF8 string = "nl.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// no
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNo captures enum value "no"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNo string = "no"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// no.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNoDotUTF8 captures enum value "no.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageNoDotUTF8 string = "no.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// pl
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePl captures enum value "pl"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePl string = "pl"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// pl.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePlDotUTF8 captures enum value "pl.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePlDotUTF8 string = "pl.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// pt
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePt captures enum value "pt"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePt string = "pt"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// pt.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePtDotUTF8 captures enum value "pt.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguagePtDotUTF8 string = "pt.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ro
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRo captures enum value "ro"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRo string = "ro"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ro.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRoDotUTF8 captures enum value "ro.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRoDotUTF8 string = "ro.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ru
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRu captures enum value "ru"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRu string = "ru"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// ru.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRuDotUTF8 captures enum value "ru.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageRuDotUTF8 string = "ru.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// sk
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSk captures enum value "sk"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSk string = "sk"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// sk.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSkDotUTF8 captures enum value "sk.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSkDotUTF8 string = "sk.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// sl
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSl captures enum value "sl"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSl string = "sl"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// sl.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSlDotUTF8 captures enum value "sl.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSlDotUTF8 string = "sl.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// sv
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSv captures enum value "sv"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSv string = "sv"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// sv.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSvDotUTF8 captures enum value "sv.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageSvDotUTF8 string = "sv.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// tr
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageTr captures enum value "tr"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageTr string = "tr"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// tr.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageTrDotUTF8 captures enum value "tr.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageTrDotUTF8 string = "tr.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// utf8mb4
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageUtf8mb4 captures enum value "utf8mb4"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageUtf8mb4 string = "utf8mb4"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZh captures enum value "zh"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZh string = "zh"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh.gbk
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhDotGbk captures enum value "zh.gbk"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhDotGbk string = "zh.gbk"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh.gbk.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhDotGbkDotUTF8 captures enum value "zh.gbk.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhDotGbkDotUTF8 string = "zh.gbk.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhDotUTF8 captures enum value "zh.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhDotUTF8 string = "zh.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh_tw
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTw captures enum value "zh_tw"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTw string = "zh_tw"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh_tw.big5
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTwDotBig5 captures enum value "zh_tw.big5"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTwDotBig5 string = "zh_tw.big5"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh_tw.big5.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTwDotBig5DotUTF8 captures enum value "zh_tw.big5.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTwDotBig5DotUTF8 string = "zh_tw.big5.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	// language
	// Language
	// zh_tw.utf_8
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTwDotUTF8 captures enum value "zh_tw.utf_8"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0LanguageZhTwDotUTF8 string = "zh_tw.utf_8"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0VolumesItems0TypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(m.Language) { // not required
		return nil
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", m.Language); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 203); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 volumes items0 based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0VolumesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions
type ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions struct {

	// Operation to perform
	// Enum: [create add]
	Action string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count int64 `json:"count,omitempty"`

	// storage service
	StorageService *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService `json:"storage_service,omitempty"`
}

// Validate validates this consistency group consistency groups items0 volumes items0 provisioning options
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create","add"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsTypeActionPropEnum = append(consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsActionCreate string = "create"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions
	// action
	// Action
	// add
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsActionAdd captures enum value "add"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsActionAdd string = "add"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 volumes items0 provisioning options based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService Determines the placement of any storage object created during this operation.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
type ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService struct {

	// Storage service name. If not specified, the default value is the most performant for the platform.
	//
	// Enum: [extreme performance value]
	Name string `json:"name,omitempty"`
}

// Validate validates this consistency group consistency groups items0 volumes items0 provisioning options storage service
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum = append(consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
	// name
	// Name
	// extreme
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceNameExtreme captures enum value "extreme"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceNameExtreme string = "extreme"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
	// name
	// Name
	// performance
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceNamePerformance captures enum value "performance"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceNamePerformance string = "performance"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
	// name
	// Name
	// value
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceNameValue captures enum value "value"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceNameValue string = "value"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("provisioning_options"+"."+"storage_service"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group consistency groups items0 volumes items0 provisioning options storage service based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0VolumesItems0ProvisioningOptionsStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos The QoS policy for this volume.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos
type ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos struct {

	// policy
	Policy *ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy `json:"policy,omitempty"`
}

// Validate validates this consistency group consistency groups items0 volumes items0 qos
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 volumes items0 qos based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0VolumesItems0Qos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy The QoS policy
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy
type ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group consistency groups items0 volumes items0 qos policy
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group consistency groups items0 volumes items0 qos policy based on the context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0VolumesItems0QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space consistency group consistency groups items0 volumes items0 space
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space
type ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space struct {

	// The available space, in bytes.
	Available int64 `json:"available,omitempty"`

	// Total provisioned size, in bytes.
	Size int64 `json:"size,omitempty"`

	// The virtual space used (includes volume reserves) before storage efficiency, in bytes.
	Used int64 `json:"used,omitempty"`
}

// Validate validates this consistency group consistency groups items0 volumes items0 space
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group consistency groups items0 volumes items0 space based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0VolumesItems0Space
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering The tiering placement and policy definitions for this volume.
//
//
// swagger:model ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
type ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering struct {

	// Storage tiering placement rules for the object.
	// Enum: [allowed best_effort disallowed required]
	Control string `json:"control,omitempty"`

	// Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold.
	// <br>FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br/>all &dash; Allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br/>auto &dash; Allows tiering of both snapshot and active file system user data to the cloud store<br/>none &dash; Volume blocks are not be tiered to the cloud store.<br/>snapshot_only &dash; Allows tiering of only the volume Snapshot copies not associated with the active file system.
	// <br>The default tiering policy is "snapshot-only" for a FlexVol volume and "none" for a FlexGroup volume. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy it is 31 days.
	//
	// Enum: [all auto backup none snapshot_only]
	Policy string `json:"policy,omitempty"`
}

// Validate validates this consistency group consistency groups items0 volumes items0 tiering
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypeControlPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["allowed","best_effort","disallowed","required"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypeControlPropEnum = append(consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypeControlPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// control
	// Control
	// allowed
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlAllowed captures enum value "allowed"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlAllowed string = "allowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// control
	// Control
	// best_effort
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlBestEffort captures enum value "best_effort"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlBestEffort string = "best_effort"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// control
	// Control
	// disallowed
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlDisallowed captures enum value "disallowed"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlDisallowed string = "disallowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// control
	// Control
	// required
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlRequired captures enum value "required"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringControlRequired string = "required"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) validateControlEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypeControlPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) validateControl(formats strfmt.Registry) error {
	if swag.IsZero(m.Control) { // not required
		return nil
	}

	// value enum
	if err := m.validateControlEnum("tiering"+"."+"control", "body", m.Control); err != nil {
		return err
	}

	return nil
}

var consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypePolicyPropEnum = append(consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypePolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// policy
	// Policy
	// all
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyAll captures enum value "all"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// policy
	// Policy
	// auto
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyAuto captures enum value "auto"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// policy
	// Policy
	// backup
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyBackup captures enum value "backup"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// policy
	// Policy
	// none
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyNone captures enum value "none"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	// policy
	// Policy
	// snapshot_only
	// END DEBUGGING
	// ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicySnapshotOnly captures enum value "snapshot_only"
	ConsistencyGroupConsistencyGroupsItems0VolumesItems0TieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupConsistencyGroupsItems0VolumesItems0TieringTypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyEnum("tiering"+"."+"policy", "body", m.Policy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group consistency groups items0 volumes items0 tiering based on context it is used
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupConsistencyGroupsItems0VolumesItems0Tiering
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0 A LUN is the logical representation of storage in a storage area network (SAN).<br/>
// In ONTAP, a LUN is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
// A LUN can be created to a specified size using thin or thick provisioning. A LUN can then be renamed, resized, cloned, and moved to a different volume. LUNs support the assignment of a quality of service (QoS) policy for performance management or a QoS policy can be assigned to the volume containing the LUN. See the LUN object model to learn more about each of the properties supported by the LUN REST API.<br/>
// A LUN must be mapped to an initiator group to grant access to the initiator group's initiators (client hosts). Initiators can then access the LUN and perform I/O over a Fibre Channel (FC) fabric using the Fibre Channel Protocol or a TCP/IP network using iSCSI.
//
//
// swagger:model ConsistencyGroupLunsItems0
type ConsistencyGroupLunsItems0 struct {

	// clone
	Clone *ConsistencyGroupLunsItems0Clone `json:"clone,omitempty"`

	// A configurable comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// The time the LUN was created.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"create_time,omitempty"`

	// The enabled state of the LUN. LUNs can be disabled to prevent access to the LUN. Certain error conditions also cause the LUN to become disabled. If the LUN is disabled, you can consult the `state` property to determine if the LUN is administratively disabled (_offline_) or has become disabled as a result of an error. A LUN in an error condition can be brought online by setting the `enabled` property to _true_ or brought administratively offline by setting the `enabled` property to _false_. Upon creation, a LUN is enabled by default. Valid in PATCH.
	//
	Enabled bool `json:"enabled,omitempty"`

	// An array of LUN maps.<br/>
	// A LUN map is an association between a LUN and an initiator group. When a LUN is mapped to an initiator group, the initiator group's initiators are granted access to the LUN. The relationship between a LUN and an initiator group is many LUNs to many initiator groups.
	//
	LunMaps []*ConsistencyGroupLunsItems0LunMapsItems0 `json:"lun_maps,omitempty"`

	// The fully qualified path name of the LUN composed of the "/vol" prefix, the volume name, the qtree name (optional), and the base name of the LUN. Valid in POST and PATCH.
	//
	// Example: /vol/volume1/lun1
	Name string `json:"name,omitempty"`

	// The operating system type of the LUN.<br/>
	// Required in POST when creating a LUN that is not a clone of another. Disallowed in POST when creating a LUN clone.
	//
	// Enum: [aix hpux hyper_v linux netware openvms solaris solaris_efi vmware windows windows_2008 windows_gpt xen]
	OsType string `json:"os_type,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupLunsItems0ProvisioningOptions `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupLunsItems0Qos `json:"qos,omitempty"`

	// The LUN serial number. The serial number is generated by ONTAP when the LUN is created.
	//
	// Read Only: true
	// Max Length: 12
	// Min Length: 12
	SerialNumber string `json:"serial_number,omitempty"`

	// space
	Space *ConsistencyGroupLunsItems0Space `json:"space,omitempty"`

	// The unique identifier of the LUN.  The UUID is generated by ONTAP when the LUN is created.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group luns items0
func (m *ConsistencyGroupLunsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLunMaps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0) validateClone(formats strfmt.Registry) error {
	if swag.IsZero(m.Clone) { // not required
		return nil
	}

	if m.Clone != nil {
		if err := m.Clone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) validateCreateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("create_time", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) validateLunMaps(formats strfmt.Registry) error {
	if swag.IsZero(m.LunMaps) { // not required
		return nil
	}

	for i := 0; i < len(m.LunMaps); i++ {
		if swag.IsZero(m.LunMaps[i]) { // not required
			continue
		}

		if m.LunMaps[i] != nil {
			if err := m.LunMaps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var consistencyGroupLunsItems0TypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","hpux","hyper_v","linux","netware","openvms","solaris","solaris_efi","vmware","windows","windows_2008","windows_gpt","xen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupLunsItems0TypeOsTypePropEnum = append(consistencyGroupLunsItems0TypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeAix captures enum value "aix"
	ConsistencyGroupLunsItems0OsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// hpux
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeHpux captures enum value "hpux"
	ConsistencyGroupLunsItems0OsTypeHpux string = "hpux"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// hyper_v
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeHyperv captures enum value "hyper_v"
	ConsistencyGroupLunsItems0OsTypeHyperv string = "hyper_v"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeLinux captures enum value "linux"
	ConsistencyGroupLunsItems0OsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// netware
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeNetware captures enum value "netware"
	ConsistencyGroupLunsItems0OsTypeNetware string = "netware"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// openvms
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeOpenvms captures enum value "openvms"
	ConsistencyGroupLunsItems0OsTypeOpenvms string = "openvms"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// solaris
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeSolaris captures enum value "solaris"
	ConsistencyGroupLunsItems0OsTypeSolaris string = "solaris"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// solaris_efi
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeSolarisEfi captures enum value "solaris_efi"
	ConsistencyGroupLunsItems0OsTypeSolarisEfi string = "solaris_efi"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeVmware captures enum value "vmware"
	ConsistencyGroupLunsItems0OsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeWindows captures enum value "windows"
	ConsistencyGroupLunsItems0OsTypeWindows string = "windows"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// windows_2008
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeWindows2008 captures enum value "windows_2008"
	ConsistencyGroupLunsItems0OsTypeWindows2008 string = "windows_2008"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// windows_gpt
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeWindowsGpt captures enum value "windows_gpt"
	ConsistencyGroupLunsItems0OsTypeWindowsGpt string = "windows_gpt"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0
	// ConsistencyGroupLunsItems0
	// os_type
	// OsType
	// xen
	// END DEBUGGING
	// ConsistencyGroupLunsItems0OsTypeXen captures enum value "xen"
	ConsistencyGroupLunsItems0OsTypeXen string = "xen"
)

// prop value enum
func (m *ConsistencyGroupLunsItems0) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupLunsItems0TypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) validateSerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.SerialNumber) { // not required
		return nil
	}

	if err := validate.MinLength("serial_number", "body", m.SerialNumber, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("serial_number", "body", m.SerialNumber, 12); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 based on the context it is used
func (m *ConsistencyGroupLunsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLunMaps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateClone(ctx context.Context, formats strfmt.Registry) error {

	if m.Clone != nil {
		if err := m.Clone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", m.CreateTime); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateLunMaps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LunMaps); i++ {

		if m.LunMaps[i] != nil {
			if err := m.LunMaps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0Clone This sub-object is used in POST to create a new LUN as a clone of an existing LUN, or PATCH to overwrite an existing LUN as a clone of another. Setting a property in this sub-object indicates that a LUN clone is desired. Consider the following other properties when cloning a LUN: `auto_delete`, `qos_policy`, `space.guarantee.requested` and `space.scsi_thin_provisioning_support_enabled`.<br/>
// When used in a PATCH, the patched LUN's data is over-written as a clone of the source and the following properties are preserved from the patched LUN unless otherwise specified as part of the PATCH: `class`, `auto_delete`, `lun_maps`, `serial_number`, `status.state`, and `uuid`.<br/>
// Persistent reservations for the patched LUN are also preserved.
//
//
// swagger:model ConsistencyGroupLunsItems0Clone
type ConsistencyGroupLunsItems0Clone struct {

	// source
	Source *ConsistencyGroupLunsItems0CloneSource `json:"source,omitempty"`
}

// Validate validates this consistency group luns items0 clone
func (m *ConsistencyGroupLunsItems0Clone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0Clone) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 clone based on the context it is used
func (m *ConsistencyGroupLunsItems0Clone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0Clone) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0Clone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0Clone) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0Clone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0CloneSource The source LUN for a LUN clone operation. This can be specified using property `clone.source.uuid` or `clone.source.name`. If both properties are supplied, they must refer to the same LUN.<br/>
// Valid in POST to create a new LUN as a clone of the source.<br/>
// Valid in PATCH to overwrite an existing LUN's data as a clone of another.
//
//
// swagger:model ConsistencyGroupLunsItems0CloneSource
type ConsistencyGroupLunsItems0CloneSource struct {

	// The fully qualified path name of the clone source LUN composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN. Valid in POST and PATCH.
	//
	// Example: /vol/volume1/lun1
	Name string `json:"name,omitempty"`

	// The unique identifier of the clone source LUN. Valid in POST and PATCH.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group luns items0 clone source
func (m *ConsistencyGroupLunsItems0CloneSource) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group luns items0 clone source based on context it is used
func (m *ConsistencyGroupLunsItems0CloneSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0CloneSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0CloneSource) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0CloneSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0LunMapsItems0 A LUN map is an association between a LUN and an initiator group.<br/>
// When a LUN is mapped to an initiator group, the initiator group's initiators are granted access to the LUN. The relationship between a LUN and an initiator group is many LUNs to many initiator groups.
//
//
// swagger:model ConsistencyGroupLunsItems0LunMapsItems0
type ConsistencyGroupLunsItems0LunMapsItems0 struct {

	// igroup
	Igroup *ConsistencyGroupLunsItems0LunMapsItems0Igroup `json:"igroup,omitempty"`

	// The logical unit number assigned to the LUN when mapped to the specified initiator group. The number is used to identify the LUN to initiators in the initiator group when communicating through the Fibre Channel Protocol or iSCSI. Optional in POST; if no value is provided, ONTAP assigns the lowest available value.
	//
	LogicalUnitNumber int64 `json:"logical_unit_number,omitempty"`
}

// Validate validates this consistency group luns items0 lun maps items0
func (m *ConsistencyGroupLunsItems0LunMapsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIgroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0) validateIgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Igroup) { // not required
		return nil
	}

	if m.Igroup != nil {
		if err := m.Igroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 lun maps items0 based on the context it is used
func (m *ConsistencyGroupLunsItems0LunMapsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0) contextValidateIgroup(ctx context.Context, formats strfmt.Registry) error {

	if m.Igroup != nil {
		if err := m.Igroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0LunMapsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0LunMapsItems0Igroup The initiator group that directly owns the initiator, which is where modification of the initiator is supported. This property will only be populated when the initiator is a member of a nested initiator group.
//
//
// swagger:model ConsistencyGroupLunsItems0LunMapsItems0Igroup
type ConsistencyGroupLunsItems0LunMapsItems0Igroup struct {

	// A comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Separate igroup definitions to include in this igroup.
	//
	Igroups []*ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0 `json:"igroups,omitempty"`

	// The initiators that are members of the group.
	//
	Initiators []*ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0 `json:"initiators,omitempty"`

	// The name of the initiator group. Required in POST; optional in PATCH.
	//
	// Example: igroup1
	// Max Length: 96
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// The host operating system of the initiator group. All initiators in the group should be hosts of the same operating system. Required in POST; optional in PATCH.
	//
	// Enum: [aix hpux hyper_v linux netware openvms solaris vmware windows xen]
	OsType string `json:"os_type,omitempty"`

	// The protocols supported by the initiator group. This restricts the type of initiators that can be added to the initiator group. Optional in POST; if not supplied, this defaults to _mixed_.<br/>
	// The protocol of an initiator group cannot be changed after creation of the group.
	//
	// Enum: [fcp iscsi mixed]
	Protocol *string `json:"protocol,omitempty"`

	// The unique identifier of the initiator group.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group luns items0 lun maps items0 igroup
func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitiators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("igroup"+"."+"comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("igroup"+"."+"comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateIgroups(formats strfmt.Registry) error {
	if swag.IsZero(m.Igroups) { // not required
		return nil
	}

	for i := 0; i < len(m.Igroups); i++ {
		if swag.IsZero(m.Igroups[i]) { // not required
			continue
		}

		if m.Igroups[i] != nil {
			if err := m.Igroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "igroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateInitiators(formats strfmt.Registry) error {
	if swag.IsZero(m.Initiators) { // not required
		return nil
	}

	for i := 0; i < len(m.Initiators); i++ {
		if swag.IsZero(m.Initiators[i]) { // not required
			continue
		}

		if m.Initiators[i] != nil {
			if err := m.Initiators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "initiators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("igroup"+"."+"name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("igroup"+"."+"name", "body", m.Name, 96); err != nil {
		return err
	}

	return nil
}

var consistencyGroupLunsItems0LunMapsItems0IgroupTypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","hpux","hyper_v","linux","netware","openvms","solaris","vmware","windows","xen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupLunsItems0LunMapsItems0IgroupTypeOsTypePropEnum = append(consistencyGroupLunsItems0LunMapsItems0IgroupTypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeAix captures enum value "aix"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// hpux
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeHpux captures enum value "hpux"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeHpux string = "hpux"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// hyper_v
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeHyperv captures enum value "hyper_v"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeHyperv string = "hyper_v"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeLinux captures enum value "linux"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// netware
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeNetware captures enum value "netware"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeNetware string = "netware"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// openvms
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeOpenvms captures enum value "openvms"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeOpenvms string = "openvms"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// solaris
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeSolaris captures enum value "solaris"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeSolaris string = "solaris"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeVmware captures enum value "vmware"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeWindows captures enum value "windows"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeWindows string = "windows"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// os_type
	// OsType
	// xen
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeXen captures enum value "xen"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupOsTypeXen string = "xen"
)

// prop value enum
func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupLunsItems0LunMapsItems0IgroupTypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("igroup"+"."+"os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

var consistencyGroupLunsItems0LunMapsItems0IgroupTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fcp","iscsi","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupLunsItems0LunMapsItems0IgroupTypeProtocolPropEnum = append(consistencyGroupLunsItems0LunMapsItems0IgroupTypeProtocolPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// protocol
	// Protocol
	// fcp
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupProtocolFcp captures enum value "fcp"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupProtocolFcp string = "fcp"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// protocol
	// Protocol
	// iscsi
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupProtocolIscsi captures enum value "iscsi"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupProtocolIscsi string = "iscsi"

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// ConsistencyGroupLunsItems0LunMapsItems0Igroup
	// protocol
	// Protocol
	// mixed
	// END DEBUGGING
	// ConsistencyGroupLunsItems0LunMapsItems0IgroupProtocolMixed captures enum value "mixed"
	ConsistencyGroupLunsItems0LunMapsItems0IgroupProtocolMixed string = "mixed"
)

// prop value enum
func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupLunsItems0LunMapsItems0IgroupTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("igroup"+"."+"protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 lun maps items0 igroup based on the context it is used
func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIgroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInitiators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) contextValidateIgroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Igroups); i++ {

		if m.Igroups[i] != nil {
			if err := m.Igroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "igroups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) contextValidateInitiators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Initiators); i++ {

		if m.Initiators[i] != nil {
			if err := m.Initiators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("igroup" + "." + "initiators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "igroup"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0Igroup) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0LunMapsItems0Igroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0 consistency group luns items0 lun maps items0 igroup igroups items0
//
// swagger:model ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0
type ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0 struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The name of the initiator group.
	//
	// Example: igroup1
	// Max Length: 96
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// The unique identifier of the initiator group.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group luns items0 lun maps items0 igroup igroups items0
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 96); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 lun maps items0 igroup igroups items0 based on the context it is used
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0LunMapsItems0IgroupIgroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0 The initiators that are members of the initiator group.
//
// swagger:model ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0
type ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0 struct {

	// A comment available for use by the administrator.
	//
	// Example: my comment
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Name of initiator that is a member of the initiator group.
	//
	// Example: iqn.1998-01.com.corp.iscsi:name1
	Name string `json:"name,omitempty"`
}

// Validate validates this consistency group luns items0 lun maps items0 igroup initiators items0
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group luns items0 lun maps items0 igroup initiators items0 based on context it is used
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0LunMapsItems0IgroupInitiatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0ProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupLunsItems0ProvisioningOptions
type ConsistencyGroupLunsItems0ProvisioningOptions struct {

	// Operation to perform
	// Enum: [create]
	Action string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count int64 `json:"count,omitempty"`
}

// Validate validates this consistency group luns items0 provisioning options
func (m *ConsistencyGroupLunsItems0ProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupLunsItems0ProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupLunsItems0ProvisioningOptionsTypeActionPropEnum = append(consistencyGroupLunsItems0ProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupLunsItems0ProvisioningOptions
	// ConsistencyGroupLunsItems0ProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupLunsItems0ProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupLunsItems0ProvisioningOptionsActionCreate string = "create"
)

// prop value enum
func (m *ConsistencyGroupLunsItems0ProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupLunsItems0ProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0ProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group luns items0 provisioning options based on context it is used
func (m *ConsistencyGroupLunsItems0ProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0ProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0ProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0ProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0Qos consistency group luns items0 qos
//
// swagger:model ConsistencyGroupLunsItems0Qos
type ConsistencyGroupLunsItems0Qos struct {

	// policy
	Policy *ConsistencyGroupLunsItems0QosPolicy `json:"policy,omitempty"`
}

// Validate validates this consistency group luns items0 qos
func (m *ConsistencyGroupLunsItems0Qos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0Qos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 qos based on the context it is used
func (m *ConsistencyGroupLunsItems0Qos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0Qos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0Qos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0Qos) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0Qos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0QosPolicy The QoS policy
//
//
// swagger:model ConsistencyGroupLunsItems0QosPolicy
type ConsistencyGroupLunsItems0QosPolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group luns items0 qos policy
func (m *ConsistencyGroupLunsItems0QosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0QosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 qos policy based on the context it is used
func (m *ConsistencyGroupLunsItems0QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0QosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0QosPolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0Space The storage space related properties of the LUN.
//
//
// swagger:model ConsistencyGroupLunsItems0Space
type ConsistencyGroupLunsItems0Space struct {

	// guarantee
	Guarantee *ConsistencyGroupLunsItems0SpaceGuarantee `json:"guarantee,omitempty"`

	// The total provisioned size of the LUN. The LUN size can be increased but not reduced using the REST interface.
	// The maximum and minimum sizes listed here are the absolute maximum and absolute minimum sizes, in bytes. The actual minimum and maxiumum sizes vary depending on the ONTAP version, ONTAP platform, and the available space in the containing volume and aggregate.
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	// Example: 1073741824
	// Maximum: 1.40737488355328e+14
	// Minimum: 4096
	Size int64 `json:"size,omitempty"`

	// The amount of space consumed by the main data stream of the LUN.<br/>
	// This value is the total space consumed in the volume by the LUN, including filesystem overhead, but excluding prefix and suffix streams. Due to internal filesystem overhead and the many ways SAN filesystems and applications utilize blocks within a LUN, this value does not necessarily reflect actual consumption/availability from the perspective of the filesystem or application. Without specific knowledge of how the LUN blocks are utilized outside of ONTAP, this property should not be used as an indicator for an out-of-space condition.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	Used int64 `json:"used,omitempty"`
}

// Validate validates this consistency group luns items0 space
func (m *ConsistencyGroupLunsItems0Space) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGuarantee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0Space) validateGuarantee(formats strfmt.Registry) error {
	if swag.IsZero(m.Guarantee) { // not required
		return nil
	}

	if m.Guarantee != nil {
		if err := m.Guarantee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupLunsItems0Space) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := validate.MinimumInt("space"+"."+"size", "body", m.Size, 4096, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("space"+"."+"size", "body", m.Size, 1.40737488355328e+14, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this consistency group luns items0 space based on the context it is used
func (m *ConsistencyGroupLunsItems0Space) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGuarantee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupLunsItems0Space) contextValidateGuarantee(ctx context.Context, formats strfmt.Registry) error {

	if m.Guarantee != nil {
		if err := m.Guarantee.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0Space) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0Space) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0Space
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupLunsItems0SpaceGuarantee Properties that request and report the space guarantee for the LUN.
//
//
// swagger:model ConsistencyGroupLunsItems0SpaceGuarantee
type ConsistencyGroupLunsItems0SpaceGuarantee struct {

	// The requested space reservation policy for the LUN. If _true_, a space reservation is requested for the LUN; if _false_, the LUN is thin provisioned. Guaranteeing a space reservation request for a LUN requires that the volume in which the LUN resides is also space reserved and that the fractional reserve for the volume is 100%. Valid in POST and PATCH.
	//
	Requested *bool `json:"requested,omitempty"`

	// Reports if the LUN is space guaranteed.<br/>
	// If _true_, a space guarantee is requested and the containing volume and aggregate support the request. If _false_, a space guarantee is not requested or a space guarantee is requested and either the containing volume or aggregate do not support the request.
	//
	Reserved bool `json:"reserved,omitempty"`
}

// Validate validates this consistency group luns items0 space guarantee
func (m *ConsistencyGroupLunsItems0SpaceGuarantee) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group luns items0 space guarantee based on context it is used
func (m *ConsistencyGroupLunsItems0SpaceGuarantee) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0SpaceGuarantee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupLunsItems0SpaceGuarantee) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupLunsItems0SpaceGuarantee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupNamespacesItems0 An NVMe namespace is a collection of addressable logical blocks presented to hosts connected to the storage virtual machine using the NVMe over Fabrics protocol.<br/>
// In ONTAP, an NVMe namespace is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
// An NVMe namespace is created to a specified size using thin or thick provisioning as determined by the volume on which it is created. NVMe namespaces support being cloned. An NVMe namespace cannot be renamed, resized, or moved to a different volume. NVMe namespaces do not support the assignment of a QoS policy for performance management, but a QoS policy can be assigned to the volume containing the namespace. See the NVMe namespace object model to learn more about each of the properties supported by the NVMe namespace REST API.<br/>
// An NVMe namespace must be mapped to an NVMe subsystem to grant access to the subsystem's hosts. Hosts can then access the NVMe namespace and perform I/O using the NVMe over Fabrics protocol.
//
//
// swagger:model ConsistencyGroupNamespacesItems0
type ConsistencyGroupNamespacesItems0 struct {

	// This property marks the NVMe namespace for auto deletion when the volume containing the namespace runs out of space. This is most commonly set on namespace clones.<br/>
	// When set to _true_, the NVMe namespace becomes eligible for automatic deletion when the volume runs out of space. Auto deletion only occurs when the volume containing the namespace is also configured for auto deletion and free space in the volume decreases below a particular threshold.<br/>
	// This property is optional in POST and PATCH. The default value for a new NVMe namespace is _false_.<br/>
	// There is an added cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// A configurable comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// The time the NVMe namespace was created.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"create_time,omitempty"`

	// The enabled state of the NVMe namespace. Certain error conditions cause the namespace to become disabled. If the namespace is disabled, you can check the `state` property to determine what error disabled the namespace. An NVMe namespace is enabled automatically when it is created.
	//
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// The fully qualified path name of the NVMe namespace composed of a "/vol" prefix, the volume name, the (optional) qtree name and base name of the namespace. Valid in POST.<br/>
	// NVMe namespaces do not support rename, or movement between volumes.
	//
	// Example: /vol/volume1/qtree1/namespace1
	Name string `json:"name,omitempty"`

	// The operating system type of the NVMe namespace.<br/>
	// Required in POST when creating an NVMe namespace that is not a clone of another. Disallowed in POST when creating a namespace clone.
	//
	// Enum: [aix linux vmware windows]
	OsType string `json:"os_type,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupNamespacesItems0ProvisioningOptions `json:"provisioning_options,omitempty"`

	// The NVMe subsystem with which the NVMe namespace is associated. A namespace can be mapped to zero (0) or one (1) subsystems.<br/>
	// There is an added cost to retrieving property values for `subsystem_map`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter.
	//
	SubsystemMap []*ConsistencyGroupNamespacesItems0SubsystemMapItems0 `json:"subsystem_map,omitempty"`

	// The unique identifier of the NVMe namespace.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group namespaces items0
func (m *ConsistencyGroupNamespacesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubsystemMap(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupNamespacesItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0) validateCreateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("create_time", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var consistencyGroupNamespacesItems0TypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","linux","vmware","windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupNamespacesItems0TypeOsTypePropEnum = append(consistencyGroupNamespacesItems0TypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupNamespacesItems0
	// ConsistencyGroupNamespacesItems0
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// ConsistencyGroupNamespacesItems0OsTypeAix captures enum value "aix"
	ConsistencyGroupNamespacesItems0OsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// ConsistencyGroupNamespacesItems0
	// ConsistencyGroupNamespacesItems0
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// ConsistencyGroupNamespacesItems0OsTypeLinux captures enum value "linux"
	ConsistencyGroupNamespacesItems0OsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// ConsistencyGroupNamespacesItems0
	// ConsistencyGroupNamespacesItems0
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// ConsistencyGroupNamespacesItems0OsTypeVmware captures enum value "vmware"
	ConsistencyGroupNamespacesItems0OsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// ConsistencyGroupNamespacesItems0
	// ConsistencyGroupNamespacesItems0
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// ConsistencyGroupNamespacesItems0OsTypeWindows captures enum value "windows"
	ConsistencyGroupNamespacesItems0OsTypeWindows string = "windows"
)

// prop value enum
func (m *ConsistencyGroupNamespacesItems0) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupNamespacesItems0TypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupNamespacesItems0) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0) validateSubsystemMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SubsystemMap) { // not required
		return nil
	}

	for i := 0; i < len(m.SubsystemMap); i++ {
		if swag.IsZero(m.SubsystemMap[i]) { // not required
			continue
		}

		if m.SubsystemMap[i] != nil {
			if err := m.SubsystemMap[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subsystem_map" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this consistency group namespaces items0 based on the context it is used
func (m *ConsistencyGroupNamespacesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubsystemMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupNamespacesItems0) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", m.CreateTime); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0) contextValidateSubsystemMap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SubsystemMap); i++ {

		if m.SubsystemMap[i] != nil {
			if err := m.SubsystemMap[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subsystem_map" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupNamespacesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupNamespacesItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupNamespacesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupNamespacesItems0ProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupNamespacesItems0ProvisioningOptions
type ConsistencyGroupNamespacesItems0ProvisioningOptions struct {

	// Operation to perform
	// Enum: [create]
	Action string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count int64 `json:"count,omitempty"`
}

// Validate validates this consistency group namespaces items0 provisioning options
func (m *ConsistencyGroupNamespacesItems0ProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupNamespacesItems0ProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupNamespacesItems0ProvisioningOptionsTypeActionPropEnum = append(consistencyGroupNamespacesItems0ProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupNamespacesItems0ProvisioningOptions
	// ConsistencyGroupNamespacesItems0ProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupNamespacesItems0ProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupNamespacesItems0ProvisioningOptionsActionCreate string = "create"
)

// prop value enum
func (m *ConsistencyGroupNamespacesItems0ProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupNamespacesItems0ProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupNamespacesItems0ProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group namespaces items0 provisioning options based on context it is used
func (m *ConsistencyGroupNamespacesItems0ProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupNamespacesItems0ProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupNamespacesItems0ProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupNamespacesItems0ProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupNamespacesItems0SubsystemMapItems0 The NVMe subsystem with which the NVMe namespace is associated. A namespace can be mapped to zero (0) or one (1) subsystems.<br/>
// There is an added cost to retrieving property values for `subsystem_map`.
// They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter.
//
//
// swagger:model ConsistencyGroupNamespacesItems0SubsystemMapItems0
type ConsistencyGroupNamespacesItems0SubsystemMapItems0 struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The Asymmetric Namespace Access Group ID (ANAGRPID) of the NVMe namespace.<br/>
	// The format for an ANAGRPID is 8 hexadecimal digits (zero-filled) followed by a lower case "h".
	//
	// Example: 00103050h
	Anagrpid string `json:"anagrpid,omitempty"`

	// The NVMe namespace identifier. This is an identifier used by an NVMe controller to provide access to the NVMe namespace.<br/>
	// The format for an NVMe namespace identifier is 8 hexadecimal digits (zero-filled) followed by a lower case "h".
	//
	// Example: 00000001h
	Nsid string `json:"nsid,omitempty"`

	// The NVMe subsystem to which the NVMe namespace is mapped.
	//
	Subsystem *NvmeSubsystemReference `json:"subsystem,omitempty"`
}

// Validate validates this consistency group namespaces items0 subsystem map items0
func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubsystem(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) validateSubsystem(formats strfmt.Registry) error {
	if swag.IsZero(m.Subsystem) { // not required
		return nil
	}

	if m.Subsystem != nil {
		if err := m.Subsystem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subsystem")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group namespaces items0 subsystem map items0 based on the context it is used
func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubsystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) contextValidateSubsystem(ctx context.Context, formats strfmt.Registry) error {

	if m.Subsystem != nil {
		if err := m.Subsystem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subsystem")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupNamespacesItems0SubsystemMapItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupNamespacesItems0SubsystemMapItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupParentConsistencyGroup The parent consistency group.
//
//
// swagger:model ConsistencyGroupParentConsistencyGroup
type ConsistencyGroupParentConsistencyGroup struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// The name of the consistency group.
	// Example: my_consistency_group
	Name string `json:"name,omitempty"`

	// The unique identifier of the consistency group.
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group parent consistency group
func (m *ConsistencyGroupParentConsistencyGroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupParentConsistencyGroup) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group parent consistency group based on the context it is used
func (m *ConsistencyGroupParentConsistencyGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupParentConsistencyGroup) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parent_consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupParentConsistencyGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupParentConsistencyGroup) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupParentConsistencyGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupProvisioningOptionsType Options that are applied to the operation.
//
// swagger:model ConsistencyGroupProvisioningOptionsType
type ConsistencyGroupProvisioningOptionsType struct {

	// Operation to perform
	// Enum: [create]
	Action string `json:"action,omitempty"`

	// storage service
	StorageService *ConsistencyGroupProvisioningOptionsTypeStorageServiceType `json:"storage_service,omitempty"`
}

// Validate validates this consistency group provisioning options type
func (m *ConsistencyGroupProvisioningOptionsType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupProvisioningOptionsTypeTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupProvisioningOptionsTypeTypeActionPropEnum = append(consistencyGroupProvisioningOptionsTypeTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupProvisioningOptionsType
	// ConsistencyGroupProvisioningOptionsType
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupProvisioningOptionsTypeActionCreate captures enum value "create"
	ConsistencyGroupProvisioningOptionsTypeActionCreate string = "create"
)

// prop value enum
func (m *ConsistencyGroupProvisioningOptionsType) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupProvisioningOptionsTypeTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupProvisioningOptionsType) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupProvisioningOptionsType) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group provisioning options type based on the context it is used
func (m *ConsistencyGroupProvisioningOptionsType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupProvisioningOptionsType) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupProvisioningOptionsType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupProvisioningOptionsType) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupProvisioningOptionsType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupProvisioningOptionsTypeStorageServiceType Determines the placement of any storage object created during this operation.
//
//
// swagger:model ConsistencyGroupProvisioningOptionsTypeStorageServiceType
type ConsistencyGroupProvisioningOptionsTypeStorageServiceType struct {

	// Storage service name. If not specified, the default value is the most performant for the platform.
	//
	// Enum: [extreme performance value]
	Name string `json:"name,omitempty"`
}

// Validate validates this consistency group provisioning options type storage service type
func (m *ConsistencyGroupProvisioningOptionsTypeStorageServiceType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupProvisioningOptionsTypeStorageServiceTypeTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupProvisioningOptionsTypeStorageServiceTypeTypeNamePropEnum = append(consistencyGroupProvisioningOptionsTypeStorageServiceTypeTypeNamePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceType
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceType
	// name
	// Name
	// extreme
	// END DEBUGGING
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceTypeNameExtreme captures enum value "extreme"
	ConsistencyGroupProvisioningOptionsTypeStorageServiceTypeNameExtreme string = "extreme"

	// BEGIN DEBUGGING
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceType
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceType
	// name
	// Name
	// performance
	// END DEBUGGING
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceTypeNamePerformance captures enum value "performance"
	ConsistencyGroupProvisioningOptionsTypeStorageServiceTypeNamePerformance string = "performance"

	// BEGIN DEBUGGING
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceType
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceType
	// name
	// Name
	// value
	// END DEBUGGING
	// ConsistencyGroupProvisioningOptionsTypeStorageServiceTypeNameValue captures enum value "value"
	ConsistencyGroupProvisioningOptionsTypeStorageServiceTypeNameValue string = "value"
)

// prop value enum
func (m *ConsistencyGroupProvisioningOptionsTypeStorageServiceType) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupProvisioningOptionsTypeStorageServiceTypeTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupProvisioningOptionsTypeStorageServiceType) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("provisioning_options"+"."+"storage_service"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group provisioning options type storage service type based on context it is used
func (m *ConsistencyGroupProvisioningOptionsTypeStorageServiceType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupProvisioningOptionsTypeStorageServiceType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupProvisioningOptionsTypeStorageServiceType) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupProvisioningOptionsTypeStorageServiceType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupQosType consistency group qos type
//
// swagger:model ConsistencyGroupQosType
type ConsistencyGroupQosType struct {

	// policy
	Policy *ConsistencyGroupQosTypePolicyType `json:"policy,omitempty"`
}

// Validate validates this consistency group qos type
func (m *ConsistencyGroupQosType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupQosType) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group qos type based on the context it is used
func (m *ConsistencyGroupQosType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupQosType) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupQosType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupQosType) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupQosType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupQosTypePolicyType The QoS policy
//
//
// swagger:model ConsistencyGroupQosTypePolicyType
type ConsistencyGroupQosTypePolicyType struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group qos type policy type
func (m *ConsistencyGroupQosTypePolicyType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupQosTypePolicyType) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group qos type policy type based on the context it is used
func (m *ConsistencyGroupQosTypePolicyType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupQosTypePolicyType) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupQosTypePolicyType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupQosTypePolicyType) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupQosTypePolicyType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupRestoreTo Use to restore a consistency group to a previous Snapshot copy
//
//
// swagger:model ConsistencyGroupRestoreTo
type ConsistencyGroupRestoreTo struct {

	// snapshot
	Snapshot *ConsistencyGroupRestoreToSnapshot `json:"snapshot,omitempty"`
}

// Validate validates this consistency group restore to
func (m *ConsistencyGroupRestoreTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupRestoreTo) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group restore to based on the context it is used
func (m *ConsistencyGroupRestoreTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupRestoreTo) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {
		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restore_to" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupRestoreTo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupRestoreTo) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupRestoreTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupRestoreToSnapshot A consistency group's Snapshot copy
//
// swagger:model ConsistencyGroupRestoreToSnapshot
type ConsistencyGroupRestoreToSnapshot struct {

	// The name of the consistency group's Snapshot copy to restore to.
	Name string `json:"name,omitempty"`

	// The UUID of the consistency group's Snapshot copy to restore to.
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group restore to snapshot
func (m *ConsistencyGroupRestoreToSnapshot) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group restore to snapshot based on context it is used
func (m *ConsistencyGroupRestoreToSnapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupRestoreToSnapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupRestoreToSnapshot) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupRestoreToSnapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupSpaceType Space information for the consistency group.
//
//
// swagger:model ConsistencyGroupSpaceType
type ConsistencyGroupSpaceType struct {

	// The amount of space available in the consistency group, in bytes.<br/>
	//
	// Example: 5737418
	Available int64 `json:"available,omitempty"`

	// The total provisioned size of the consistency group, in bytes.<br/>
	//
	// Example: 1073741824
	Size int64 `json:"size,omitempty"`

	// The amount of space consumed in the consistency group, in bytes.<br/>
	//
	// Example: 5737418
	Used int64 `json:"used,omitempty"`
}

// Validate validates this consistency group space type
func (m *ConsistencyGroupSpaceType) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group space type based on context it is used
func (m *ConsistencyGroupSpaceType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupSpaceType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupSpaceType) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupSpaceType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupSvm The Storage Virtual Machine (SVM) in which the consistency group is located.
//
//
// swagger:model ConsistencyGroupSvm
type ConsistencyGroupSvm struct {

	// links
	Links *ConsistencyGroupSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group svm
func (m *ConsistencyGroupSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group svm based on the context it is used
func (m *ConsistencyGroupSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupSvm) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupSvmLinks consistency group svm links
//
// swagger:model ConsistencyGroupSvmLinks
type ConsistencyGroupSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this consistency group svm links
func (m *ConsistencyGroupSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group svm links based on the context it is used
func (m *ConsistencyGroupSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupSvmLinks) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupTieringType The tiering placement and policy definitions for volumes in this consistency group.
//
//
// swagger:model ConsistencyGroupTieringType
type ConsistencyGroupTieringType struct {

	// Storage tiering placement rules for the object.
	// Enum: [allowed best_effort disallowed required]
	Control string `json:"control,omitempty"`

	// Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold.
	// <br>FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br/>all &dash; Allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br/>auto &dash; Allows tiering of both snapshot and active file system user data to the cloud store<br/>none &dash; Volume blocks are not be tiered to the cloud store.<br/>snapshot_only &dash; Allows tiering of only the volume Snapshot copies not associated with the active file system.
	// <br>The default tiering policy is "snapshot-only" for a FlexVol volume and "none" for a FlexGroup volume. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy it is 31 days.
	//
	// Enum: [all auto backup none snapshot_only]
	Policy string `json:"policy,omitempty"`
}

// Validate validates this consistency group tiering type
func (m *ConsistencyGroupTieringType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupTieringTypeTypeControlPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["allowed","best_effort","disallowed","required"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupTieringTypeTypeControlPropEnum = append(consistencyGroupTieringTypeTypeControlPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// control
	// Control
	// allowed
	// END DEBUGGING
	// ConsistencyGroupTieringTypeControlAllowed captures enum value "allowed"
	ConsistencyGroupTieringTypeControlAllowed string = "allowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// control
	// Control
	// best_effort
	// END DEBUGGING
	// ConsistencyGroupTieringTypeControlBestEffort captures enum value "best_effort"
	ConsistencyGroupTieringTypeControlBestEffort string = "best_effort"

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// control
	// Control
	// disallowed
	// END DEBUGGING
	// ConsistencyGroupTieringTypeControlDisallowed captures enum value "disallowed"
	ConsistencyGroupTieringTypeControlDisallowed string = "disallowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// control
	// Control
	// required
	// END DEBUGGING
	// ConsistencyGroupTieringTypeControlRequired captures enum value "required"
	ConsistencyGroupTieringTypeControlRequired string = "required"
)

// prop value enum
func (m *ConsistencyGroupTieringType) validateControlEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupTieringTypeTypeControlPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupTieringType) validateControl(formats strfmt.Registry) error {
	if swag.IsZero(m.Control) { // not required
		return nil
	}

	// value enum
	if err := m.validateControlEnum("tiering"+"."+"control", "body", m.Control); err != nil {
		return err
	}

	return nil
}

var consistencyGroupTieringTypeTypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupTieringTypeTypePolicyPropEnum = append(consistencyGroupTieringTypeTypePolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// policy
	// Policy
	// all
	// END DEBUGGING
	// ConsistencyGroupTieringTypePolicyAll captures enum value "all"
	ConsistencyGroupTieringTypePolicyAll string = "all"

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// policy
	// Policy
	// auto
	// END DEBUGGING
	// ConsistencyGroupTieringTypePolicyAuto captures enum value "auto"
	ConsistencyGroupTieringTypePolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// policy
	// Policy
	// backup
	// END DEBUGGING
	// ConsistencyGroupTieringTypePolicyBackup captures enum value "backup"
	ConsistencyGroupTieringTypePolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// policy
	// Policy
	// none
	// END DEBUGGING
	// ConsistencyGroupTieringTypePolicyNone captures enum value "none"
	ConsistencyGroupTieringTypePolicyNone string = "none"

	// BEGIN DEBUGGING
	// ConsistencyGroupTieringType
	// ConsistencyGroupTieringType
	// policy
	// Policy
	// snapshot_only
	// END DEBUGGING
	// ConsistencyGroupTieringTypePolicySnapshotOnly captures enum value "snapshot_only"
	ConsistencyGroupTieringTypePolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *ConsistencyGroupTieringType) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupTieringTypeTypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupTieringType) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyEnum("tiering"+"."+"policy", "body", m.Policy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group tiering type based on context it is used
func (m *ConsistencyGroupTieringType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupTieringType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupTieringType) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupTieringType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumesItems0 consistency group volumes items0
//
// swagger:model ConsistencyGroupVolumesItems0
type ConsistencyGroupVolumesItems0 struct {

	// A comment for the volume. Valid in POST or PATCH.
	// Max Length: 1023
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// Language encoding setting for volume. If no language is specified, the volume inherits its SVM language encoding setting.
	// Enum: [ar ar.utf_8 c c.utf_8 cs cs.utf_8 da da.utf_8 de de.utf_8 en en.utf_8 en_us en_us.utf_8 es es.utf_8 fi fi.utf_8 fr fr.utf_8 he he.utf_8 hr hr.utf_8 hu hu.utf_8 it it.utf_8 ja ja.utf_8 ja_jp.932 ja_jp.932.utf_8 ja_jp.pck ja_jp.pck.utf_8 ja_jp.pck_v2 ja_jp.pck_v2.utf_8 ja_v1 ja_v1.utf_8 ko ko.utf_8 nl nl.utf_8 no no.utf_8 pl pl.utf_8 pt pt.utf_8 ro ro.utf_8 ru ru.utf_8 sk sk.utf_8 sl sl.utf_8 sv sv.utf_8 tr tr.utf_8 utf8mb4 zh zh.gbk zh.gbk.utf_8 zh.utf_8 zh_tw zh_tw.big5 zh_tw.big5.utf_8 zh_tw.utf_8]
	Language string `json:"language,omitempty"`

	// Volume name. The name of volume must start with an alphabetic character (a to z or A to Z) or an underscore (_). The name must be 197 or fewer characters in length for FlexGroups, and 203 or fewer characters in length for all other types of volumes. Volume names must be unique within an SVM. Required on POST.
	// Example: vol_cs_dept
	// Max Length: 203
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// provisioning options
	ProvisioningOptions *ConsistencyGroupVolumesItems0ProvisioningOptions `json:"provisioning_options,omitempty"`

	// qos
	Qos *ConsistencyGroupVolumesItems0Qos `json:"qos,omitempty"`

	// The Snapshot copy policy for this volume.
	//
	SnapshotPolicy *SnapshotPolicyReference `json:"snapshot_policy,omitempty"`

	// space
	Space *ConsistencyGroupVolumesItems0Space `json:"space,omitempty"`

	// tiering
	Tiering *ConsistencyGroupVolumesItems0Tiering `json:"tiering,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volumes items0
func (m *ConsistencyGroupVolumesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisioningOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 1023); err != nil {
		return err
	}

	return nil
}

var consistencyGroupVolumesItems0TypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","ar.utf_8","c","c.utf_8","cs","cs.utf_8","da","da.utf_8","de","de.utf_8","en","en.utf_8","en_us","en_us.utf_8","es","es.utf_8","fi","fi.utf_8","fr","fr.utf_8","he","he.utf_8","hr","hr.utf_8","hu","hu.utf_8","it","it.utf_8","ja","ja.utf_8","ja_jp.932","ja_jp.932.utf_8","ja_jp.pck","ja_jp.pck.utf_8","ja_jp.pck_v2","ja_jp.pck_v2.utf_8","ja_v1","ja_v1.utf_8","ko","ko.utf_8","nl","nl.utf_8","no","no.utf_8","pl","pl.utf_8","pt","pt.utf_8","ro","ro.utf_8","ru","ru.utf_8","sk","sk.utf_8","sl","sl.utf_8","sv","sv.utf_8","tr","tr.utf_8","utf8mb4","zh","zh.gbk","zh.gbk.utf_8","zh.utf_8","zh_tw","zh_tw.big5","zh_tw.big5.utf_8","zh_tw.utf_8"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumesItems0TypeLanguagePropEnum = append(consistencyGroupVolumesItems0TypeLanguagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ar
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageAr captures enum value "ar"
	ConsistencyGroupVolumesItems0LanguageAr string = "ar"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ar.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageArDotUTF8 captures enum value "ar.utf_8"
	ConsistencyGroupVolumesItems0LanguageArDotUTF8 string = "ar.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// c
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageC captures enum value "c"
	ConsistencyGroupVolumesItems0LanguageC string = "c"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// c.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageCDotUTF8 captures enum value "c.utf_8"
	ConsistencyGroupVolumesItems0LanguageCDotUTF8 string = "c.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// cs
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageCs captures enum value "cs"
	ConsistencyGroupVolumesItems0LanguageCs string = "cs"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// cs.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageCsDotUTF8 captures enum value "cs.utf_8"
	ConsistencyGroupVolumesItems0LanguageCsDotUTF8 string = "cs.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// da
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageDa captures enum value "da"
	ConsistencyGroupVolumesItems0LanguageDa string = "da"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// da.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageDaDotUTF8 captures enum value "da.utf_8"
	ConsistencyGroupVolumesItems0LanguageDaDotUTF8 string = "da.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// de
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageDe captures enum value "de"
	ConsistencyGroupVolumesItems0LanguageDe string = "de"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// de.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageDeDotUTF8 captures enum value "de.utf_8"
	ConsistencyGroupVolumesItems0LanguageDeDotUTF8 string = "de.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// en
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageEn captures enum value "en"
	ConsistencyGroupVolumesItems0LanguageEn string = "en"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// en.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageEnDotUTF8 captures enum value "en.utf_8"
	ConsistencyGroupVolumesItems0LanguageEnDotUTF8 string = "en.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// en_us
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageEnUs captures enum value "en_us"
	ConsistencyGroupVolumesItems0LanguageEnUs string = "en_us"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// en_us.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageEnUsDotUTF8 captures enum value "en_us.utf_8"
	ConsistencyGroupVolumesItems0LanguageEnUsDotUTF8 string = "en_us.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// es
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageEs captures enum value "es"
	ConsistencyGroupVolumesItems0LanguageEs string = "es"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// es.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageEsDotUTF8 captures enum value "es.utf_8"
	ConsistencyGroupVolumesItems0LanguageEsDotUTF8 string = "es.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// fi
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageFi captures enum value "fi"
	ConsistencyGroupVolumesItems0LanguageFi string = "fi"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// fi.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageFiDotUTF8 captures enum value "fi.utf_8"
	ConsistencyGroupVolumesItems0LanguageFiDotUTF8 string = "fi.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// fr
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageFr captures enum value "fr"
	ConsistencyGroupVolumesItems0LanguageFr string = "fr"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// fr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageFrDotUTF8 captures enum value "fr.utf_8"
	ConsistencyGroupVolumesItems0LanguageFrDotUTF8 string = "fr.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// he
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageHe captures enum value "he"
	ConsistencyGroupVolumesItems0LanguageHe string = "he"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// he.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageHeDotUTF8 captures enum value "he.utf_8"
	ConsistencyGroupVolumesItems0LanguageHeDotUTF8 string = "he.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// hr
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageHr captures enum value "hr"
	ConsistencyGroupVolumesItems0LanguageHr string = "hr"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// hr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageHrDotUTF8 captures enum value "hr.utf_8"
	ConsistencyGroupVolumesItems0LanguageHrDotUTF8 string = "hr.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// hu
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageHu captures enum value "hu"
	ConsistencyGroupVolumesItems0LanguageHu string = "hu"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// hu.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageHuDotUTF8 captures enum value "hu.utf_8"
	ConsistencyGroupVolumesItems0LanguageHuDotUTF8 string = "hu.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// it
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageIt captures enum value "it"
	ConsistencyGroupVolumesItems0LanguageIt string = "it"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// it.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageItDotUTF8 captures enum value "it.utf_8"
	ConsistencyGroupVolumesItems0LanguageItDotUTF8 string = "it.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJa captures enum value "ja"
	ConsistencyGroupVolumesItems0LanguageJa string = "ja"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaDotUTF8 captures enum value "ja.utf_8"
	ConsistencyGroupVolumesItems0LanguageJaDotUTF8 string = "ja.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_jp.932
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaJpDot932 captures enum value "ja_jp.932"
	ConsistencyGroupVolumesItems0LanguageJaJpDot932 string = "ja_jp.932"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_jp.932.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaJpDot932DotUTF8 captures enum value "ja_jp.932.utf_8"
	ConsistencyGroupVolumesItems0LanguageJaJpDot932DotUTF8 string = "ja_jp.932.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_jp.pck
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaJpDotPck captures enum value "ja_jp.pck"
	ConsistencyGroupVolumesItems0LanguageJaJpDotPck string = "ja_jp.pck"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_jp.pck.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaJpDotPckDotUTF8 captures enum value "ja_jp.pck.utf_8"
	ConsistencyGroupVolumesItems0LanguageJaJpDotPckDotUTF8 string = "ja_jp.pck.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_jp.pck_v2
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaJpDotPckV2 captures enum value "ja_jp.pck_v2"
	ConsistencyGroupVolumesItems0LanguageJaJpDotPckV2 string = "ja_jp.pck_v2"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_jp.pck_v2.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaJpDotPckV2DotUTF8 captures enum value "ja_jp.pck_v2.utf_8"
	ConsistencyGroupVolumesItems0LanguageJaJpDotPckV2DotUTF8 string = "ja_jp.pck_v2.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_v1
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaV1 captures enum value "ja_v1"
	ConsistencyGroupVolumesItems0LanguageJaV1 string = "ja_v1"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ja_v1.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageJaV1DotUTF8 captures enum value "ja_v1.utf_8"
	ConsistencyGroupVolumesItems0LanguageJaV1DotUTF8 string = "ja_v1.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ko
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageKo captures enum value "ko"
	ConsistencyGroupVolumesItems0LanguageKo string = "ko"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ko.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageKoDotUTF8 captures enum value "ko.utf_8"
	ConsistencyGroupVolumesItems0LanguageKoDotUTF8 string = "ko.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// nl
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageNl captures enum value "nl"
	ConsistencyGroupVolumesItems0LanguageNl string = "nl"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// nl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageNlDotUTF8 captures enum value "nl.utf_8"
	ConsistencyGroupVolumesItems0LanguageNlDotUTF8 string = "nl.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// no
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageNo captures enum value "no"
	ConsistencyGroupVolumesItems0LanguageNo string = "no"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// no.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageNoDotUTF8 captures enum value "no.utf_8"
	ConsistencyGroupVolumesItems0LanguageNoDotUTF8 string = "no.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// pl
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguagePl captures enum value "pl"
	ConsistencyGroupVolumesItems0LanguagePl string = "pl"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// pl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguagePlDotUTF8 captures enum value "pl.utf_8"
	ConsistencyGroupVolumesItems0LanguagePlDotUTF8 string = "pl.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// pt
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguagePt captures enum value "pt"
	ConsistencyGroupVolumesItems0LanguagePt string = "pt"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// pt.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguagePtDotUTF8 captures enum value "pt.utf_8"
	ConsistencyGroupVolumesItems0LanguagePtDotUTF8 string = "pt.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ro
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageRo captures enum value "ro"
	ConsistencyGroupVolumesItems0LanguageRo string = "ro"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ro.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageRoDotUTF8 captures enum value "ro.utf_8"
	ConsistencyGroupVolumesItems0LanguageRoDotUTF8 string = "ro.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ru
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageRu captures enum value "ru"
	ConsistencyGroupVolumesItems0LanguageRu string = "ru"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// ru.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageRuDotUTF8 captures enum value "ru.utf_8"
	ConsistencyGroupVolumesItems0LanguageRuDotUTF8 string = "ru.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// sk
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageSk captures enum value "sk"
	ConsistencyGroupVolumesItems0LanguageSk string = "sk"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// sk.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageSkDotUTF8 captures enum value "sk.utf_8"
	ConsistencyGroupVolumesItems0LanguageSkDotUTF8 string = "sk.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// sl
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageSl captures enum value "sl"
	ConsistencyGroupVolumesItems0LanguageSl string = "sl"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// sl.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageSlDotUTF8 captures enum value "sl.utf_8"
	ConsistencyGroupVolumesItems0LanguageSlDotUTF8 string = "sl.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// sv
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageSv captures enum value "sv"
	ConsistencyGroupVolumesItems0LanguageSv string = "sv"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// sv.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageSvDotUTF8 captures enum value "sv.utf_8"
	ConsistencyGroupVolumesItems0LanguageSvDotUTF8 string = "sv.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// tr
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageTr captures enum value "tr"
	ConsistencyGroupVolumesItems0LanguageTr string = "tr"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// tr.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageTrDotUTF8 captures enum value "tr.utf_8"
	ConsistencyGroupVolumesItems0LanguageTrDotUTF8 string = "tr.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// utf8mb4
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageUtf8mb4 captures enum value "utf8mb4"
	ConsistencyGroupVolumesItems0LanguageUtf8mb4 string = "utf8mb4"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZh captures enum value "zh"
	ConsistencyGroupVolumesItems0LanguageZh string = "zh"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh.gbk
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZhDotGbk captures enum value "zh.gbk"
	ConsistencyGroupVolumesItems0LanguageZhDotGbk string = "zh.gbk"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh.gbk.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZhDotGbkDotUTF8 captures enum value "zh.gbk.utf_8"
	ConsistencyGroupVolumesItems0LanguageZhDotGbkDotUTF8 string = "zh.gbk.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZhDotUTF8 captures enum value "zh.utf_8"
	ConsistencyGroupVolumesItems0LanguageZhDotUTF8 string = "zh.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh_tw
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZhTw captures enum value "zh_tw"
	ConsistencyGroupVolumesItems0LanguageZhTw string = "zh_tw"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh_tw.big5
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZhTwDotBig5 captures enum value "zh_tw.big5"
	ConsistencyGroupVolumesItems0LanguageZhTwDotBig5 string = "zh_tw.big5"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh_tw.big5.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZhTwDotBig5DotUTF8 captures enum value "zh_tw.big5.utf_8"
	ConsistencyGroupVolumesItems0LanguageZhTwDotBig5DotUTF8 string = "zh_tw.big5.utf_8"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0
	// ConsistencyGroupVolumesItems0
	// language
	// Language
	// zh_tw.utf_8
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0LanguageZhTwDotUTF8 captures enum value "zh_tw.utf_8"
	ConsistencyGroupVolumesItems0LanguageZhTwDotUTF8 string = "zh_tw.utf_8"
)

// prop value enum
func (m *ConsistencyGroupVolumesItems0) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumesItems0TypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(m.Language) { // not required
		return nil
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", m.Language); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 203); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateProvisioningOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ProvisioningOptions) { // not required
		return nil
	}

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volumes items0 based on the context it is used
func (m *ConsistencyGroupVolumesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProvisioningOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0) contextValidateProvisioningOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ProvisioningOptions != nil {
		if err := m.ProvisioningOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumesItems0ProvisioningOptions Options that are applied to the operation.
//
// swagger:model ConsistencyGroupVolumesItems0ProvisioningOptions
type ConsistencyGroupVolumesItems0ProvisioningOptions struct {

	// Operation to perform
	// Enum: [create add]
	Action string `json:"action,omitempty"`

	// Number of elements to perform the operation on.
	Count int64 `json:"count,omitempty"`

	// storage service
	StorageService *ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService `json:"storage_service,omitempty"`
}

// Validate validates this consistency group volumes items0 provisioning options
func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumesItems0ProvisioningOptionsTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create","add"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumesItems0ProvisioningOptionsTypeActionPropEnum = append(consistencyGroupVolumesItems0ProvisioningOptionsTypeActionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptions
	// ConsistencyGroupVolumesItems0ProvisioningOptions
	// action
	// Action
	// create
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsActionCreate captures enum value "create"
	ConsistencyGroupVolumesItems0ProvisioningOptionsActionCreate string = "create"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptions
	// ConsistencyGroupVolumesItems0ProvisioningOptions
	// action
	// Action
	// add
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsActionAdd captures enum value "add"
	ConsistencyGroupVolumesItems0ProvisioningOptionsActionAdd string = "add"
)

// prop value enum
func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumesItems0ProvisioningOptionsTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("provisioning_options"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volumes items0 provisioning options based on the context it is used
func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisioning_options" + "." + "storage_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0ProvisioningOptions) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumesItems0ProvisioningOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService Determines the placement of any storage object created during this operation.
//
//
// swagger:model ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
type ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService struct {

	// Storage service name. If not specified, the default value is the most performant for the platform.
	//
	// Enum: [extreme performance value]
	Name string `json:"name,omitempty"`
}

// Validate validates this consistency group volumes items0 provisioning options storage service
func (m *ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum = append(consistencyGroupVolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
	// name
	// Name
	// extreme
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageServiceNameExtreme captures enum value "extreme"
	ConsistencyGroupVolumesItems0ProvisioningOptionsStorageServiceNameExtreme string = "extreme"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
	// name
	// Name
	// performance
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageServiceNamePerformance captures enum value "performance"
	ConsistencyGroupVolumesItems0ProvisioningOptionsStorageServiceNamePerformance string = "performance"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
	// name
	// Name
	// value
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0ProvisioningOptionsStorageServiceNameValue captures enum value "value"
	ConsistencyGroupVolumesItems0ProvisioningOptionsStorageServiceNameValue string = "value"
)

// prop value enum
func (m *ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumesItems0ProvisioningOptionsStorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("provisioning_options"+"."+"storage_service"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group volumes items0 provisioning options storage service based on context it is used
func (m *ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumesItems0ProvisioningOptionsStorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumesItems0Qos The QoS policy for this volume.
//
//
// swagger:model ConsistencyGroupVolumesItems0Qos
type ConsistencyGroupVolumesItems0Qos struct {

	// policy
	Policy *ConsistencyGroupVolumesItems0QosPolicy `json:"policy,omitempty"`
}

// Validate validates this consistency group volumes items0 qos
func (m *ConsistencyGroupVolumesItems0Qos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0Qos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volumes items0 qos based on the context it is used
func (m *ConsistencyGroupVolumesItems0Qos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0Qos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0Qos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0Qos) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumesItems0Qos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumesItems0QosPolicy The QoS policy
//
//
// swagger:model ConsistencyGroupVolumesItems0QosPolicy
type ConsistencyGroupVolumesItems0QosPolicy struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this consistency group volumes items0 qos policy
func (m *ConsistencyGroupVolumesItems0QosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0QosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this consistency group volumes items0 qos policy based on the context it is used
func (m *ConsistencyGroupVolumesItems0QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0QosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0QosPolicy) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumesItems0QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumesItems0Space consistency group volumes items0 space
//
// swagger:model ConsistencyGroupVolumesItems0Space
type ConsistencyGroupVolumesItems0Space struct {

	// The available space, in bytes.
	Available int64 `json:"available,omitempty"`

	// Total provisioned size, in bytes.
	Size int64 `json:"size,omitempty"`

	// The virtual space used (includes volume reserves) before storage efficiency, in bytes.
	Used int64 `json:"used,omitempty"`
}

// Validate validates this consistency group volumes items0 space
func (m *ConsistencyGroupVolumesItems0Space) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this consistency group volumes items0 space based on context it is used
func (m *ConsistencyGroupVolumesItems0Space) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0Space) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0Space) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumesItems0Space
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConsistencyGroupVolumesItems0Tiering The tiering placement and policy definitions for this volume.
//
//
// swagger:model ConsistencyGroupVolumesItems0Tiering
type ConsistencyGroupVolumesItems0Tiering struct {

	// Storage tiering placement rules for the object.
	// Enum: [allowed best_effort disallowed required]
	Control string `json:"control,omitempty"`

	// Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold.
	// <br>FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br/>all &dash; Allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br/>auto &dash; Allows tiering of both snapshot and active file system user data to the cloud store<br/>none &dash; Volume blocks are not be tiered to the cloud store.<br/>snapshot_only &dash; Allows tiering of only the volume Snapshot copies not associated with the active file system.
	// <br>The default tiering policy is "snapshot-only" for a FlexVol volume and "none" for a FlexGroup volume. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy it is 31 days.
	//
	// Enum: [all auto backup none snapshot_only]
	Policy string `json:"policy,omitempty"`
}

// Validate validates this consistency group volumes items0 tiering
func (m *ConsistencyGroupVolumesItems0Tiering) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var consistencyGroupVolumesItems0TieringTypeControlPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["allowed","best_effort","disallowed","required"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumesItems0TieringTypeControlPropEnum = append(consistencyGroupVolumesItems0TieringTypeControlPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// control
	// Control
	// allowed
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringControlAllowed captures enum value "allowed"
	ConsistencyGroupVolumesItems0TieringControlAllowed string = "allowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// control
	// Control
	// best_effort
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringControlBestEffort captures enum value "best_effort"
	ConsistencyGroupVolumesItems0TieringControlBestEffort string = "best_effort"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// control
	// Control
	// disallowed
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringControlDisallowed captures enum value "disallowed"
	ConsistencyGroupVolumesItems0TieringControlDisallowed string = "disallowed"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// control
	// Control
	// required
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringControlRequired captures enum value "required"
	ConsistencyGroupVolumesItems0TieringControlRequired string = "required"
)

// prop value enum
func (m *ConsistencyGroupVolumesItems0Tiering) validateControlEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumesItems0TieringTypeControlPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0Tiering) validateControl(formats strfmt.Registry) error {
	if swag.IsZero(m.Control) { // not required
		return nil
	}

	// value enum
	if err := m.validateControlEnum("tiering"+"."+"control", "body", m.Control); err != nil {
		return err
	}

	return nil
}

var consistencyGroupVolumesItems0TieringTypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		consistencyGroupVolumesItems0TieringTypePolicyPropEnum = append(consistencyGroupVolumesItems0TieringTypePolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// policy
	// Policy
	// all
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringPolicyAll captures enum value "all"
	ConsistencyGroupVolumesItems0TieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// policy
	// Policy
	// auto
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringPolicyAuto captures enum value "auto"
	ConsistencyGroupVolumesItems0TieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// policy
	// Policy
	// backup
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringPolicyBackup captures enum value "backup"
	ConsistencyGroupVolumesItems0TieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// policy
	// Policy
	// none
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringPolicyNone captures enum value "none"
	ConsistencyGroupVolumesItems0TieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// ConsistencyGroupVolumesItems0Tiering
	// ConsistencyGroupVolumesItems0Tiering
	// policy
	// Policy
	// snapshot_only
	// END DEBUGGING
	// ConsistencyGroupVolumesItems0TieringPolicySnapshotOnly captures enum value "snapshot_only"
	ConsistencyGroupVolumesItems0TieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *ConsistencyGroupVolumesItems0Tiering) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, consistencyGroupVolumesItems0TieringTypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConsistencyGroupVolumesItems0Tiering) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyEnum("tiering"+"."+"policy", "body", m.Policy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this consistency group volumes items0 tiering based on context it is used
func (m *ConsistencyGroupVolumesItems0Tiering) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0Tiering) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConsistencyGroupVolumesItems0Tiering) UnmarshalBinary(b []byte) error {
	var res ConsistencyGroupVolumesItems0Tiering
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

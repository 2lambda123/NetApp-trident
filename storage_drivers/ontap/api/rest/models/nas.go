// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Nas A generic NAS application.
//
// swagger:model nas
type Nas struct {

	// application components
	// Required: true
	// Max Items: 10
	// Min Items: 1
	ApplicationComponents []*NasApplicationComponentsItems0 `json:"application_components"`

	// The list of CIFS access controls.
	CifsAccess []*AppCifsAccess `json:"cifs_access,omitempty"`

	// The list of NFS access controls.
	NfsAccess []*AppNfsAccess `json:"nfs_access,omitempty"`

	// protection type
	ProtectionType *NasProtectionType `json:"protection_type,omitempty"`
}

// Validate validates this nas
func (m *Nas) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplicationComponents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCifsAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Nas) validateApplicationComponents(formats strfmt.Registry) error {

	if err := validate.Required("application_components", "body", m.ApplicationComponents); err != nil {
		return err
	}

	iApplicationComponentsSize := int64(len(m.ApplicationComponents))

	if err := validate.MinItems("application_components", "body", iApplicationComponentsSize, 1); err != nil {
		return err
	}

	if err := validate.MaxItems("application_components", "body", iApplicationComponentsSize, 10); err != nil {
		return err
	}

	for i := 0; i < len(m.ApplicationComponents); i++ {
		if swag.IsZero(m.ApplicationComponents[i]) { // not required
			continue
		}

		if m.ApplicationComponents[i] != nil {
			if err := m.ApplicationComponents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("application_components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) validateCifsAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.CifsAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.CifsAccess); i++ {
		if swag.IsZero(m.CifsAccess[i]) { // not required
			continue
		}

		if m.CifsAccess[i] != nil {
			if err := m.CifsAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) validateNfsAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsAccess) { // not required
		return nil
	}

	for i := 0; i < len(m.NfsAccess); i++ {
		if swag.IsZero(m.NfsAccess[i]) { // not required
			continue
		}

		if m.NfsAccess[i] != nil {
			if err := m.NfsAccess[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) validateProtectionType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionType) { // not required
		return nil
	}

	if m.ProtectionType != nil {
		if err := m.ProtectionType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protection_type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas based on the context it is used
func (m *Nas) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApplicationComponents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCifsAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfsAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtectionType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Nas) contextValidateApplicationComponents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ApplicationComponents); i++ {

		if m.ApplicationComponents[i] != nil {
			if err := m.ApplicationComponents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("application_components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) contextValidateCifsAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CifsAccess); i++ {

		if m.CifsAccess[i] != nil {
			if err := m.CifsAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cifs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) contextValidateNfsAccess(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NfsAccess); i++ {

		if m.NfsAccess[i] != nil {
			if err := m.NfsAccess[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nfs_access" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Nas) contextValidateProtectionType(ctx context.Context, formats strfmt.Registry) error {

	if m.ProtectionType != nil {
		if err := m.ProtectionType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("protection_type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Nas) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Nas) UnmarshalBinary(b []byte) error {
	var res Nas
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0 nas application components items0
//
// swagger:model NasApplicationComponentsItems0
type NasApplicationComponentsItems0 struct {

	// flexcache
	Flexcache *NasApplicationComponentsItems0Flexcache `json:"flexcache,omitempty"`

	// The name of the application component.
	// Required: true
	// Max Length: 512
	// Min Length: 1
	Name *string `json:"name"`

	// Denotes a Flexgroup.
	// Enum: [false true]
	ScaleOut bool `json:"scale_out,omitempty"`

	// The number of shares in the application component.
	// Required: true
	// Maximum: 10
	// Minimum: 1
	ShareCount *int64 `json:"share_count"`

	// storage service
	StorageService *NasApplicationComponentsItems0StorageService `json:"storage_service,omitempty"`

	// tiering
	Tiering *NasApplicationComponentsTiering `json:"tiering,omitempty"`

	// The total size of the application component, split across the member shares. Usage: {&lt;integer&gt;[KB|MB|GB|TB|PB]}
	// Required: true
	TotalSize *int64 `json:"total_size"`
}

// Validate validates this nas application components items0
func (m *NasApplicationComponentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFlexcache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScaleOut(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShareCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0) validateFlexcache(formats strfmt.Registry) error {
	if swag.IsZero(m.Flexcache) { // not required
		return nil
	}

	if m.Flexcache != nil {
		if err := m.Flexcache.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 512); err != nil {
		return err
	}

	return nil
}

var nasApplicationComponentsItems0TypeScaleOutPropEnum []interface{}

func init() {
	var res []bool
	if err := json.Unmarshal([]byte(`[false,true]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0TypeScaleOutPropEnum = append(nasApplicationComponentsItems0TypeScaleOutPropEnum, v)
	}
}

// prop value enum
func (m *NasApplicationComponentsItems0) validateScaleOutEnum(path, location string, value bool) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0TypeScaleOutPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0) validateScaleOut(formats strfmt.Registry) error {
	if swag.IsZero(m.ScaleOut) { // not required
		return nil
	}

	// value enum
	if err := m.validateScaleOutEnum("scale_out", "body", m.ScaleOut); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateShareCount(formats strfmt.Registry) error {

	if err := validate.Required("share_count", "body", m.ShareCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("share_count", "body", *m.ShareCount, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("share_count", "body", *m.ShareCount, 10, false); err != nil {
		return err
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateStorageService(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageService) { // not required
		return nil
	}

	if m.StorageService != nil {
		if err := m.StorageService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) validateTotalSize(formats strfmt.Registry) error {

	if err := validate.Required("total_size", "body", m.TotalSize); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nas application components items0 based on the context it is used
func (m *NasApplicationComponentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFlexcache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateFlexcache(ctx context.Context, formats strfmt.Registry) error {

	if m.Flexcache != nil {
		if err := m.Flexcache.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateStorageService(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageService != nil {
		if err := m.StorageService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_service")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0Flexcache nas application components items0 flexcache
//
// swagger:model NasApplicationComponentsItems0Flexcache
type NasApplicationComponentsItems0Flexcache struct {

	// origin
	Origin *NasApplicationComponentsItems0FlexcacheOrigin `json:"origin,omitempty"`
}

// Validate validates this nas application components items0 flexcache
func (m *NasApplicationComponentsItems0Flexcache) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0Flexcache) validateOrigin(formats strfmt.Registry) error {
	if swag.IsZero(m.Origin) { // not required
		return nil
	}

	if m.Origin != nil {
		if err := m.Origin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas application components items0 flexcache based on the context it is used
func (m *NasApplicationComponentsItems0Flexcache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateOrigin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0Flexcache) contextValidateOrigin(ctx context.Context, formats strfmt.Registry) error {

	if m.Origin != nil {
		if err := m.Origin.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Flexcache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0Flexcache) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0Flexcache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0FlexcacheOrigin nas application components items0 flexcache origin
//
// swagger:model NasApplicationComponentsItems0FlexcacheOrigin
type NasApplicationComponentsItems0FlexcacheOrigin struct {

	// component
	// Required: true
	Component *NasApplicationComponentsItems0FlexcacheOriginComponent `json:"component"`

	// svm
	// Required: true
	Svm *NasApplicationComponentsItems0FlexcacheOriginSvm `json:"svm"`
}

// Validate validates this nas application components items0 flexcache origin
func (m *NasApplicationComponentsItems0FlexcacheOrigin) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComponent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) validateComponent(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"component", "body", m.Component); err != nil {
		return err
	}

	if m.Component != nil {
		if err := m.Component.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "component")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) validateSvm(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"svm", "body", m.Svm); err != nil {
		return err
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas application components items0 flexcache origin based on the context it is used
func (m *NasApplicationComponentsItems0FlexcacheOrigin) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComponent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) contextValidateComponent(ctx context.Context, formats strfmt.Registry) error {

	if m.Component != nil {
		if err := m.Component.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "component")
			}
			return err
		}
	}

	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOrigin) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexcache" + "." + "origin" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOrigin) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOrigin) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0FlexcacheOrigin
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0FlexcacheOriginComponent nas application components items0 flexcache origin component
//
// swagger:model NasApplicationComponentsItems0FlexcacheOriginComponent
type NasApplicationComponentsItems0FlexcacheOriginComponent struct {

	// Name of the source component.
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this nas application components items0 flexcache origin component
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) validateName(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"component"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas application components items0 flexcache origin component based on context it is used
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginComponent) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0FlexcacheOriginComponent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0FlexcacheOriginSvm nas application components items0 flexcache origin svm
//
// swagger:model NasApplicationComponentsItems0FlexcacheOriginSvm
type NasApplicationComponentsItems0FlexcacheOriginSvm struct {

	// Name of the source SVM.
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this nas application components items0 flexcache origin svm
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) validateName(formats strfmt.Registry) error {

	if err := validate.Required("flexcache"+"."+"origin"+"."+"svm"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas application components items0 flexcache origin svm based on context it is used
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0FlexcacheOriginSvm) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0FlexcacheOriginSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasApplicationComponentsItems0StorageService nas application components items0 storage service
//
// swagger:model NasApplicationComponentsItems0StorageService
type NasApplicationComponentsItems0StorageService struct {

	// The storage service of the application component.
	// Enum: [extreme performance value]
	Name *string `json:"name,omitempty"`
}

// Validate validates this nas application components items0 storage service
func (m *NasApplicationComponentsItems0StorageService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasApplicationComponentsItems0StorageServiceTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["extreme","performance","value"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasApplicationComponentsItems0StorageServiceTypeNamePropEnum = append(nasApplicationComponentsItems0StorageServiceTypeNamePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NasApplicationComponentsItems0StorageService
	// NasApplicationComponentsItems0StorageService
	// name
	// Name
	// extreme
	// END RIPPY DEBUGGING
	// NasApplicationComponentsItems0StorageServiceNameExtreme captures enum value "extreme"
	NasApplicationComponentsItems0StorageServiceNameExtreme string = "extreme"

	// BEGIN RIPPY DEBUGGING
	// NasApplicationComponentsItems0StorageService
	// NasApplicationComponentsItems0StorageService
	// name
	// Name
	// performance
	// END RIPPY DEBUGGING
	// NasApplicationComponentsItems0StorageServiceNamePerformance captures enum value "performance"
	NasApplicationComponentsItems0StorageServiceNamePerformance string = "performance"

	// BEGIN RIPPY DEBUGGING
	// NasApplicationComponentsItems0StorageService
	// NasApplicationComponentsItems0StorageService
	// name
	// Name
	// value
	// END RIPPY DEBUGGING
	// NasApplicationComponentsItems0StorageServiceNameValue captures enum value "value"
	NasApplicationComponentsItems0StorageServiceNameValue string = "value"
)

// prop value enum
func (m *NasApplicationComponentsItems0StorageService) validateNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasApplicationComponentsItems0StorageServiceTypeNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasApplicationComponentsItems0StorageService) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	// value enum
	if err := m.validateNameEnum("storage_service"+"."+"name", "body", *m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas application components items0 storage service based on context it is used
func (m *NasApplicationComponentsItems0StorageService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasApplicationComponentsItems0StorageService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasApplicationComponentsItems0StorageService) UnmarshalBinary(b []byte) error {
	var res NasApplicationComponentsItems0StorageService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NasProtectionType nas protection type
//
// swagger:model NasProtectionType
type NasProtectionType struct {

	// The snapshot policy to apply to each volume in the smart container. This property is only supported for smart containers. Usage: &lt;snapshot policy&gt;
	LocalPolicy string `json:"local_policy,omitempty"`

	// The local rpo of the application.
	// Enum: [hourly none]
	LocalRpo string `json:"local_rpo,omitempty"`

	// The remote rpo of the application.
	// Enum: [none zero]
	RemoteRpo string `json:"remote_rpo,omitempty"`
}

// Validate validates this nas protection type
func (m *NasProtectionType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocalRpo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteRpo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasProtectionTypeTypeLocalRpoPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["hourly","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasProtectionTypeTypeLocalRpoPropEnum = append(nasProtectionTypeTypeLocalRpoPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NasProtectionType
	// NasProtectionType
	// local_rpo
	// LocalRpo
	// hourly
	// END RIPPY DEBUGGING
	// NasProtectionTypeLocalRpoHourly captures enum value "hourly"
	NasProtectionTypeLocalRpoHourly string = "hourly"

	// BEGIN RIPPY DEBUGGING
	// NasProtectionType
	// NasProtectionType
	// local_rpo
	// LocalRpo
	// none
	// END RIPPY DEBUGGING
	// NasProtectionTypeLocalRpoNone captures enum value "none"
	NasProtectionTypeLocalRpoNone string = "none"
)

// prop value enum
func (m *NasProtectionType) validateLocalRpoEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasProtectionTypeTypeLocalRpoPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasProtectionType) validateLocalRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalRpo) { // not required
		return nil
	}

	// value enum
	if err := m.validateLocalRpoEnum("protection_type"+"."+"local_rpo", "body", m.LocalRpo); err != nil {
		return err
	}

	return nil
}

var nasProtectionTypeTypeRemoteRpoPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","zero"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasProtectionTypeTypeRemoteRpoPropEnum = append(nasProtectionTypeTypeRemoteRpoPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// NasProtectionType
	// NasProtectionType
	// remote_rpo
	// RemoteRpo
	// none
	// END RIPPY DEBUGGING
	// NasProtectionTypeRemoteRpoNone captures enum value "none"
	NasProtectionTypeRemoteRpoNone string = "none"

	// BEGIN RIPPY DEBUGGING
	// NasProtectionType
	// NasProtectionType
	// remote_rpo
	// RemoteRpo
	// zero
	// END RIPPY DEBUGGING
	// NasProtectionTypeRemoteRpoZero captures enum value "zero"
	NasProtectionTypeRemoteRpoZero string = "zero"
)

// prop value enum
func (m *NasProtectionType) validateRemoteRpoEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasProtectionTypeTypeRemoteRpoPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasProtectionType) validateRemoteRpo(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteRpo) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemoteRpoEnum("protection_type"+"."+"remote_rpo", "body", m.RemoteRpo); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this nas protection type based on context it is used
func (m *NasProtectionType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NasProtectionType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasProtectionType) UnmarshalBinary(b []byte) error {
	var res NasProtectionType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

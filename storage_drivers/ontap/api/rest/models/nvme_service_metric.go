// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NvmeServiceMetric Performance numbers, such as IOPS latency and throughput, for SVM protocols.
//
// swagger:model nvme_service_metric
type NvmeServiceMetric struct {

	// links
	Links *NvmeServiceMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// fc
	Fc *NvmeServiceMetricFc `json:"fc,omitempty"`

	// iops
	Iops *NvmeServiceMetricIops `json:"iops,omitempty"`

	// latency
	Latency *NvmeServiceMetricLatency `json:"latency,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// tcp
	TCP *NvmeServiceMetricTCP `json:"tcp,omitempty"`

	// throughput
	Throughput *NvmeServiceMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nvme service metric
func (m *NvmeServiceMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTCP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceMetricTypeDurationPropEnum = append(nvmeServiceMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// NvmeServiceMetricDurationPT15S captures enum value "PT15S"
	NvmeServiceMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// NvmeServiceMetricDurationPT4M captures enum value "PT4M"
	NvmeServiceMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// NvmeServiceMetricDurationPT30M captures enum value "PT30M"
	NvmeServiceMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// NvmeServiceMetricDurationPT2H captures enum value "PT2H"
	NvmeServiceMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// NvmeServiceMetricDurationP1D captures enum value "P1D"
	NvmeServiceMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// NvmeServiceMetricDurationPT5M captures enum value "PT5M"
	NvmeServiceMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *NvmeServiceMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetric) validateFc(formats strfmt.Registry) error {
	if swag.IsZero(m.Fc) { // not required
		return nil
	}

	if m.Fc != nil {
		if err := m.Fc.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceMetricTypeStatusPropEnum = append(nvmeServiceMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// NvmeServiceMetricStatusOk captures enum value "ok"
	NvmeServiceMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// NvmeServiceMetricStatusError captures enum value "error"
	NvmeServiceMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NvmeServiceMetricStatusPartialNoData captures enum value "partial_no_data"
	NvmeServiceMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NvmeServiceMetricStatusPartialNoResponse captures enum value "partial_no_response"
	NvmeServiceMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NvmeServiceMetricStatusPartialOtherError captures enum value "partial_other_error"
	NvmeServiceMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NvmeServiceMetricStatusNegativeDelta captures enum value "negative_delta"
	NvmeServiceMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// not_found
	// END DEBUGGING
	// NvmeServiceMetricStatusNotFound captures enum value "not_found"
	NvmeServiceMetricStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NvmeServiceMetricStatusBackfilledData captures enum value "backfilled_data"
	NvmeServiceMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NvmeServiceMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NvmeServiceMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NvmeServiceMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NvmeServiceMetricStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// nvme_service_metric
	// NvmeServiceMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NvmeServiceMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	NvmeServiceMetricStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *NvmeServiceMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetric) validateTCP(formats strfmt.Registry) error {
	if swag.IsZero(m.TCP) { // not required
		return nil
	}

	if m.TCP != nil {
		if err := m.TCP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nvme service metric based on the context it is used
func (m *NvmeServiceMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFc(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTCP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateFc(ctx context.Context, formats strfmt.Registry) error {

	if m.Fc != nil {
		if err := m.Fc.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iops")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latency")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateTCP(ctx context.Context, formats strfmt.Registry) error {

	if m.TCP != nil {
		if err := m.TCP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetric) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricFc The NVMe/FC portion of the aggregated metrics.
//
// swagger:model NvmeServiceMetricFc
type NvmeServiceMetricFc struct {

	// links
	Links *NvmeServiceMetricFcLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *NvmeServiceMetricFcIops `json:"iops,omitempty"`

	// latency
	Latency *NvmeServiceMetricFcLatency `json:"latency,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *NvmeServiceMetricFcThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nvme service metric fc
func (m *NvmeServiceMetricFc) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricFc) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceMetricFcTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceMetricFcTypeDurationPropEnum = append(nvmeServiceMetricFcTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// NvmeServiceMetricFcDurationPT15S captures enum value "PT15S"
	NvmeServiceMetricFcDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// NvmeServiceMetricFcDurationPT4M captures enum value "PT4M"
	NvmeServiceMetricFcDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// NvmeServiceMetricFcDurationPT30M captures enum value "PT30M"
	NvmeServiceMetricFcDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// NvmeServiceMetricFcDurationPT2H captures enum value "PT2H"
	NvmeServiceMetricFcDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// NvmeServiceMetricFcDurationP1D captures enum value "P1D"
	NvmeServiceMetricFcDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// NvmeServiceMetricFcDurationPT5M captures enum value "PT5M"
	NvmeServiceMetricFcDurationPT5M string = "PT5M"
)

// prop value enum
func (m *NvmeServiceMetricFc) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceMetricFcTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceMetricFc) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("fc"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricFc) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricFc) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceMetricFcTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceMetricFcTypeStatusPropEnum = append(nvmeServiceMetricFcTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// ok
	// END DEBUGGING
	// NvmeServiceMetricFcStatusOk captures enum value "ok"
	NvmeServiceMetricFcStatusOk string = "ok"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// error
	// END DEBUGGING
	// NvmeServiceMetricFcStatusError captures enum value "error"
	NvmeServiceMetricFcStatusError string = "error"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NvmeServiceMetricFcStatusPartialNoData captures enum value "partial_no_data"
	NvmeServiceMetricFcStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NvmeServiceMetricFcStatusPartialNoResponse captures enum value "partial_no_response"
	NvmeServiceMetricFcStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NvmeServiceMetricFcStatusPartialOtherError captures enum value "partial_other_error"
	NvmeServiceMetricFcStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NvmeServiceMetricFcStatusNegativeDelta captures enum value "negative_delta"
	NvmeServiceMetricFcStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// not_found
	// END DEBUGGING
	// NvmeServiceMetricFcStatusNotFound captures enum value "not_found"
	NvmeServiceMetricFcStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NvmeServiceMetricFcStatusBackfilledData captures enum value "backfilled_data"
	NvmeServiceMetricFcStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NvmeServiceMetricFcStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NvmeServiceMetricFcStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NvmeServiceMetricFcStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NvmeServiceMetricFcStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// NvmeServiceMetricFc
	// NvmeServiceMetricFc
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NvmeServiceMetricFcStatusPartialNoUUID captures enum value "partial_no_uuid"
	NvmeServiceMetricFcStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *NvmeServiceMetricFc) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceMetricFcTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceMetricFc) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("fc"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricFc) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricFc) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("fc"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nvme service metric fc based on the context it is used
func (m *NvmeServiceMetricFc) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricFc) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricFc) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fc"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricFc) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricFc) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricFc) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fc"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricFc) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricFc) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fc"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricFc) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricFc) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricFc
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricFcIops The rate of I/O operations observed at the storage object.
//
// swagger:model NvmeServiceMetricFcIops
type NvmeServiceMetricFcIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric fc iops
func (m *NvmeServiceMetricFcIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric fc iops based on the context it is used
func (m *NvmeServiceMetricFcIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricFcIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricFcIops) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricFcIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricFcLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model NvmeServiceMetricFcLatency
type NvmeServiceMetricFcLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric fc latency
func (m *NvmeServiceMetricFcLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric fc latency based on the context it is used
func (m *NvmeServiceMetricFcLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricFcLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricFcLatency) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricFcLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricFcLinks nvme service metric fc links
//
// swagger:model NvmeServiceMetricFcLinks
type NvmeServiceMetricFcLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this nvme service metric fc links
func (m *NvmeServiceMetricFcLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricFcLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nvme service metric fc links based on the context it is used
func (m *NvmeServiceMetricFcLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricFcLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricFcLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricFcLinks) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricFcLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricFcThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model NvmeServiceMetricFcThroughput
type NvmeServiceMetricFcThroughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric fc throughput
func (m *NvmeServiceMetricFcThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric fc throughput based on the context it is used
func (m *NvmeServiceMetricFcThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricFcThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricFcThroughput) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricFcThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model NvmeServiceMetricIops
type NvmeServiceMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric iops
func (m *NvmeServiceMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric iops based on the context it is used
func (m *NvmeServiceMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricIops) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model NvmeServiceMetricLatency
type NvmeServiceMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric latency
func (m *NvmeServiceMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric latency based on the context it is used
func (m *NvmeServiceMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricLatency) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricLinks nvme service metric links
//
// swagger:model NvmeServiceMetricLinks
type NvmeServiceMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this nvme service metric links
func (m *NvmeServiceMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nvme service metric links based on the context it is used
func (m *NvmeServiceMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricLinks) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricTCP The NVMe/TCP portion of the aggregated metrics.
//
// swagger:model NvmeServiceMetricTCP
type NvmeServiceMetricTCP struct {

	// links
	Links *NvmeServiceMetricTCPLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *NvmeServiceMetricTCPIops `json:"iops,omitempty"`

	// latency
	Latency *NvmeServiceMetricTCPLatency `json:"latency,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *NvmeServiceMetricTCPThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this nvme service metric TCP
func (m *NvmeServiceMetricTCP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricTCP) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceMetricTcpTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceMetricTcpTypeDurationPropEnum = append(nvmeServiceMetricTcpTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// NvmeServiceMetricTCPDurationPT15S captures enum value "PT15S"
	NvmeServiceMetricTCPDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// NvmeServiceMetricTCPDurationPT4M captures enum value "PT4M"
	NvmeServiceMetricTCPDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// NvmeServiceMetricTCPDurationPT30M captures enum value "PT30M"
	NvmeServiceMetricTCPDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// NvmeServiceMetricTCPDurationPT2H captures enum value "PT2H"
	NvmeServiceMetricTCPDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// NvmeServiceMetricTCPDurationP1D captures enum value "P1D"
	NvmeServiceMetricTCPDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// NvmeServiceMetricTCPDurationPT5M captures enum value "PT5M"
	NvmeServiceMetricTCPDurationPT5M string = "PT5M"
)

// prop value enum
func (m *NvmeServiceMetricTCP) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceMetricTcpTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceMetricTCP) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("tcp"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricTCP) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricTCP) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var nvmeServiceMetricTcpTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nvmeServiceMetricTcpTypeStatusPropEnum = append(nvmeServiceMetricTcpTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// ok
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusOk captures enum value "ok"
	NvmeServiceMetricTCPStatusOk string = "ok"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// error
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusError captures enum value "error"
	NvmeServiceMetricTCPStatusError string = "error"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusPartialNoData captures enum value "partial_no_data"
	NvmeServiceMetricTCPStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusPartialNoResponse captures enum value "partial_no_response"
	NvmeServiceMetricTCPStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusPartialOtherError captures enum value "partial_other_error"
	NvmeServiceMetricTCPStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusNegativeDelta captures enum value "negative_delta"
	NvmeServiceMetricTCPStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// not_found
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusNotFound captures enum value "not_found"
	NvmeServiceMetricTCPStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusBackfilledData captures enum value "backfilled_data"
	NvmeServiceMetricTCPStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	NvmeServiceMetricTCPStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusInconsistentOldData captures enum value "inconsistent_old_data"
	NvmeServiceMetricTCPStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// NvmeServiceMetricTCP
	// NvmeServiceMetricTCP
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// NvmeServiceMetricTCPStatusPartialNoUUID captures enum value "partial_no_uuid"
	NvmeServiceMetricTCPStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *NvmeServiceMetricTCP) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nvmeServiceMetricTcpTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NvmeServiceMetricTCP) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("tcp"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricTCP) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricTCP) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("tcp"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this nvme service metric TCP based on the context it is used
func (m *NvmeServiceMetricTCP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricTCP) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricTCP) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tcp"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricTCP) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricTCP) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricTCP) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tcp"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *NvmeServiceMetricTCP) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *NvmeServiceMetricTCP) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tcp"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricTCP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricTCP) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricTCP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricTCPIops The rate of I/O operations observed at the storage object.
//
// swagger:model NvmeServiceMetricTCPIops
type NvmeServiceMetricTCPIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric TCP iops
func (m *NvmeServiceMetricTCPIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric TCP iops based on the context it is used
func (m *NvmeServiceMetricTCPIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricTCPIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricTCPIops) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricTCPIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricTCPLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model NvmeServiceMetricTCPLatency
type NvmeServiceMetricTCPLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric TCP latency
func (m *NvmeServiceMetricTCPLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric TCP latency based on the context it is used
func (m *NvmeServiceMetricTCPLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricTCPLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricTCPLatency) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricTCPLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricTCPLinks nvme service metric TCP links
//
// swagger:model NvmeServiceMetricTCPLinks
type NvmeServiceMetricTCPLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this nvme service metric TCP links
func (m *NvmeServiceMetricTCPLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricTCPLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nvme service metric TCP links based on the context it is used
func (m *NvmeServiceMetricTCPLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NvmeServiceMetricTCPLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tcp" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricTCPLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricTCPLinks) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricTCPLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricTCPThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model NvmeServiceMetricTCPThroughput
type NvmeServiceMetricTCPThroughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric TCP throughput
func (m *NvmeServiceMetricTCPThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric TCP throughput based on the context it is used
func (m *NvmeServiceMetricTCPThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricTCPThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricTCPThroughput) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricTCPThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NvmeServiceMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model NvmeServiceMetricThroughput
type NvmeServiceMetricThroughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this nvme service metric throughput
func (m *NvmeServiceMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this nvme service metric throughput based on the context it is used
func (m *NvmeServiceMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *NvmeServiceMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NvmeServiceMetricThroughput) UnmarshalBinary(b []byte) error {
	var res NvmeServiceMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

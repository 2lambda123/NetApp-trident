// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// QosPolicy qos policy
//
// swagger:model qos_policy
type QosPolicy struct {

	// links
	Links *QosPolicyLinks `json:"_links,omitempty"`

	// adaptive
	Adaptive *QosPolicyAdaptive `json:"adaptive,omitempty"`

	// fixed
	Fixed *QosPolicyFixed `json:"fixed,omitempty"`

	// Name of the QoS policy.
	// Example: extreme
	Name string `json:"name,omitempty"`

	// Number of objects attached to this policy.
	// Read Only: true
	ObjectCount int64 `json:"object_count,omitempty"`

	// Policy group ID of the QoS policy.
	// Read Only: true
	Pgid int64 `json:"pgid,omitempty"`

	// Class of the QoS policy.
	// Read Only: true
	// Enum: [undefined preset user_defined system_defined autovolume load_control]
	PolicyClass string `json:"policy_class,omitempty"`

	// Scope of the entity. Set to "cluster" for cluster owned objects and to "svm" for SVM owned objects.
	// Enum: [cluster svm]
	Scope string `json:"scope,omitempty"`

	// svm
	Svm *QosPolicySvm `json:"svm,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this qos policy
func (m *QosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdaptive(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFixed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) validateAdaptive(formats strfmt.Registry) error {
	if swag.IsZero(m.Adaptive) { // not required
		return nil
	}

	if m.Adaptive != nil {
		if err := m.Adaptive.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adaptive")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) validateFixed(formats strfmt.Registry) error {
	if swag.IsZero(m.Fixed) { // not required
		return nil
	}

	if m.Fixed != nil {
		if err := m.Fixed.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fixed")
			}
			return err
		}
	}

	return nil
}

var qosPolicyTypePolicyClassPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["undefined","preset","user_defined","system_defined","autovolume","load_control"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		qosPolicyTypePolicyClassPropEnum = append(qosPolicyTypePolicyClassPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// policy_class
	// PolicyClass
	// undefined
	// END DEBUGGING
	// QosPolicyPolicyClassUndefined captures enum value "undefined"
	QosPolicyPolicyClassUndefined string = "undefined"

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// policy_class
	// PolicyClass
	// preset
	// END DEBUGGING
	// QosPolicyPolicyClassPreset captures enum value "preset"
	QosPolicyPolicyClassPreset string = "preset"

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// policy_class
	// PolicyClass
	// user_defined
	// END DEBUGGING
	// QosPolicyPolicyClassUserDefined captures enum value "user_defined"
	QosPolicyPolicyClassUserDefined string = "user_defined"

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// policy_class
	// PolicyClass
	// system_defined
	// END DEBUGGING
	// QosPolicyPolicyClassSystemDefined captures enum value "system_defined"
	QosPolicyPolicyClassSystemDefined string = "system_defined"

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// policy_class
	// PolicyClass
	// autovolume
	// END DEBUGGING
	// QosPolicyPolicyClassAutovolume captures enum value "autovolume"
	QosPolicyPolicyClassAutovolume string = "autovolume"

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// policy_class
	// PolicyClass
	// load_control
	// END DEBUGGING
	// QosPolicyPolicyClassLoadControl captures enum value "load_control"
	QosPolicyPolicyClassLoadControl string = "load_control"
)

// prop value enum
func (m *QosPolicy) validatePolicyClassEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, qosPolicyTypePolicyClassPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *QosPolicy) validatePolicyClass(formats strfmt.Registry) error {
	if swag.IsZero(m.PolicyClass) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyClassEnum("policy_class", "body", m.PolicyClass); err != nil {
		return err
	}

	return nil
}

var qosPolicyTypeScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["cluster","svm"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		qosPolicyTypeScopePropEnum = append(qosPolicyTypeScopePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// scope
	// Scope
	// cluster
	// END DEBUGGING
	// QosPolicyScopeCluster captures enum value "cluster"
	QosPolicyScopeCluster string = "cluster"

	// BEGIN DEBUGGING
	// qos_policy
	// QosPolicy
	// scope
	// Scope
	// svm
	// END DEBUGGING
	// QosPolicyScopeSvm captures enum value "svm"
	QosPolicyScopeSvm string = "svm"
)

// prop value enum
func (m *QosPolicy) validateScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, qosPolicyTypeScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *QosPolicy) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	// value enum
	if err := m.validateScopeEnum("scope", "body", m.Scope); err != nil {
		return err
	}

	return nil
}

func (m *QosPolicy) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy based on the context it is used
func (m *QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdaptive(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFixed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjectCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePgid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePolicyClass(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateAdaptive(ctx context.Context, formats strfmt.Registry) error {

	if m.Adaptive != nil {
		if err := m.Adaptive.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adaptive")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateFixed(ctx context.Context, formats strfmt.Registry) error {

	if m.Fixed != nil {
		if err := m.Fixed.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fixed")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateObjectCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "object_count", "body", int64(m.ObjectCount)); err != nil {
		return err
	}

	return nil
}

func (m *QosPolicy) contextValidatePgid(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "pgid", "body", int64(m.Pgid)); err != nil {
		return err
	}

	return nil
}

func (m *QosPolicy) contextValidatePolicyClass(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "policy_class", "body", string(m.PolicyClass)); err != nil {
		return err
	}

	return nil
}

func (m *QosPolicy) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicy) UnmarshalBinary(b []byte) error {
	var res QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicyAdaptive Adaptive QoS policy-groups define measurable service level objectives (SLOs) that adjust based on the storage object used space and the storage object allocated space.
//
// swagger:model QosPolicyAdaptive
type QosPolicyAdaptive struct {

	// Specifies the absolute minimum IOPS that is used as an override when the expected_iops is less than this value. These floors are not guaranteed on non-AFF platforms or when FabricPool tiering policies are set.
	AbsoluteMinIops int64 `json:"absolute_min_iops,omitempty"`

	// Specifies the block size
	// Enum: [any 4k 8k 16k 32k 64k 128k]
	BlockSize *string `json:"block_size,omitempty"`

	// Expected IOPS. Specifies the minimum expected IOPS per TB allocated based on the storage object allocated size. These floors are not guaranteed on non-AFF platforms or when FabricPool tiering policies are set.
	ExpectedIops int64 `json:"expected_iops,omitempty"`

	// Specifies the size to be used to calculate expected IOPS per TB. The size options are either the storage object allocated space or the storage object used space.
	// Enum: [used_space allocated_space]
	ExpectedIopsAllocation *string `json:"expected_iops_allocation,omitempty"`

	// Peak IOPS. Specifies the maximum possible IOPS per TB allocated based on the storage object allocated size or the storage object used size.
	PeakIops int64 `json:"peak_iops,omitempty"`

	// Specifies the size to be used to calculate peak IOPS per TB. The size options are either the storage object allocated space or the storage object used space.
	// Enum: [used_space allocated_space]
	PeakIopsAllocation *string `json:"peak_iops_allocation,omitempty"`
}

// Validate validates this qos policy adaptive
func (m *QosPolicyAdaptive) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpectedIopsAllocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeakIopsAllocation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var qosPolicyAdaptiveTypeBlockSizePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["any","4k","8k","16k","32k","64k","128k"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		qosPolicyAdaptiveTypeBlockSizePropEnum = append(qosPolicyAdaptiveTypeBlockSizePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// block_size
	// BlockSize
	// any
	// END DEBUGGING
	// QosPolicyAdaptiveBlockSizeAny captures enum value "any"
	QosPolicyAdaptiveBlockSizeAny string = "any"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// block_size
	// BlockSize
	// 4k
	// END DEBUGGING
	// QosPolicyAdaptiveBlockSizeNr4k captures enum value "4k"
	QosPolicyAdaptiveBlockSizeNr4k string = "4k"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// block_size
	// BlockSize
	// 8k
	// END DEBUGGING
	// QosPolicyAdaptiveBlockSizeNr8k captures enum value "8k"
	QosPolicyAdaptiveBlockSizeNr8k string = "8k"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// block_size
	// BlockSize
	// 16k
	// END DEBUGGING
	// QosPolicyAdaptiveBlockSizeNr16k captures enum value "16k"
	QosPolicyAdaptiveBlockSizeNr16k string = "16k"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// block_size
	// BlockSize
	// 32k
	// END DEBUGGING
	// QosPolicyAdaptiveBlockSizeNr32k captures enum value "32k"
	QosPolicyAdaptiveBlockSizeNr32k string = "32k"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// block_size
	// BlockSize
	// 64k
	// END DEBUGGING
	// QosPolicyAdaptiveBlockSizeNr64k captures enum value "64k"
	QosPolicyAdaptiveBlockSizeNr64k string = "64k"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// block_size
	// BlockSize
	// 128k
	// END DEBUGGING
	// QosPolicyAdaptiveBlockSizeNr128k captures enum value "128k"
	QosPolicyAdaptiveBlockSizeNr128k string = "128k"
)

// prop value enum
func (m *QosPolicyAdaptive) validateBlockSizeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, qosPolicyAdaptiveTypeBlockSizePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *QosPolicyAdaptive) validateBlockSize(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockSize) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockSizeEnum("adaptive"+"."+"block_size", "body", *m.BlockSize); err != nil {
		return err
	}

	return nil
}

var qosPolicyAdaptiveTypeExpectedIopsAllocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["used_space","allocated_space"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		qosPolicyAdaptiveTypeExpectedIopsAllocationPropEnum = append(qosPolicyAdaptiveTypeExpectedIopsAllocationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// expected_iops_allocation
	// ExpectedIopsAllocation
	// used_space
	// END DEBUGGING
	// QosPolicyAdaptiveExpectedIopsAllocationUsedSpace captures enum value "used_space"
	QosPolicyAdaptiveExpectedIopsAllocationUsedSpace string = "used_space"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// expected_iops_allocation
	// ExpectedIopsAllocation
	// allocated_space
	// END DEBUGGING
	// QosPolicyAdaptiveExpectedIopsAllocationAllocatedSpace captures enum value "allocated_space"
	QosPolicyAdaptiveExpectedIopsAllocationAllocatedSpace string = "allocated_space"
)

// prop value enum
func (m *QosPolicyAdaptive) validateExpectedIopsAllocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, qosPolicyAdaptiveTypeExpectedIopsAllocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *QosPolicyAdaptive) validateExpectedIopsAllocation(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpectedIopsAllocation) { // not required
		return nil
	}

	// value enum
	if err := m.validateExpectedIopsAllocationEnum("adaptive"+"."+"expected_iops_allocation", "body", *m.ExpectedIopsAllocation); err != nil {
		return err
	}

	return nil
}

var qosPolicyAdaptiveTypePeakIopsAllocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["used_space","allocated_space"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		qosPolicyAdaptiveTypePeakIopsAllocationPropEnum = append(qosPolicyAdaptiveTypePeakIopsAllocationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// peak_iops_allocation
	// PeakIopsAllocation
	// used_space
	// END DEBUGGING
	// QosPolicyAdaptivePeakIopsAllocationUsedSpace captures enum value "used_space"
	QosPolicyAdaptivePeakIopsAllocationUsedSpace string = "used_space"

	// BEGIN DEBUGGING
	// QosPolicyAdaptive
	// QosPolicyAdaptive
	// peak_iops_allocation
	// PeakIopsAllocation
	// allocated_space
	// END DEBUGGING
	// QosPolicyAdaptivePeakIopsAllocationAllocatedSpace captures enum value "allocated_space"
	QosPolicyAdaptivePeakIopsAllocationAllocatedSpace string = "allocated_space"
)

// prop value enum
func (m *QosPolicyAdaptive) validatePeakIopsAllocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, qosPolicyAdaptiveTypePeakIopsAllocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *QosPolicyAdaptive) validatePeakIopsAllocation(formats strfmt.Registry) error {
	if swag.IsZero(m.PeakIopsAllocation) { // not required
		return nil
	}

	// value enum
	if err := m.validatePeakIopsAllocationEnum("adaptive"+"."+"peak_iops_allocation", "body", *m.PeakIopsAllocation); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this qos policy adaptive based on context it is used
func (m *QosPolicyAdaptive) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicyAdaptive) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicyAdaptive) UnmarshalBinary(b []byte) error {
	var res QosPolicyAdaptive
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicyFixed QoS policy-groups define a fixed service level objective (SLO) for a storage object.
//
// swagger:model QosPolicyFixed
type QosPolicyFixed struct {

	// Specifies whether the capacities are shared across all objects that use this QoS policy-group. Default is false.
	CapacityShared *bool `json:"capacity_shared,omitempty"`

	// Maximum throughput defined by this policy.  It is specified in terms of IOPS. 0 means no maximum throughput is enforced.
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Maximum throughput defined by this policy.  It is specified in terms of Mbps. 0 means no maximum throughput is enforced.
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Minimum throughput defined by this policy.  It is specified in terms of IOPS. 0 means no minimum throughput is enforced. These floors are not guaranteed on non-AFF platforms or when FabricPool tiering policies are set.
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Minimum throughput defined by this policy.  It is specified in terms of Mbps. 0 means no minimum throughput is enforced.
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`
}

// Validate validates this qos policy fixed
func (m *QosPolicyFixed) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this qos policy fixed based on context it is used
func (m *QosPolicyFixed) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicyFixed) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicyFixed) UnmarshalBinary(b []byte) error {
	var res QosPolicyFixed
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicyLinks qos policy links
//
// swagger:model QosPolicyLinks
type QosPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this qos policy links
func (m *QosPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy links based on the context it is used
func (m *QosPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicyLinks) UnmarshalBinary(b []byte) error {
	var res QosPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicySvm qos policy svm
//
// swagger:model QosPolicySvm
type QosPolicySvm struct {

	// links
	Links *QosPolicySvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this qos policy svm
func (m *QosPolicySvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy svm based on the context it is used
func (m *QosPolicySvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicySvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicySvm) UnmarshalBinary(b []byte) error {
	var res QosPolicySvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicySvmLinks qos policy svm links
//
// swagger:model QosPolicySvmLinks
type QosPolicySvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this qos policy svm links
func (m *QosPolicySvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy svm links based on the context it is used
func (m *QosPolicySvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicySvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicySvmLinks) UnmarshalBinary(b []byte) error {
	var res QosPolicySvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// QosPolicy qos policy
//
// swagger:model qos_policy
type QosPolicy struct {

	// links
	Links *QosPolicyLinks `json:"_links,omitempty"`

	// adaptive
	Adaptive *QosPolicyAdaptive `json:"adaptive,omitempty"`

	// fixed
	Fixed *QosPolicyFixed `json:"fixed,omitempty"`

	// Name of the QoS policy.
	// Example: extreme
	Name string `json:"name,omitempty"`

	// Number of objects attached to this policy.
	// Read Only: true
	ObjectCount int64 `json:"object_count,omitempty"`

	// svm
	Svm *QosPolicySvm `json:"svm,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this qos policy
func (m *QosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdaptive(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFixed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) validateAdaptive(formats strfmt.Registry) error {
	if swag.IsZero(m.Adaptive) { // not required
		return nil
	}

	if m.Adaptive != nil {
		if err := m.Adaptive.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adaptive")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) validateFixed(formats strfmt.Registry) error {
	if swag.IsZero(m.Fixed) { // not required
		return nil
	}

	if m.Fixed != nil {
		if err := m.Fixed.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fixed")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy based on the context it is used
func (m *QosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdaptive(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFixed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjectCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateAdaptive(ctx context.Context, formats strfmt.Registry) error {

	if m.Adaptive != nil {
		if err := m.Adaptive.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adaptive")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateFixed(ctx context.Context, formats strfmt.Registry) error {

	if m.Fixed != nil {
		if err := m.Fixed.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fixed")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateObjectCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "object_count", "body", int64(m.ObjectCount)); err != nil {
		return err
	}

	return nil
}

func (m *QosPolicy) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *QosPolicy) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicy) UnmarshalBinary(b []byte) error {
	var res QosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicyAdaptive Adaptive QoS policy-groups define measurable service level objectives (SLOs) that adjust based on the storage object used space and the storage object allocated space.
//
// swagger:model QosPolicyAdaptive
type QosPolicyAdaptive struct {

	// Specifies the absolute minimum IOPS that is used as an override when the expected_iops is less than this value. These floors are not guaranteed on non-AFF platforms or when FabricPool tiering policies are set.
	AbsoluteMinIops int64 `json:"absolute_min_iops,omitempty"`

	// Expected IOPS. Specifies the minimum expected IOPS per TB allocated based on the storage object allocated size. These floors are not guaranteed on non-AFF platforms or when FabricPool tiering policies are set.
	ExpectedIops int64 `json:"expected_iops,omitempty"`

	// Peak IOPS. Specifies the maximum possible IOPS per TB allocated based on the storage object allocated size or the storage object used size.
	PeakIops int64 `json:"peak_iops,omitempty"`
}

// Validate validates this qos policy adaptive
func (m *QosPolicyAdaptive) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this qos policy adaptive based on context it is used
func (m *QosPolicyAdaptive) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicyAdaptive) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicyAdaptive) UnmarshalBinary(b []byte) error {
	var res QosPolicyAdaptive
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicyFixed QoS policy-groups define a fixed service level objective (SLO) for a storage object.
//
// swagger:model QosPolicyFixed
type QosPolicyFixed struct {

	// Specifies whether the capacities are shared across all objects that use this QoS policy-group. Default is false.
	CapacityShared *bool `json:"capacity_shared,omitempty"`

	// Maximum throughput defined by this policy.  It is specified in terms of IOPS. 0 means no maximum throughput is enforced.
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Maximum throughput defined by this policy.  It is specified in terms of Mbps. 0 means no maximum throughput is enforced.
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Minimum throughput defined by this policy.  It is specified in terms of IOPS. 0 means no minimum throughput is enforced. These floors are not guaranteed on non-AFF platforms or when FabricPool tiering policies are set.
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Minimum throughput defined by this policy.  It is specified in terms of Mbps. 0 means no minimum throughput is enforced.
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`
}

// Validate validates this qos policy fixed
func (m *QosPolicyFixed) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this qos policy fixed based on context it is used
func (m *QosPolicyFixed) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicyFixed) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicyFixed) UnmarshalBinary(b []byte) error {
	var res QosPolicyFixed
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicyLinks qos policy links
//
// swagger:model QosPolicyLinks
type QosPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this qos policy links
func (m *QosPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy links based on the context it is used
func (m *QosPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicyLinks) UnmarshalBinary(b []byte) error {
	var res QosPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicySvm qos policy svm
//
// swagger:model QosPolicySvm
type QosPolicySvm struct {

	// links
	Links *QosPolicySvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this qos policy svm
func (m *QosPolicySvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy svm based on the context it is used
func (m *QosPolicySvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicySvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicySvm) UnmarshalBinary(b []byte) error {
	var res QosPolicySvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// QosPolicySvmLinks qos policy svm links
//
// swagger:model QosPolicySvmLinks
type QosPolicySvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this qos policy svm links
func (m *QosPolicySvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this qos policy svm links based on the context it is used
func (m *QosPolicySvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QosPolicySvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QosPolicySvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QosPolicySvmLinks) UnmarshalBinary(b []byte) error {
	var res QosPolicySvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

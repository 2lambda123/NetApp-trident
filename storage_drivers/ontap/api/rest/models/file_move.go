// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// FileMove File move
//
// swagger:model file_move
type FileMove struct {

	// The maximum amount of time (in seconds) that the source can be quiesced before a destination file must be made available for read-write traffic.
	// Example: 10
	CutoverTime *int64 `json:"cutover_time,omitempty"`

	// A list of source files along with the destination file they are moved to. If the terminal path component of the destination is a directory, then the source file's basename is replicated in that directory.
	FilesToMove []*FileMoveFilesToMoveItems0 `json:"files_to_move,omitempty"`

	// The maximum amount of data (in bytes) that can be transferred per second in support of this operation.
	MaxThroughput int64 `json:"max_throughput,omitempty"`

	// The maximum amount of time (in seconds) that the source reference file can be quiesced before the corresponding destination file must be made available for read-write traffic.
	// Example: 10
	ReferenceCutoverTime *int64 `json:"reference_cutover_time,omitempty"`

	// reference file
	ReferenceFile *FileMoveReferenceFile `json:"reference_file,omitempty"`
}

// Validate validates this file move
func (m *FileMove) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFilesToMove(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferenceFile(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMove) validateFilesToMove(formats strfmt.Registry) error {
	if swag.IsZero(m.FilesToMove) { // not required
		return nil
	}

	for i := 0; i < len(m.FilesToMove); i++ {
		if swag.IsZero(m.FilesToMove[i]) { // not required
			continue
		}

		if m.FilesToMove[i] != nil {
			if err := m.FilesToMove[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files_to_move" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileMove) validateReferenceFile(formats strfmt.Registry) error {
	if swag.IsZero(m.ReferenceFile) { // not required
		return nil
	}

	if m.ReferenceFile != nil {
		if err := m.ReferenceFile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move based on the context it is used
func (m *FileMove) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFilesToMove(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReferenceFile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMove) contextValidateFilesToMove(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FilesToMove); i++ {

		if m.FilesToMove[i] != nil {
			if err := m.FilesToMove[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files_to_move" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileMove) contextValidateReferenceFile(ctx context.Context, formats strfmt.Registry) error {

	if m.ReferenceFile != nil {
		if err := m.ReferenceFile.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMove) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMove) UnmarshalBinary(b []byte) error {
	var res FileMove
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0 file move files to move items0
//
// swagger:model FileMoveFilesToMoveItems0
type FileMoveFilesToMoveItems0 struct {

	// destination
	Destination *FileMoveFilesToMoveItems0Destination `json:"destination,omitempty"`

	// source
	Source *FileMoveFilesToMoveItems0Source `json:"source,omitempty"`
}

// Validate validates this file move files to move items0
func (m *FileMoveFilesToMoveItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0) validateDestination(formats strfmt.Registry) error {
	if swag.IsZero(m.Destination) { // not required
		return nil
	}

	if m.Destination != nil {
		if err := m.Destination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

func (m *FileMoveFilesToMoveItems0) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 based on the context it is used
func (m *FileMoveFilesToMoveItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0) contextValidateDestination(ctx context.Context, formats strfmt.Registry) error {

	if m.Destination != nil {
		if err := m.Destination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

func (m *FileMoveFilesToMoveItems0) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0Destination file move files to move items0 destination
//
// swagger:model FileMoveFilesToMoveItems0Destination
type FileMoveFilesToMoveItems0Destination struct {

	// Path of the file or directory.
	Path string `json:"path,omitempty"`

	// svm
	Svm *FileMoveFilesToMoveItems0DestinationSvm `json:"svm,omitempty"`

	// volume
	Volume *FileMoveFilesToMoveItems0DestinationVolume `json:"volume,omitempty"`
}

// Validate validates this file move files to move items0 destination
func (m *FileMoveFilesToMoveItems0Destination) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0Destination) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

func (m *FileMoveFilesToMoveItems0Destination) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 destination based on the context it is used
func (m *FileMoveFilesToMoveItems0Destination) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0Destination) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

func (m *FileMoveFilesToMoveItems0Destination) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0Destination) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0Destination) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0Destination
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0DestinationSvm SVM, applies only to SVM-scoped objects.
//
// swagger:model FileMoveFilesToMoveItems0DestinationSvm
type FileMoveFilesToMoveItems0DestinationSvm struct {

	// links
	Links *FileMoveFilesToMoveItems0DestinationSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this file move files to move items0 destination svm
func (m *FileMoveFilesToMoveItems0DestinationSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 destination svm based on the context it is used
func (m *FileMoveFilesToMoveItems0DestinationSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationSvm) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0DestinationSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0DestinationSvmLinks file move files to move items0 destination svm links
//
// swagger:model FileMoveFilesToMoveItems0DestinationSvmLinks
type FileMoveFilesToMoveItems0DestinationSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file move files to move items0 destination svm links
func (m *FileMoveFilesToMoveItems0DestinationSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 destination svm links based on the context it is used
func (m *FileMoveFilesToMoveItems0DestinationSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationSvmLinks) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0DestinationSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0DestinationVolume file move files to move items0 destination volume
//
// swagger:model FileMoveFilesToMoveItems0DestinationVolume
type FileMoveFilesToMoveItems0DestinationVolume struct {

	// links
	Links *FileMoveFilesToMoveItems0DestinationVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this file move files to move items0 destination volume
func (m *FileMoveFilesToMoveItems0DestinationVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 destination volume based on the context it is used
func (m *FileMoveFilesToMoveItems0DestinationVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationVolume) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0DestinationVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0DestinationVolumeLinks file move files to move items0 destination volume links
//
// swagger:model FileMoveFilesToMoveItems0DestinationVolumeLinks
type FileMoveFilesToMoveItems0DestinationVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file move files to move items0 destination volume links
func (m *FileMoveFilesToMoveItems0DestinationVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 destination volume links based on the context it is used
func (m *FileMoveFilesToMoveItems0DestinationVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0DestinationVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0DestinationVolumeLinks) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0DestinationVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0Source file move files to move items0 source
//
// swagger:model FileMoveFilesToMoveItems0Source
type FileMoveFilesToMoveItems0Source struct {

	// Path of the file or directory.
	Path string `json:"path,omitempty"`

	// svm
	Svm *FileMoveFilesToMoveItems0SourceSvm `json:"svm,omitempty"`

	// volume
	Volume *FileMoveFilesToMoveItems0SourceVolume `json:"volume,omitempty"`
}

// Validate validates this file move files to move items0 source
func (m *FileMoveFilesToMoveItems0Source) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0Source) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

func (m *FileMoveFilesToMoveItems0Source) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 source based on the context it is used
func (m *FileMoveFilesToMoveItems0Source) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0Source) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "svm")
			}
			return err
		}
	}

	return nil
}

func (m *FileMoveFilesToMoveItems0Source) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0Source) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0Source) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0Source
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0SourceSvm SVM, applies only to SVM-scoped objects.
//
// swagger:model FileMoveFilesToMoveItems0SourceSvm
type FileMoveFilesToMoveItems0SourceSvm struct {

	// links
	Links *FileMoveFilesToMoveItems0SourceSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this file move files to move items0 source svm
func (m *FileMoveFilesToMoveItems0SourceSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 source svm based on the context it is used
func (m *FileMoveFilesToMoveItems0SourceSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceSvm) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0SourceSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0SourceSvmLinks file move files to move items0 source svm links
//
// swagger:model FileMoveFilesToMoveItems0SourceSvmLinks
type FileMoveFilesToMoveItems0SourceSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file move files to move items0 source svm links
func (m *FileMoveFilesToMoveItems0SourceSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 source svm links based on the context it is used
func (m *FileMoveFilesToMoveItems0SourceSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceSvmLinks) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0SourceSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0SourceVolume file move files to move items0 source volume
//
// swagger:model FileMoveFilesToMoveItems0SourceVolume
type FileMoveFilesToMoveItems0SourceVolume struct {

	// links
	Links *FileMoveFilesToMoveItems0SourceVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this file move files to move items0 source volume
func (m *FileMoveFilesToMoveItems0SourceVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 source volume based on the context it is used
func (m *FileMoveFilesToMoveItems0SourceVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceVolume) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0SourceVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveFilesToMoveItems0SourceVolumeLinks file move files to move items0 source volume links
//
// swagger:model FileMoveFilesToMoveItems0SourceVolumeLinks
type FileMoveFilesToMoveItems0SourceVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file move files to move items0 source volume links
func (m *FileMoveFilesToMoveItems0SourceVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move files to move items0 source volume links based on the context it is used
func (m *FileMoveFilesToMoveItems0SourceVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveFilesToMoveItems0SourceVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveFilesToMoveItems0SourceVolumeLinks) UnmarshalBinary(b []byte) error {
	var res FileMoveFilesToMoveItems0SourceVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveReferenceFile file move reference file
//
// swagger:model FileMoveReferenceFile
type FileMoveReferenceFile struct {

	// The source reference file. If a reference file is specified, data for other files being moved will be transferred as a difference from the reference file. This can save bandwidth and destination storage if the specified source files share blocks. If provided, this input must match one of the source file paths. This input need not be provided if only one source file is specified.
	Path string `json:"path,omitempty"`

	// volume
	Volume *FileMoveReferenceFileVolume `json:"volume,omitempty"`
}

// Validate validates this file move reference file
func (m *FileMoveReferenceFile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveReferenceFile) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move reference file based on the context it is used
func (m *FileMoveReferenceFile) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveReferenceFile) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveReferenceFile) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveReferenceFile) UnmarshalBinary(b []byte) error {
	var res FileMoveReferenceFile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveReferenceFileVolume file move reference file volume
//
// swagger:model FileMoveReferenceFileVolume
type FileMoveReferenceFileVolume struct {

	// links
	Links *FileMoveReferenceFileVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this file move reference file volume
func (m *FileMoveReferenceFileVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveReferenceFileVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move reference file volume based on the context it is used
func (m *FileMoveReferenceFileVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveReferenceFileVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveReferenceFileVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveReferenceFileVolume) UnmarshalBinary(b []byte) error {
	var res FileMoveReferenceFileVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FileMoveReferenceFileVolumeLinks file move reference file volume links
//
// swagger:model FileMoveReferenceFileVolumeLinks
type FileMoveReferenceFileVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this file move reference file volume links
func (m *FileMoveReferenceFileVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveReferenceFileVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file move reference file volume links based on the context it is used
func (m *FileMoveReferenceFileVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileMoveReferenceFileVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_file" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileMoveReferenceFileVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileMoveReferenceFileVolumeLinks) UnmarshalBinary(b []byte) error {
	var res FileMoveReferenceFileVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

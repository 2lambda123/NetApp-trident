// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Volume volume
//
// swagger:model volume
type Volume struct {

	// links
	Links *VolumeLinks `json:"_links,omitempty"`

	// Indicates whether or not access time updates are enabled on the volume.
	AccessTimeEnabled bool `json:"access_time_enabled,omitempty"`

	// activity tracking
	ActivityTracking *VolumeActivityTracking `json:"activity_tracking,omitempty"`

	// Aggregate hosting the volume. Required on POST.
	Aggregates []*VolumeAggregatesItems0 `json:"aggregates,omitempty"`

	// analytics
	Analytics *VolumeAnalytics `json:"analytics,omitempty"`

	// anti ransomware
	AntiRansomware *VolumeAntiRansomwareType `json:"anti_ransomware,omitempty"`

	// The Anti-ransomware state of the volume. If no "anti_ransomware_state" property is specified, the volume inherits the value from its parent SVM's "anti_ransomware_default_volume_state" property. If this value is "disabled", Anti-ransomware is disabled on the volume. If this value is "enabled", Anti-ransomware is enabled on the volume and alerts are raised if any suspect is detected for those volumes. If this value is "dry_run", Anti-ransomware is enabled in the dry-run or learning mode on the volume. The "dry_run" state is same as the "enabled" state except that the analytics data is used here for learning. No alerts are raised for any detections or violations. If this value is "paused", Anti-ransomware is paused on the volume. Additionally, three more states are available, which are only valid for GET. If this value is "disable_in_progress", Anti-ransomware monitoring is being disabled and a cleanup operation is in effect. If this value is "enable_paused", Anti-ransomware is paused on the volume from its earlier enabled state. If this value is "dry_run_paused", Anti-ransomware monitoring is paused on the volume from its earlier dry_run state. For POST, the valid Anti-ransomware states are only "disabled", "enabled" and "dry_run", whereas for PATCH, "paused" is also valid along with the three valid states for POST.
	// Enum: [disabled enabled dry_run paused disable_in_progress enable_paused dry_run_paused]
	AntiRansomwareState string `json:"anti_ransomware_state,omitempty"`

	// application
	Application *VolumeApplication `json:"application,omitempty"`

	// autosize
	Autosize *VolumeAutosize `json:"autosize,omitempty"`

	// clone
	Clone *VolumeClone `json:"clone,omitempty"`

	// This parameter specifies the cloud retrieval policy for the volume. This policy determines which tiered out blocks to retrieve from the capacity tier to the performance tier. The available cloud retrieval policies are
	// "default" policy retrieves tiered data based on the underlying tiering policy. If the tiering policy is 'auto', tiered data is retrieved only for random client driven data reads. If the tiering policy is 'none' or 'snapshot_only', tiered data is retrieved for random and sequential client driven data reads. If the tiering policy is 'all', tiered data is not retrieved.
	// "on_read" policy retrieves tiered data for all client driven data reads.
	// "never" policy never retrieves tiered data.
	// "promote" policy retrieves all eligible tiered data automatically during the next scheduled scan. It is only supported when the tiering policy is 'none' or 'snapshot_only'. If the tiering policy is 'snapshot_only', the only data brought back is the data in the AFS. Data that is only in a snapshot copy stays in the cloud and if tiering policy is 'none' then all data is retrieved.
	//
	// Enum: [default on_read never promote]
	CloudRetrievalPolicy string `json:"cloud_retrieval_policy,omitempty"`

	// A comment for the volume. Valid in POST or PATCH.
	// Max Length: 1023
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// consistency group
	ConsistencyGroup *VolumeConsistencyGroup `json:"consistency_group,omitempty"`

	// constituents
	Constituents []*VolumeConstituentsItems0 `json:"constituents,omitempty"`

	// Specifies the number of times to iterate over the aggregates listed with the "aggregates.name" or "aggregates.uuid" when creating or expanding a FlexGroup volume. If a volume is being created on a single aggregate, the system creates a flexible volume if the "constituents_per_aggregate" field is not specified, or a FlexGroup volume if it is specified. If a volume is being created on multiple aggregates, the system always creates a FlexGroup volume. The root constituent of a FlexGroup volume is always placed on the first aggregate in the list.
	// Maximum: 1000
	// Minimum: 1
	ConstituentsPerAggregate int64 `json:"constituents_per_aggregate,omitempty"`

	// Specifies whether directory Unicode format conversion is enabled when directories are accessed by NFS clients.
	ConvertUnicode bool `json:"convert_unicode,omitempty"`

	// Creation time of the volume. This field is generated when the volume is created.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"create_time,omitempty"`

	// efficiency
	Efficiency *VolumeEfficiencyType `json:"efficiency,omitempty"`

	// encryption
	Encryption *VolumeEncryption `json:"encryption,omitempty"`

	// error state
	ErrorState *VolumeErrorState `json:"error_state,omitempty"`

	// files
	Files *VolumeFiles `json:"files,omitempty"`

	// flash pool
	FlashPool *VolumeFlashPool `json:"flash_pool,omitempty"`

	// FlexCache endpoint type. <br>none &dash; The volume is neither a FlexCache nor origin of any FlexCache. <br>cache &dash; The volume is a FlexCache volume. <br>origin &dash; The volume is origin of a FlexCache volume.
	// Read Only: true
	// Enum: [none cache origin]
	FlexcacheEndpointType string `json:"flexcache_endpoint_type,omitempty"`

	// flexgroup
	Flexgroup *VolumeFlexgroup `json:"flexgroup,omitempty"`

	// guarantee
	Guarantee *VolumeGuarantee `json:"guarantee,omitempty"`

	// Specifies whether the volume is provisioned for an object store server.
	// Read Only: true
	IsObjectStore *bool `json:"is_object_store,omitempty"`

	// Specifies whether the volume is a root volume of the SVM it belongs to.
	// Read Only: true
	IsSvmRoot *bool `json:"is_svm_root,omitempty"`

	// Language encoding setting for volume. If no language is specified, the volume inherits its SVM language encoding setting.
	// Enum: [ar ar.utf_8 c c.utf_8 cs cs.utf_8 da da.utf_8 de de.utf_8 en en.utf_8 en_us en_us.utf_8 es es.utf_8 fi fi.utf_8 fr fr.utf_8 he he.utf_8 hr hr.utf_8 hu hu.utf_8 it it.utf_8 ja ja.utf_8 ja_jp.932 ja_jp.932.utf_8 ja_jp.pck ja_jp.pck.utf_8 ja_jp.pck_v2 ja_jp.pck_v2.utf_8 ja_v1 ja_v1.utf_8 ko ko.utf_8 nl nl.utf_8 no no.utf_8 pl pl.utf_8 pt pt.utf_8 ro ro.utf_8 ru ru.utf_8 sk sk.utf_8 sl sl.utf_8 sv sv.utf_8 tr tr.utf_8 utf8mb4 zh zh.gbk zh.gbk.utf_8 zh.utf_8 zh_tw zh_tw.big5 zh_tw.big5.utf_8 zh_tw.utf_8]
	Language string `json:"language,omitempty"`

	// Maximum directory size. This value sets maximum size, in bytes, to which a directory can grow. The default maximum directory size for FlexVol volumes is model-dependent, and optimized for the size of system memory. Before increasing the maximum directory size, involve technical support.
	MaxDirSize int64 `json:"max_dir_size,omitempty"`

	// metric
	Metric *VolumeMetric `json:"metric,omitempty"`

	// movement
	Movement *VolumeMovement `json:"movement,omitempty"`

	// Volume name. The name of volume must start with an alphabetic character (a to z or A to Z) or an underscore (_). The name must be 197 or fewer characters in length for FlexGroups, and 203 or fewer characters in length for all other types of volumes. Volume names must be unique within an SVM. Required on POST.
	// Example: vol_cs_dept
	// Max Length: 203
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// nas
	Nas *VolumeNas `json:"nas,omitempty"`

	// qos
	Qos *VolumeQos `json:"qos,omitempty"`

	// Specifies whether the volume is queued for encryption.
	QueueForEncryption bool `json:"queue_for_encryption,omitempty"`

	// quota
	Quota *VolumeQuota `json:"quota,omitempty"`

	// Naming Scheme for automatic Snapshot copies:
	// * create_time - Automatic Snapshot copies are saved as per the start of their current date and time.
	// * ordinal - Latest automatic snapshot copy is saved as <scheduled_frequency>.0 and subsequent copies will follow the create_time naming convention.
	//
	// Enum: [create_time ordinal]
	ScheduledSnapshotNamingScheme *string `json:"scheduled_snapshot_naming_scheme,omitempty"`

	// Physical size of the volume, in bytes. The minimum size for a FlexVol volume is 20MB and the minimum size for a FlexGroup volume is 200MB per constituent. The recommended size for a FlexGroup volume is a minimum of 100GB per constituent. For all volumes, the default size is equal to the minimum size.
	Size int64 `json:"size,omitempty"`

	// snaplock
	Snaplock *VolumeSnaplock `json:"snaplock,omitempty"`

	// snapmirror
	Snapmirror *VolumeSnapmirror `json:"snapmirror,omitempty"`

	// Number of Snapshot copies in the volume.
	// Read Only: true
	// Maximum: 1023
	// Minimum: 0
	SnapshotCount int64 `json:"snapshot_count,omitempty"`

	// snapshot policy
	SnapshotPolicy *VolumeSnapshotPolicy `json:"snapshot_policy,omitempty"`

	// space
	Space *VolumeSpace `json:"space,omitempty"`

	// Volume state. Client access is supported only when volume is online and junctioned. Taking volume to offline or restricted state removes its junction path and blocks client access. When volume is in restricted state some operations like parity reconstruction and iron on commit are allowed. The 'mixed' state applies to FlexGroup volumes only and cannot be specified as a target state. An 'error' state implies that the volume is not in a state to serve data.
	// Enum: [error mixed offline online restricted]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *VolumeStatistics `json:"statistics,omitempty"`

	// Describes the current status of a volume.
	// Read Only: true
	Status []string `json:"status,omitempty"`

	// The style of the volume. If "style" is not specified, the volume type is determined based on the specified aggregates. Specifying a single aggregate, without "constituents_per_aggregate", creates a flexible volume. Specifying multiple aggregates, or a single aggregate with "constituents_per_aggregate", creates a FlexGroup. Specifying a volume "style" creates a volume of that type. For example, if the style is "flexvol" you must specify a single aggregate. If the style is "flexgroup", the system either uses the specified aggregates or automatically provisions aggregates if there are no specified aggregates. The style "flexgroup_constiutent" is not supported when creating a volume.<br>flexvol &dash; flexible volumes and FlexClone volumes<br>flexgroup &dash; FlexGroup volumes<br>flexgroup_constituent &dash; FlexGroup constituents.
	// Enum: [flexvol flexgroup flexgroup_constituent]
	Style string `json:"style,omitempty"`

	// svm
	Svm *VolumeSvm `json:"svm,omitempty"`

	// tiering
	Tiering *VolumeTiering `json:"tiering,omitempty"`

	// Type of the volume.<br>rw &dash; read-write volume.<br>dp &dash; data-protection volume.<br>ls &dash; load-sharing `dp` volume. Valid in GET.
	// Enum: [rw dp ls]
	Type *string `json:"type,omitempty"`

	// Specifies whether mirrored aggregates are selected when provisioning a FlexGroup without specifying "aggregates.name" or "aggregates.uuid". Only mirrored aggregates are used if this parameter is set to 'true' and only unmirrored aggregates are used if this parameter is set to 'false'. Aggregate level mirroring for a FlexGroup can be changed by moving all of the constituents to the required aggregates. The default value is 'true' for a MetroCluster configuration and is 'false' for a non-MetroCluster configuration.
	UseMirroredAggregates bool `json:"use_mirrored_aggregates,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume
func (m *Volume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActivityTracking(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAnalytics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAntiRansomware(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAntiRansomwareState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApplication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutosize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudRetrievalPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsistencyGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConstituents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConstituentsPerAggregate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEfficiency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlashPool(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexcacheEndpointType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexgroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGuarantee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMovement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScheduledSnapshotNamingScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnaplock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapmirror(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStyle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTiering(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Volume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateActivityTracking(formats strfmt.Registry) error {
	if swag.IsZero(m.ActivityTracking) { // not required
		return nil
	}

	if m.ActivityTracking != nil {
		if err := m.ActivityTracking.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activity_tracking")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregates) { // not required
		return nil
	}

	for i := 0; i < len(m.Aggregates); i++ {
		if swag.IsZero(m.Aggregates[i]) { // not required
			continue
		}

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Volume) validateAnalytics(formats strfmt.Registry) error {
	if swag.IsZero(m.Analytics) { // not required
		return nil
	}

	if m.Analytics != nil {
		if err := m.Analytics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("analytics")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateAntiRansomware(formats strfmt.Registry) error {
	if swag.IsZero(m.AntiRansomware) { // not required
		return nil
	}

	if m.AntiRansomware != nil {
		if err := m.AntiRansomware.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("anti_ransomware")
			}
			return err
		}
	}

	return nil
}

var volumeTypeAntiRansomwareStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["disabled","enabled","dry_run","paused","disable_in_progress","enable_paused","dry_run_paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeAntiRansomwareStatePropEnum = append(volumeTypeAntiRansomwareStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// anti_ransomware_state
	// AntiRansomwareState
	// disabled
	// END DEBUGGING
	// VolumeAntiRansomwareStateDisabled captures enum value "disabled"
	VolumeAntiRansomwareStateDisabled string = "disabled"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// anti_ransomware_state
	// AntiRansomwareState
	// enabled
	// END DEBUGGING
	// VolumeAntiRansomwareStateEnabled captures enum value "enabled"
	VolumeAntiRansomwareStateEnabled string = "enabled"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// anti_ransomware_state
	// AntiRansomwareState
	// dry_run
	// END DEBUGGING
	// VolumeAntiRansomwareStateDryRun captures enum value "dry_run"
	VolumeAntiRansomwareStateDryRun string = "dry_run"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// anti_ransomware_state
	// AntiRansomwareState
	// paused
	// END DEBUGGING
	// VolumeAntiRansomwareStatePaused captures enum value "paused"
	VolumeAntiRansomwareStatePaused string = "paused"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// anti_ransomware_state
	// AntiRansomwareState
	// disable_in_progress
	// END DEBUGGING
	// VolumeAntiRansomwareStateDisableInProgress captures enum value "disable_in_progress"
	VolumeAntiRansomwareStateDisableInProgress string = "disable_in_progress"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// anti_ransomware_state
	// AntiRansomwareState
	// enable_paused
	// END DEBUGGING
	// VolumeAntiRansomwareStateEnablePaused captures enum value "enable_paused"
	VolumeAntiRansomwareStateEnablePaused string = "enable_paused"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// anti_ransomware_state
	// AntiRansomwareState
	// dry_run_paused
	// END DEBUGGING
	// VolumeAntiRansomwareStateDryRunPaused captures enum value "dry_run_paused"
	VolumeAntiRansomwareStateDryRunPaused string = "dry_run_paused"
)

// prop value enum
func (m *Volume) validateAntiRansomwareStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeAntiRansomwareStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateAntiRansomwareState(formats strfmt.Registry) error {
	if swag.IsZero(m.AntiRansomwareState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAntiRansomwareStateEnum("anti_ransomware_state", "body", m.AntiRansomwareState); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateApplication(formats strfmt.Registry) error {
	if swag.IsZero(m.Application) { // not required
		return nil
	}

	if m.Application != nil {
		if err := m.Application.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateAutosize(formats strfmt.Registry) error {
	if swag.IsZero(m.Autosize) { // not required
		return nil
	}

	if m.Autosize != nil {
		if err := m.Autosize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autosize")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateClone(formats strfmt.Registry) error {
	if swag.IsZero(m.Clone) { // not required
		return nil
	}

	if m.Clone != nil {
		if err := m.Clone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

var volumeTypeCloudRetrievalPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","on_read","never","promote"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeCloudRetrievalPolicyPropEnum = append(volumeTypeCloudRetrievalPolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// cloud_retrieval_policy
	// CloudRetrievalPolicy
	// default
	// END DEBUGGING
	// VolumeCloudRetrievalPolicyDefault captures enum value "default"
	VolumeCloudRetrievalPolicyDefault string = "default"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// cloud_retrieval_policy
	// CloudRetrievalPolicy
	// on_read
	// END DEBUGGING
	// VolumeCloudRetrievalPolicyOnRead captures enum value "on_read"
	VolumeCloudRetrievalPolicyOnRead string = "on_read"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// cloud_retrieval_policy
	// CloudRetrievalPolicy
	// never
	// END DEBUGGING
	// VolumeCloudRetrievalPolicyNever captures enum value "never"
	VolumeCloudRetrievalPolicyNever string = "never"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// cloud_retrieval_policy
	// CloudRetrievalPolicy
	// promote
	// END DEBUGGING
	// VolumeCloudRetrievalPolicyPromote captures enum value "promote"
	VolumeCloudRetrievalPolicyPromote string = "promote"
)

// prop value enum
func (m *Volume) validateCloudRetrievalPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeCloudRetrievalPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateCloudRetrievalPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudRetrievalPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateCloudRetrievalPolicyEnum("cloud_retrieval_policy", "body", m.CloudRetrievalPolicy); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 1023); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateConsistencyGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ConsistencyGroup) { // not required
		return nil
	}

	if m.ConsistencyGroup != nil {
		if err := m.ConsistencyGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateConstituents(formats strfmt.Registry) error {
	if swag.IsZero(m.Constituents) { // not required
		return nil
	}

	for i := 0; i < len(m.Constituents); i++ {
		if swag.IsZero(m.Constituents[i]) { // not required
			continue
		}

		if m.Constituents[i] != nil {
			if err := m.Constituents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("constituents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Volume) validateConstituentsPerAggregate(formats strfmt.Registry) error {
	if swag.IsZero(m.ConstituentsPerAggregate) { // not required
		return nil
	}

	if err := validate.MinimumInt("constituents_per_aggregate", "body", m.ConstituentsPerAggregate, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("constituents_per_aggregate", "body", m.ConstituentsPerAggregate, 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateCreateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("create_time", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateEfficiency(formats strfmt.Registry) error {
	if swag.IsZero(m.Efficiency) { // not required
		return nil
	}

	if m.Efficiency != nil {
		if err := m.Efficiency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("efficiency")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.Encryption) { // not required
		return nil
	}

	if m.Encryption != nil {
		if err := m.Encryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateErrorState(formats strfmt.Registry) error {
	if swag.IsZero(m.ErrorState) { // not required
		return nil
	}

	if m.ErrorState != nil {
		if err := m.ErrorState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error_state")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.Files) { // not required
		return nil
	}

	if m.Files != nil {
		if err := m.Files.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("files")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateFlashPool(formats strfmt.Registry) error {
	if swag.IsZero(m.FlashPool) { // not required
		return nil
	}

	if m.FlashPool != nil {
		if err := m.FlashPool.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flash_pool")
			}
			return err
		}
	}

	return nil
}

var volumeTypeFlexcacheEndpointTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","cache","origin"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeFlexcacheEndpointTypePropEnum = append(volumeTypeFlexcacheEndpointTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// flexcache_endpoint_type
	// FlexcacheEndpointType
	// none
	// END DEBUGGING
	// VolumeFlexcacheEndpointTypeNone captures enum value "none"
	VolumeFlexcacheEndpointTypeNone string = "none"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// flexcache_endpoint_type
	// FlexcacheEndpointType
	// cache
	// END DEBUGGING
	// VolumeFlexcacheEndpointTypeCache captures enum value "cache"
	VolumeFlexcacheEndpointTypeCache string = "cache"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// flexcache_endpoint_type
	// FlexcacheEndpointType
	// origin
	// END DEBUGGING
	// VolumeFlexcacheEndpointTypeOrigin captures enum value "origin"
	VolumeFlexcacheEndpointTypeOrigin string = "origin"
)

// prop value enum
func (m *Volume) validateFlexcacheEndpointTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeFlexcacheEndpointTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateFlexcacheEndpointType(formats strfmt.Registry) error {
	if swag.IsZero(m.FlexcacheEndpointType) { // not required
		return nil
	}

	// value enum
	if err := m.validateFlexcacheEndpointTypeEnum("flexcache_endpoint_type", "body", m.FlexcacheEndpointType); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateFlexgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Flexgroup) { // not required
		return nil
	}

	if m.Flexgroup != nil {
		if err := m.Flexgroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexgroup")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateGuarantee(formats strfmt.Registry) error {
	if swag.IsZero(m.Guarantee) { // not required
		return nil
	}

	if m.Guarantee != nil {
		if err := m.Guarantee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("guarantee")
			}
			return err
		}
	}

	return nil
}

var volumeTypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","ar.utf_8","c","c.utf_8","cs","cs.utf_8","da","da.utf_8","de","de.utf_8","en","en.utf_8","en_us","en_us.utf_8","es","es.utf_8","fi","fi.utf_8","fr","fr.utf_8","he","he.utf_8","hr","hr.utf_8","hu","hu.utf_8","it","it.utf_8","ja","ja.utf_8","ja_jp.932","ja_jp.932.utf_8","ja_jp.pck","ja_jp.pck.utf_8","ja_jp.pck_v2","ja_jp.pck_v2.utf_8","ja_v1","ja_v1.utf_8","ko","ko.utf_8","nl","nl.utf_8","no","no.utf_8","pl","pl.utf_8","pt","pt.utf_8","ro","ro.utf_8","ru","ru.utf_8","sk","sk.utf_8","sl","sl.utf_8","sv","sv.utf_8","tr","tr.utf_8","utf8mb4","zh","zh.gbk","zh.gbk.utf_8","zh.utf_8","zh_tw","zh_tw.big5","zh_tw.big5.utf_8","zh_tw.utf_8"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeLanguagePropEnum = append(volumeTypeLanguagePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ar
	// END DEBUGGING
	// VolumeLanguageAr captures enum value "ar"
	VolumeLanguageAr string = "ar"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ar.utf_8
	// END DEBUGGING
	// VolumeLanguageArDotUTF8 captures enum value "ar.utf_8"
	VolumeLanguageArDotUTF8 string = "ar.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// c
	// END DEBUGGING
	// VolumeLanguageC captures enum value "c"
	VolumeLanguageC string = "c"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// c.utf_8
	// END DEBUGGING
	// VolumeLanguageCDotUTF8 captures enum value "c.utf_8"
	VolumeLanguageCDotUTF8 string = "c.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// cs
	// END DEBUGGING
	// VolumeLanguageCs captures enum value "cs"
	VolumeLanguageCs string = "cs"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// cs.utf_8
	// END DEBUGGING
	// VolumeLanguageCsDotUTF8 captures enum value "cs.utf_8"
	VolumeLanguageCsDotUTF8 string = "cs.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// da
	// END DEBUGGING
	// VolumeLanguageDa captures enum value "da"
	VolumeLanguageDa string = "da"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// da.utf_8
	// END DEBUGGING
	// VolumeLanguageDaDotUTF8 captures enum value "da.utf_8"
	VolumeLanguageDaDotUTF8 string = "da.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// de
	// END DEBUGGING
	// VolumeLanguageDe captures enum value "de"
	VolumeLanguageDe string = "de"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// de.utf_8
	// END DEBUGGING
	// VolumeLanguageDeDotUTF8 captures enum value "de.utf_8"
	VolumeLanguageDeDotUTF8 string = "de.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// en
	// END DEBUGGING
	// VolumeLanguageEn captures enum value "en"
	VolumeLanguageEn string = "en"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// en.utf_8
	// END DEBUGGING
	// VolumeLanguageEnDotUTF8 captures enum value "en.utf_8"
	VolumeLanguageEnDotUTF8 string = "en.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// en_us
	// END DEBUGGING
	// VolumeLanguageEnUs captures enum value "en_us"
	VolumeLanguageEnUs string = "en_us"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// en_us.utf_8
	// END DEBUGGING
	// VolumeLanguageEnUsDotUTF8 captures enum value "en_us.utf_8"
	VolumeLanguageEnUsDotUTF8 string = "en_us.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// es
	// END DEBUGGING
	// VolumeLanguageEs captures enum value "es"
	VolumeLanguageEs string = "es"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// es.utf_8
	// END DEBUGGING
	// VolumeLanguageEsDotUTF8 captures enum value "es.utf_8"
	VolumeLanguageEsDotUTF8 string = "es.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// fi
	// END DEBUGGING
	// VolumeLanguageFi captures enum value "fi"
	VolumeLanguageFi string = "fi"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// fi.utf_8
	// END DEBUGGING
	// VolumeLanguageFiDotUTF8 captures enum value "fi.utf_8"
	VolumeLanguageFiDotUTF8 string = "fi.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// fr
	// END DEBUGGING
	// VolumeLanguageFr captures enum value "fr"
	VolumeLanguageFr string = "fr"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// fr.utf_8
	// END DEBUGGING
	// VolumeLanguageFrDotUTF8 captures enum value "fr.utf_8"
	VolumeLanguageFrDotUTF8 string = "fr.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// he
	// END DEBUGGING
	// VolumeLanguageHe captures enum value "he"
	VolumeLanguageHe string = "he"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// he.utf_8
	// END DEBUGGING
	// VolumeLanguageHeDotUTF8 captures enum value "he.utf_8"
	VolumeLanguageHeDotUTF8 string = "he.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// hr
	// END DEBUGGING
	// VolumeLanguageHr captures enum value "hr"
	VolumeLanguageHr string = "hr"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// hr.utf_8
	// END DEBUGGING
	// VolumeLanguageHrDotUTF8 captures enum value "hr.utf_8"
	VolumeLanguageHrDotUTF8 string = "hr.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// hu
	// END DEBUGGING
	// VolumeLanguageHu captures enum value "hu"
	VolumeLanguageHu string = "hu"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// hu.utf_8
	// END DEBUGGING
	// VolumeLanguageHuDotUTF8 captures enum value "hu.utf_8"
	VolumeLanguageHuDotUTF8 string = "hu.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// it
	// END DEBUGGING
	// VolumeLanguageIt captures enum value "it"
	VolumeLanguageIt string = "it"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// it.utf_8
	// END DEBUGGING
	// VolumeLanguageItDotUTF8 captures enum value "it.utf_8"
	VolumeLanguageItDotUTF8 string = "it.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja
	// END DEBUGGING
	// VolumeLanguageJa captures enum value "ja"
	VolumeLanguageJa string = "ja"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja.utf_8
	// END DEBUGGING
	// VolumeLanguageJaDotUTF8 captures enum value "ja.utf_8"
	VolumeLanguageJaDotUTF8 string = "ja.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_jp.932
	// END DEBUGGING
	// VolumeLanguageJaJpDot932 captures enum value "ja_jp.932"
	VolumeLanguageJaJpDot932 string = "ja_jp.932"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_jp.932.utf_8
	// END DEBUGGING
	// VolumeLanguageJaJpDot932DotUTF8 captures enum value "ja_jp.932.utf_8"
	VolumeLanguageJaJpDot932DotUTF8 string = "ja_jp.932.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_jp.pck
	// END DEBUGGING
	// VolumeLanguageJaJpDotPck captures enum value "ja_jp.pck"
	VolumeLanguageJaJpDotPck string = "ja_jp.pck"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_jp.pck.utf_8
	// END DEBUGGING
	// VolumeLanguageJaJpDotPckDotUTF8 captures enum value "ja_jp.pck.utf_8"
	VolumeLanguageJaJpDotPckDotUTF8 string = "ja_jp.pck.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_jp.pck_v2
	// END DEBUGGING
	// VolumeLanguageJaJpDotPckV2 captures enum value "ja_jp.pck_v2"
	VolumeLanguageJaJpDotPckV2 string = "ja_jp.pck_v2"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_jp.pck_v2.utf_8
	// END DEBUGGING
	// VolumeLanguageJaJpDotPckV2DotUTF8 captures enum value "ja_jp.pck_v2.utf_8"
	VolumeLanguageJaJpDotPckV2DotUTF8 string = "ja_jp.pck_v2.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_v1
	// END DEBUGGING
	// VolumeLanguageJaV1 captures enum value "ja_v1"
	VolumeLanguageJaV1 string = "ja_v1"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ja_v1.utf_8
	// END DEBUGGING
	// VolumeLanguageJaV1DotUTF8 captures enum value "ja_v1.utf_8"
	VolumeLanguageJaV1DotUTF8 string = "ja_v1.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ko
	// END DEBUGGING
	// VolumeLanguageKo captures enum value "ko"
	VolumeLanguageKo string = "ko"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ko.utf_8
	// END DEBUGGING
	// VolumeLanguageKoDotUTF8 captures enum value "ko.utf_8"
	VolumeLanguageKoDotUTF8 string = "ko.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// nl
	// END DEBUGGING
	// VolumeLanguageNl captures enum value "nl"
	VolumeLanguageNl string = "nl"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// nl.utf_8
	// END DEBUGGING
	// VolumeLanguageNlDotUTF8 captures enum value "nl.utf_8"
	VolumeLanguageNlDotUTF8 string = "nl.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// no
	// END DEBUGGING
	// VolumeLanguageNo captures enum value "no"
	VolumeLanguageNo string = "no"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// no.utf_8
	// END DEBUGGING
	// VolumeLanguageNoDotUTF8 captures enum value "no.utf_8"
	VolumeLanguageNoDotUTF8 string = "no.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// pl
	// END DEBUGGING
	// VolumeLanguagePl captures enum value "pl"
	VolumeLanguagePl string = "pl"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// pl.utf_8
	// END DEBUGGING
	// VolumeLanguagePlDotUTF8 captures enum value "pl.utf_8"
	VolumeLanguagePlDotUTF8 string = "pl.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// pt
	// END DEBUGGING
	// VolumeLanguagePt captures enum value "pt"
	VolumeLanguagePt string = "pt"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// pt.utf_8
	// END DEBUGGING
	// VolumeLanguagePtDotUTF8 captures enum value "pt.utf_8"
	VolumeLanguagePtDotUTF8 string = "pt.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ro
	// END DEBUGGING
	// VolumeLanguageRo captures enum value "ro"
	VolumeLanguageRo string = "ro"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ro.utf_8
	// END DEBUGGING
	// VolumeLanguageRoDotUTF8 captures enum value "ro.utf_8"
	VolumeLanguageRoDotUTF8 string = "ro.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ru
	// END DEBUGGING
	// VolumeLanguageRu captures enum value "ru"
	VolumeLanguageRu string = "ru"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// ru.utf_8
	// END DEBUGGING
	// VolumeLanguageRuDotUTF8 captures enum value "ru.utf_8"
	VolumeLanguageRuDotUTF8 string = "ru.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// sk
	// END DEBUGGING
	// VolumeLanguageSk captures enum value "sk"
	VolumeLanguageSk string = "sk"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// sk.utf_8
	// END DEBUGGING
	// VolumeLanguageSkDotUTF8 captures enum value "sk.utf_8"
	VolumeLanguageSkDotUTF8 string = "sk.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// sl
	// END DEBUGGING
	// VolumeLanguageSl captures enum value "sl"
	VolumeLanguageSl string = "sl"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// sl.utf_8
	// END DEBUGGING
	// VolumeLanguageSlDotUTF8 captures enum value "sl.utf_8"
	VolumeLanguageSlDotUTF8 string = "sl.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// sv
	// END DEBUGGING
	// VolumeLanguageSv captures enum value "sv"
	VolumeLanguageSv string = "sv"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// sv.utf_8
	// END DEBUGGING
	// VolumeLanguageSvDotUTF8 captures enum value "sv.utf_8"
	VolumeLanguageSvDotUTF8 string = "sv.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// tr
	// END DEBUGGING
	// VolumeLanguageTr captures enum value "tr"
	VolumeLanguageTr string = "tr"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// tr.utf_8
	// END DEBUGGING
	// VolumeLanguageTrDotUTF8 captures enum value "tr.utf_8"
	VolumeLanguageTrDotUTF8 string = "tr.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// utf8mb4
	// END DEBUGGING
	// VolumeLanguageUtf8mb4 captures enum value "utf8mb4"
	VolumeLanguageUtf8mb4 string = "utf8mb4"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh
	// END DEBUGGING
	// VolumeLanguageZh captures enum value "zh"
	VolumeLanguageZh string = "zh"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh.gbk
	// END DEBUGGING
	// VolumeLanguageZhDotGbk captures enum value "zh.gbk"
	VolumeLanguageZhDotGbk string = "zh.gbk"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh.gbk.utf_8
	// END DEBUGGING
	// VolumeLanguageZhDotGbkDotUTF8 captures enum value "zh.gbk.utf_8"
	VolumeLanguageZhDotGbkDotUTF8 string = "zh.gbk.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh.utf_8
	// END DEBUGGING
	// VolumeLanguageZhDotUTF8 captures enum value "zh.utf_8"
	VolumeLanguageZhDotUTF8 string = "zh.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh_tw
	// END DEBUGGING
	// VolumeLanguageZhTw captures enum value "zh_tw"
	VolumeLanguageZhTw string = "zh_tw"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh_tw.big5
	// END DEBUGGING
	// VolumeLanguageZhTwDotBig5 captures enum value "zh_tw.big5"
	VolumeLanguageZhTwDotBig5 string = "zh_tw.big5"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh_tw.big5.utf_8
	// END DEBUGGING
	// VolumeLanguageZhTwDotBig5DotUTF8 captures enum value "zh_tw.big5.utf_8"
	VolumeLanguageZhTwDotBig5DotUTF8 string = "zh_tw.big5.utf_8"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// language
	// Language
	// zh_tw.utf_8
	// END DEBUGGING
	// VolumeLanguageZhTwDotUTF8 captures enum value "zh_tw.utf_8"
	VolumeLanguageZhTwDotUTF8 string = "zh_tw.utf_8"
)

// prop value enum
func (m *Volume) validateLanguageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeLanguagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(m.Language) { // not required
		return nil
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", m.Language); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateMovement(formats strfmt.Registry) error {
	if swag.IsZero(m.Movement) { // not required
		return nil
	}

	if m.Movement != nil {
		if err := m.Movement.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 203); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateNas(formats strfmt.Registry) error {
	if swag.IsZero(m.Nas) { // not required
		return nil
	}

	if m.Nas != nil {
		if err := m.Nas.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.Quota) { // not required
		return nil
	}

	if m.Quota != nil {
		if err := m.Quota.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quota")
			}
			return err
		}
	}

	return nil
}

var volumeTypeScheduledSnapshotNamingSchemePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["create_time","ordinal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeScheduledSnapshotNamingSchemePropEnum = append(volumeTypeScheduledSnapshotNamingSchemePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// scheduled_snapshot_naming_scheme
	// ScheduledSnapshotNamingScheme
	// create_time
	// END DEBUGGING
	// VolumeScheduledSnapshotNamingSchemeCreateTime captures enum value "create_time"
	VolumeScheduledSnapshotNamingSchemeCreateTime string = "create_time"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// scheduled_snapshot_naming_scheme
	// ScheduledSnapshotNamingScheme
	// ordinal
	// END DEBUGGING
	// VolumeScheduledSnapshotNamingSchemeOrdinal captures enum value "ordinal"
	VolumeScheduledSnapshotNamingSchemeOrdinal string = "ordinal"
)

// prop value enum
func (m *Volume) validateScheduledSnapshotNamingSchemeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeScheduledSnapshotNamingSchemePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateScheduledSnapshotNamingScheme(formats strfmt.Registry) error {
	if swag.IsZero(m.ScheduledSnapshotNamingScheme) { // not required
		return nil
	}

	// value enum
	if err := m.validateScheduledSnapshotNamingSchemeEnum("scheduled_snapshot_naming_scheme", "body", *m.ScheduledSnapshotNamingScheme); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateSnaplock(formats strfmt.Registry) error {
	if swag.IsZero(m.Snaplock) { // not required
		return nil
	}

	if m.Snaplock != nil {
		if err := m.Snaplock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateSnapmirror(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapmirror) { // not required
		return nil
	}

	if m.Snapmirror != nil {
		if err := m.Snapmirror.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateSnapshotCount(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("snapshot_count", "body", m.SnapshotCount, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("snapshot_count", "body", m.SnapshotCount, 1023, false); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateSnapshotPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

var volumeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["error","mixed","offline","online","restricted"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeStatePropEnum = append(volumeTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// state
	// State
	// error
	// END DEBUGGING
	// VolumeStateError captures enum value "error"
	VolumeStateError string = "error"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// state
	// State
	// mixed
	// END DEBUGGING
	// VolumeStateMixed captures enum value "mixed"
	VolumeStateMixed string = "mixed"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// state
	// State
	// offline
	// END DEBUGGING
	// VolumeStateOffline captures enum value "offline"
	VolumeStateOffline string = "offline"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// state
	// State
	// online
	// END DEBUGGING
	// VolumeStateOnline captures enum value "online"
	VolumeStateOnline string = "online"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// state
	// State
	// restricted
	// END DEBUGGING
	// VolumeStateRestricted captures enum value "restricted"
	VolumeStateRestricted string = "restricted"
)

// prop value enum
func (m *Volume) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

var volumeTypeStylePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["flexvol","flexgroup","flexgroup_constituent"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeStylePropEnum = append(volumeTypeStylePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// style
	// Style
	// flexvol
	// END DEBUGGING
	// VolumeStyleFlexvol captures enum value "flexvol"
	VolumeStyleFlexvol string = "flexvol"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// style
	// Style
	// flexgroup
	// END DEBUGGING
	// VolumeStyleFlexgroup captures enum value "flexgroup"
	VolumeStyleFlexgroup string = "flexgroup"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// style
	// Style
	// flexgroup_constituent
	// END DEBUGGING
	// VolumeStyleFlexgroupConstituent captures enum value "flexgroup_constituent"
	VolumeStyleFlexgroupConstituent string = "flexgroup_constituent"
)

// prop value enum
func (m *Volume) validateStyleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeStylePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateStyle(formats strfmt.Registry) error {
	if swag.IsZero(m.Style) { // not required
		return nil
	}

	// value enum
	if err := m.validateStyleEnum("style", "body", m.Style); err != nil {
		return err
	}

	return nil
}

func (m *Volume) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) validateTiering(formats strfmt.Registry) error {
	if swag.IsZero(m.Tiering) { // not required
		return nil
	}

	if m.Tiering != nil {
		if err := m.Tiering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

var volumeTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["rw","dp","ls"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTypeTypePropEnum = append(volumeTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// volume
	// Volume
	// type
	// Type
	// rw
	// END DEBUGGING
	// VolumeTypeRw captures enum value "rw"
	VolumeTypeRw string = "rw"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// type
	// Type
	// dp
	// END DEBUGGING
	// VolumeTypeDp captures enum value "dp"
	VolumeTypeDp string = "dp"

	// BEGIN DEBUGGING
	// volume
	// Volume
	// type
	// Type
	// ls
	// END DEBUGGING
	// VolumeTypeLs captures enum value "ls"
	VolumeTypeLs string = "ls"
)

// prop value enum
func (m *Volume) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Volume) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume based on the context it is used
func (m *Volume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateActivityTracking(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAnalytics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAntiRansomware(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateApplication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutosize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConsistencyGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConstituents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEfficiency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateErrorState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlashPool(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexcacheEndpointType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGuarantee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsObjectStore(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSvmRoot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMovement(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNas(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnaplock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapmirror(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTiering(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Volume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateActivityTracking(ctx context.Context, formats strfmt.Registry) error {

	if m.ActivityTracking != nil {
		if err := m.ActivityTracking.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activity_tracking")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateAggregates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Aggregates); i++ {

		if m.Aggregates[i] != nil {
			if err := m.Aggregates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Volume) contextValidateAnalytics(ctx context.Context, formats strfmt.Registry) error {

	if m.Analytics != nil {
		if err := m.Analytics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("analytics")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateAntiRansomware(ctx context.Context, formats strfmt.Registry) error {

	if m.AntiRansomware != nil {
		if err := m.AntiRansomware.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("anti_ransomware")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateApplication(ctx context.Context, formats strfmt.Registry) error {

	if m.Application != nil {
		if err := m.Application.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateAutosize(ctx context.Context, formats strfmt.Registry) error {

	if m.Autosize != nil {
		if err := m.Autosize.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autosize")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateClone(ctx context.Context, formats strfmt.Registry) error {

	if m.Clone != nil {
		if err := m.Clone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateConsistencyGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ConsistencyGroup != nil {
		if err := m.ConsistencyGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateConstituents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Constituents); i++ {

		if m.Constituents[i] != nil {
			if err := m.Constituents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("constituents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Volume) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", m.CreateTime); err != nil {
		return err
	}

	return nil
}

func (m *Volume) contextValidateEfficiency(ctx context.Context, formats strfmt.Registry) error {

	if m.Efficiency != nil {
		if err := m.Efficiency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("efficiency")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.Encryption != nil {
		if err := m.Encryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateErrorState(ctx context.Context, formats strfmt.Registry) error {

	if m.ErrorState != nil {
		if err := m.ErrorState.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error_state")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateFiles(ctx context.Context, formats strfmt.Registry) error {

	if m.Files != nil {
		if err := m.Files.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("files")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateFlashPool(ctx context.Context, formats strfmt.Registry) error {

	if m.FlashPool != nil {
		if err := m.FlashPool.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flash_pool")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateFlexcacheEndpointType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flexcache_endpoint_type", "body", string(m.FlexcacheEndpointType)); err != nil {
		return err
	}

	return nil
}

func (m *Volume) contextValidateFlexgroup(ctx context.Context, formats strfmt.Registry) error {

	if m.Flexgroup != nil {
		if err := m.Flexgroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexgroup")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateGuarantee(ctx context.Context, formats strfmt.Registry) error {

	if m.Guarantee != nil {
		if err := m.Guarantee.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateIsObjectStore(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "is_object_store", "body", m.IsObjectStore); err != nil {
		return err
	}

	return nil
}

func (m *Volume) contextValidateIsSvmRoot(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "is_svm_root", "body", m.IsSvmRoot); err != nil {
		return err
	}

	return nil
}

func (m *Volume) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateMovement(ctx context.Context, formats strfmt.Registry) error {

	if m.Movement != nil {
		if err := m.Movement.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateNas(ctx context.Context, formats strfmt.Registry) error {

	if m.Nas != nil {
		if err := m.Nas.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {
		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateQuota(ctx context.Context, formats strfmt.Registry) error {

	if m.Quota != nil {
		if err := m.Quota.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quota")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateSnaplock(ctx context.Context, formats strfmt.Registry) error {

	if m.Snaplock != nil {
		if err := m.Snaplock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateSnapmirror(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapmirror != nil {
		if err := m.Snapmirror.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateSnapshotCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot_count", "body", int64(m.SnapshotCount)); err != nil {
		return err
	}

	return nil
}

func (m *Volume) contextValidateSnapshotPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotPolicy != nil {
		if err := m.SnapshotPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", []string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *Volume) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateTiering(ctx context.Context, formats strfmt.Registry) error {

	if m.Tiering != nil {
		if err := m.Tiering.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tiering")
			}
			return err
		}
	}

	return nil
}

func (m *Volume) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Volume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Volume) UnmarshalBinary(b []byte) error {
	var res Volume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeActivityTracking volume activity tracking
//
// swagger:model VolumeActivityTracking
type VolumeActivityTracking struct {

	// Activity tracking state of the volume. If this value is "on", ONTAP collects top metrics information for the volume in real time. There is a slight impact to I/O performance in order to collect this information. If this value is "off", no activity tracking information is collected or available to view.
	// Enum: [off on]
	State string `json:"state,omitempty"`

	// This field indicates whether or not volume activity tracking is supported on the volume. If volume activity tracking is not supported, the reason why is provided in the "activity_tracking.unsupported_reason" field.
	// Read Only: true
	Supported *bool `json:"supported,omitempty"`

	// unsupported reason
	UnsupportedReason *VolumeActivityTrackingUnsupportedReason `json:"unsupported_reason,omitempty"`
}

// Validate validates this volume activity tracking
func (m *VolumeActivityTracking) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnsupportedReason(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeActivityTrackingTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["off","on"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeActivityTrackingTypeStatePropEnum = append(volumeActivityTrackingTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeActivityTracking
	// VolumeActivityTracking
	// state
	// State
	// off
	// END DEBUGGING
	// VolumeActivityTrackingStateOff captures enum value "off"
	VolumeActivityTrackingStateOff string = "off"

	// BEGIN DEBUGGING
	// VolumeActivityTracking
	// VolumeActivityTracking
	// state
	// State
	// on
	// END DEBUGGING
	// VolumeActivityTrackingStateOn captures enum value "on"
	VolumeActivityTrackingStateOn string = "on"
)

// prop value enum
func (m *VolumeActivityTracking) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeActivityTrackingTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeActivityTracking) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("activity_tracking"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *VolumeActivityTracking) validateUnsupportedReason(formats strfmt.Registry) error {
	if swag.IsZero(m.UnsupportedReason) { // not required
		return nil
	}

	if m.UnsupportedReason != nil {
		if err := m.UnsupportedReason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activity_tracking" + "." + "unsupported_reason")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume activity tracking based on the context it is used
func (m *VolumeActivityTracking) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSupported(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnsupportedReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeActivityTracking) contextValidateSupported(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "activity_tracking"+"."+"supported", "body", m.Supported); err != nil {
		return err
	}

	return nil
}

func (m *VolumeActivityTracking) contextValidateUnsupportedReason(ctx context.Context, formats strfmt.Registry) error {

	if m.UnsupportedReason != nil {
		if err := m.UnsupportedReason.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activity_tracking" + "." + "unsupported_reason")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeActivityTracking) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeActivityTracking) UnmarshalBinary(b []byte) error {
	var res VolumeActivityTracking
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeActivityTrackingUnsupportedReason volume activity tracking unsupported reason
//
// swagger:model VolumeActivityTrackingUnsupportedReason
type VolumeActivityTrackingUnsupportedReason struct {

	// If volume activity tracking is not supported on the volume, this field provides an appropriate error code.
	// Example: 124518405
	// Read Only: true
	Code string `json:"code,omitempty"`

	// If volume activity tracking is not supported on the volume, this field provides an error message detailing why this is the case.
	// Example: Volume activity tracking cannot be enabled on volumes that contain LUNs.
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this volume activity tracking unsupported reason
func (m *VolumeActivityTrackingUnsupportedReason) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume activity tracking unsupported reason based on the context it is used
func (m *VolumeActivityTrackingUnsupportedReason) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeActivityTrackingUnsupportedReason) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "activity_tracking"+"."+"unsupported_reason"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeActivityTrackingUnsupportedReason) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "activity_tracking"+"."+"unsupported_reason"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeActivityTrackingUnsupportedReason) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeActivityTrackingUnsupportedReason) UnmarshalBinary(b []byte) error {
	var res VolumeActivityTrackingUnsupportedReason
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAggregatesItems0 Aggregate
//
// swagger:model VolumeAggregatesItems0
type VolumeAggregatesItems0 struct {

	// links
	Links *VolumeAggregatesItems0Links `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume aggregates items0
func (m *VolumeAggregatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAggregatesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume aggregates items0 based on the context it is used
func (m *VolumeAggregatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAggregatesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAggregatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAggregatesItems0) UnmarshalBinary(b []byte) error {
	var res VolumeAggregatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAggregatesItems0Links volume aggregates items0 links
//
// swagger:model VolumeAggregatesItems0Links
type VolumeAggregatesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume aggregates items0 links
func (m *VolumeAggregatesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAggregatesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume aggregates items0 links based on the context it is used
func (m *VolumeAggregatesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAggregatesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAggregatesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAggregatesItems0Links) UnmarshalBinary(b []byte) error {
	var res VolumeAggregatesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAnalytics volume analytics
//
// swagger:model VolumeAnalytics
type VolumeAnalytics struct {

	// Percentage of files in the volume that the file system analytics initialization scan has processed. Only returned when the state is `initializing`.
	// Example: 17
	// Read Only: true
	ScanProgress int64 `json:"scan_progress,omitempty"`

	// File system analytics state of the volume. If this value is "on", ONTAP collects extra file system analytics information for all directories on the volume.  There will be a slight impact to I/O performance to collect this information. If this value is "off", file system analytics information is not collected and not available to be viewed. If this value is "initializing", that means file system analytics was recently turned on, and the initialization scan to gather information all all existing files and directories is currently running. If this value is 'unknown' that means there was an internal error when determining the file system analytics state for the volume.
	// Enum: [unknown initializing off on]
	State string `json:"state,omitempty"`

	// This field indicates whether or not file system analytics is supported on the volume. If file system analytics is not supported, the reason will be specified in the "analytics.unsupported_reason" field.
	// Read Only: true
	Supported *bool `json:"supported,omitempty"`

	// unsupported reason
	UnsupportedReason *VolumeAnalyticsUnsupportedReason `json:"unsupported_reason,omitempty"`
}

// Validate validates this volume analytics
func (m *VolumeAnalytics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnsupportedReason(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeAnalyticsTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unknown","initializing","off","on"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeAnalyticsTypeStatePropEnum = append(volumeAnalyticsTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeAnalytics
	// VolumeAnalytics
	// state
	// State
	// unknown
	// END DEBUGGING
	// VolumeAnalyticsStateUnknown captures enum value "unknown"
	VolumeAnalyticsStateUnknown string = "unknown"

	// BEGIN DEBUGGING
	// VolumeAnalytics
	// VolumeAnalytics
	// state
	// State
	// initializing
	// END DEBUGGING
	// VolumeAnalyticsStateInitializing captures enum value "initializing"
	VolumeAnalyticsStateInitializing string = "initializing"

	// BEGIN DEBUGGING
	// VolumeAnalytics
	// VolumeAnalytics
	// state
	// State
	// off
	// END DEBUGGING
	// VolumeAnalyticsStateOff captures enum value "off"
	VolumeAnalyticsStateOff string = "off"

	// BEGIN DEBUGGING
	// VolumeAnalytics
	// VolumeAnalytics
	// state
	// State
	// on
	// END DEBUGGING
	// VolumeAnalyticsStateOn captures enum value "on"
	VolumeAnalyticsStateOn string = "on"
)

// prop value enum
func (m *VolumeAnalytics) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeAnalyticsTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeAnalytics) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("analytics"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAnalytics) validateUnsupportedReason(formats strfmt.Registry) error {
	if swag.IsZero(m.UnsupportedReason) { // not required
		return nil
	}

	if m.UnsupportedReason != nil {
		if err := m.UnsupportedReason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("analytics" + "." + "unsupported_reason")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume analytics based on the context it is used
func (m *VolumeAnalytics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateScanProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupported(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnsupportedReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAnalytics) contextValidateScanProgress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "analytics"+"."+"scan_progress", "body", int64(m.ScanProgress)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAnalytics) contextValidateSupported(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "analytics"+"."+"supported", "body", m.Supported); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAnalytics) contextValidateUnsupportedReason(ctx context.Context, formats strfmt.Registry) error {

	if m.UnsupportedReason != nil {
		if err := m.UnsupportedReason.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("analytics" + "." + "unsupported_reason")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAnalytics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAnalytics) UnmarshalBinary(b []byte) error {
	var res VolumeAnalytics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAnalyticsUnsupportedReason volume analytics unsupported reason
//
// swagger:model VolumeAnalyticsUnsupportedReason
type VolumeAnalyticsUnsupportedReason struct {

	// If file system analytics is not supported on the volume, this field provides the error code explaining why.
	// Example: 111411207
	// Read Only: true
	Code string `json:"code,omitempty"`

	// If file system analytics is not supported on the volume, this field provides the error message explaining why.
	// Example: File system analytics cannot be enabled on volumes that contain LUNs.
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this volume analytics unsupported reason
func (m *VolumeAnalyticsUnsupportedReason) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume analytics unsupported reason based on the context it is used
func (m *VolumeAnalyticsUnsupportedReason) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAnalyticsUnsupportedReason) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "analytics"+"."+"unsupported_reason"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAnalyticsUnsupportedReason) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "analytics"+"."+"unsupported_reason"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAnalyticsUnsupportedReason) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAnalyticsUnsupportedReason) UnmarshalBinary(b []byte) error {
	var res VolumeAnalyticsUnsupportedReason
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAntiRansomwareType Anti-ransomware related information of the volume.
//
// swagger:model VolumeAntiRansomwareType
type VolumeAntiRansomwareType struct {

	// Probability of a ransomware attack.<br>`none` No files are suspected of ransomware activity.<br>`low` A number of files are suspected of ransomware activity.<br>`moderate` A moderate number of files are suspected of ransomware activity.<br>`high` A large number of files are suspected of ransomware activity.
	// Read Only: true
	// Enum: [none low moderate high]
	AttackProbability string `json:"attack_probability,omitempty"`

	// attack reports
	AttackReports []*AntiRansomwareAttackReport `json:"attack_reports,omitempty"`

	// Time when Anti-ransomware monitoring `state` is set to dry-run value for starting evaluation mode.
	// Read Only: true
	// Format: date-time
	DryRunStartTime *strfmt.DateTime `json:"dry_run_start_time,omitempty"`

	// space
	Space *VolumeAntiRansomwareSpace `json:"space,omitempty"`

	// Anti-ransomware state.<br>`disabled` Anti-ransomware monitoring is disabled on the volume.  This is the default state in a POST operation.<br>`disable_in_progress` Anti-ransomware monitoring is being disabled and a cleanup operation is in effect. Valid in GET operation.<br>`dry_run` Anti-ransomware monitoring is enabled in the evaluation mode.<br>`enabled` Anti-ransomware monitoring is active on the volume.<br>`paused` Anti-ransomware monitoring is paused on the volume.<br>`enable_paused` Anti-ransomware monitoring is paused on the volume from its earlier enabled state. Valid in GET operation. <br>`dry_run_paused` Anti-ransomware monitoring is paused on the volume from its earlier dry_run state. Valid in GET operation. <br>For POST, the valid Anti-ransomware states are only `disabled`, `enabled` and `dry_run`, whereas for PATCH, `paused` is also valid along with the three valid states for POST.
	// Enum: [disabled disable_in_progress dry_run enabled paused enable_paused dry_run_paused]
	State string `json:"state,omitempty"`

	// suspect files
	SuspectFiles []*VolumeAntiRansomwareSuspectFilesItems0 `json:"suspect_files,omitempty"`
}

// Validate validates this volume anti ransomware type
func (m *VolumeAntiRansomwareType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttackProbability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttackReports(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDryRunStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuspectFiles(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeAntiRansomwareTypeTypeAttackProbabilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","low","moderate","high"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeAntiRansomwareTypeTypeAttackProbabilityPropEnum = append(volumeAntiRansomwareTypeTypeAttackProbabilityPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// attack_probability
	// AttackProbability
	// none
	// END DEBUGGING
	// VolumeAntiRansomwareTypeAttackProbabilityNone captures enum value "none"
	VolumeAntiRansomwareTypeAttackProbabilityNone string = "none"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// attack_probability
	// AttackProbability
	// low
	// END DEBUGGING
	// VolumeAntiRansomwareTypeAttackProbabilityLow captures enum value "low"
	VolumeAntiRansomwareTypeAttackProbabilityLow string = "low"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// attack_probability
	// AttackProbability
	// moderate
	// END DEBUGGING
	// VolumeAntiRansomwareTypeAttackProbabilityModerate captures enum value "moderate"
	VolumeAntiRansomwareTypeAttackProbabilityModerate string = "moderate"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// attack_probability
	// AttackProbability
	// high
	// END DEBUGGING
	// VolumeAntiRansomwareTypeAttackProbabilityHigh captures enum value "high"
	VolumeAntiRansomwareTypeAttackProbabilityHigh string = "high"
)

// prop value enum
func (m *VolumeAntiRansomwareType) validateAttackProbabilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeAntiRansomwareTypeTypeAttackProbabilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeAntiRansomwareType) validateAttackProbability(formats strfmt.Registry) error {
	if swag.IsZero(m.AttackProbability) { // not required
		return nil
	}

	// value enum
	if err := m.validateAttackProbabilityEnum("anti_ransomware"+"."+"attack_probability", "body", m.AttackProbability); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareType) validateAttackReports(formats strfmt.Registry) error {
	if swag.IsZero(m.AttackReports) { // not required
		return nil
	}

	for i := 0; i < len(m.AttackReports); i++ {
		if swag.IsZero(m.AttackReports[i]) { // not required
			continue
		}

		if m.AttackReports[i] != nil {
			if err := m.AttackReports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("anti_ransomware" + "." + "attack_reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VolumeAntiRansomwareType) validateDryRunStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.DryRunStartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("anti_ransomware"+"."+"dry_run_start_time", "body", "date-time", m.DryRunStartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareType) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("anti_ransomware" + "." + "space")
			}
			return err
		}
	}

	return nil
}

var volumeAntiRansomwareTypeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["disabled","disable_in_progress","dry_run","enabled","paused","enable_paused","dry_run_paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeAntiRansomwareTypeTypeStatePropEnum = append(volumeAntiRansomwareTypeTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// state
	// State
	// disabled
	// END DEBUGGING
	// VolumeAntiRansomwareTypeStateDisabled captures enum value "disabled"
	VolumeAntiRansomwareTypeStateDisabled string = "disabled"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// state
	// State
	// disable_in_progress
	// END DEBUGGING
	// VolumeAntiRansomwareTypeStateDisableInProgress captures enum value "disable_in_progress"
	VolumeAntiRansomwareTypeStateDisableInProgress string = "disable_in_progress"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// state
	// State
	// dry_run
	// END DEBUGGING
	// VolumeAntiRansomwareTypeStateDryRun captures enum value "dry_run"
	VolumeAntiRansomwareTypeStateDryRun string = "dry_run"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// state
	// State
	// enabled
	// END DEBUGGING
	// VolumeAntiRansomwareTypeStateEnabled captures enum value "enabled"
	VolumeAntiRansomwareTypeStateEnabled string = "enabled"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// state
	// State
	// paused
	// END DEBUGGING
	// VolumeAntiRansomwareTypeStatePaused captures enum value "paused"
	VolumeAntiRansomwareTypeStatePaused string = "paused"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// state
	// State
	// enable_paused
	// END DEBUGGING
	// VolumeAntiRansomwareTypeStateEnablePaused captures enum value "enable_paused"
	VolumeAntiRansomwareTypeStateEnablePaused string = "enable_paused"

	// BEGIN DEBUGGING
	// VolumeAntiRansomwareType
	// VolumeAntiRansomwareType
	// state
	// State
	// dry_run_paused
	// END DEBUGGING
	// VolumeAntiRansomwareTypeStateDryRunPaused captures enum value "dry_run_paused"
	VolumeAntiRansomwareTypeStateDryRunPaused string = "dry_run_paused"
)

// prop value enum
func (m *VolumeAntiRansomwareType) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeAntiRansomwareTypeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeAntiRansomwareType) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("anti_ransomware"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareType) validateSuspectFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.SuspectFiles) { // not required
		return nil
	}

	for i := 0; i < len(m.SuspectFiles); i++ {
		if swag.IsZero(m.SuspectFiles[i]) { // not required
			continue
		}

		if m.SuspectFiles[i] != nil {
			if err := m.SuspectFiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("anti_ransomware" + "." + "suspect_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this volume anti ransomware type based on the context it is used
func (m *VolumeAntiRansomwareType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttackProbability(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAttackReports(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDryRunStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuspectFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAntiRansomwareType) contextValidateAttackProbability(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "anti_ransomware"+"."+"attack_probability", "body", string(m.AttackProbability)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareType) contextValidateAttackReports(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AttackReports); i++ {

		if m.AttackReports[i] != nil {
			if err := m.AttackReports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("anti_ransomware" + "." + "attack_reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VolumeAntiRansomwareType) contextValidateDryRunStartTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "anti_ransomware"+"."+"dry_run_start_time", "body", m.DryRunStartTime); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareType) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("anti_ransomware" + "." + "space")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeAntiRansomwareType) contextValidateSuspectFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SuspectFiles); i++ {

		if m.SuspectFiles[i] != nil {
			if err := m.SuspectFiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("anti_ransomware" + "." + "suspect_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAntiRansomwareType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAntiRansomwareType) UnmarshalBinary(b []byte) error {
	var res VolumeAntiRansomwareType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAntiRansomwareSpace volume anti ransomware space
//
// swagger:model VolumeAntiRansomwareSpace
type VolumeAntiRansomwareSpace struct {

	// Total number of Anti-ransomware backup Snapshot copies.
	// Read Only: true
	SnapshotCount int64 `json:"snapshot_count,omitempty"`

	// Total space in bytes used by the Anti-ransomware feature.
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// Space in bytes used by the Anti-ransomware analytics logs.
	// Read Only: true
	UsedByLogs int64 `json:"used_by_logs,omitempty"`

	// Space in bytes used by the Anti-ransomware backup Snapshot copies.
	// Read Only: true
	UsedBySnapshots int64 `json:"used_by_snapshots,omitempty"`
}

// Validate validates this volume anti ransomware space
func (m *VolumeAntiRansomwareSpace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume anti ransomware space based on the context it is used
func (m *VolumeAntiRansomwareSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSnapshotCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedByLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedBySnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAntiRansomwareSpace) contextValidateSnapshotCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "anti_ransomware"+"."+"space"+"."+"snapshot_count", "body", int64(m.SnapshotCount)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareSpace) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "anti_ransomware"+"."+"space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareSpace) contextValidateUsedByLogs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "anti_ransomware"+"."+"space"+"."+"used_by_logs", "body", int64(m.UsedByLogs)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareSpace) contextValidateUsedBySnapshots(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "anti_ransomware"+"."+"space"+"."+"used_by_snapshots", "body", int64(m.UsedBySnapshots)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAntiRansomwareSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAntiRansomwareSpace) UnmarshalBinary(b []byte) error {
	var res VolumeAntiRansomwareSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAntiRansomwareSuspectFilesItems0 volume anti ransomware suspect files items0
//
// swagger:model VolumeAntiRansomwareSuspectFilesItems0
type VolumeAntiRansomwareSuspectFilesItems0 struct {

	// Total number of `suspect_files.format` files observed by the Anti-ransomware analytics engine on the volume.
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// File formats observed by the Anti-ransomware analytics engine on the volume.
	// Read Only: true
	Format string `json:"format,omitempty"`
}

// Validate validates this volume anti ransomware suspect files items0
func (m *VolumeAntiRansomwareSuspectFilesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume anti ransomware suspect files items0 based on the context it is used
func (m *VolumeAntiRansomwareSuspectFilesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeAntiRansomwareSuspectFilesItems0) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeAntiRansomwareSuspectFilesItems0) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "format", "body", string(m.Format)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAntiRansomwareSuspectFilesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAntiRansomwareSuspectFilesItems0) UnmarshalBinary(b []byte) error {
	var res VolumeAntiRansomwareSuspectFilesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeApplication volume application
//
// swagger:model VolumeApplication
type VolumeApplication struct {

	// Name of the application to which the volume belongs. Available only when the volume is part of an application.
	// Read Only: true
	Name string `json:"name,omitempty"`

	// UUID of the application to which the volume belongs. Available only when the volume is part of an application.
	// Example: 1cd8a442-86d1-11e0-ae1d-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume application
func (m *VolumeApplication) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume application based on the context it is used
func (m *VolumeApplication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeApplication) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "application"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeApplication) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "application"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeApplication) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeApplication) UnmarshalBinary(b []byte) error {
	var res VolumeApplication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeAutosize volume autosize
//
// swagger:model VolumeAutosize
type VolumeAutosize struct {

	// Used space threshold size, in percentage, for the automatic growth of the volume. When the amount of used space in the volume becomes greater than this threhold, the volume automatically grows unless it has reached the maximum size. The volume grows when 'space.used' is greater than this percent of 'space.size'. The 'grow_threshold' size cannot be less than or equal to the 'shrink_threshold' size..
	GrowThreshold int64 `json:"grow_threshold,omitempty"`

	// Maximum size in bytes up to which a volume grows automatically. This size cannot be less than the current volume size, or less than or equal to the minimum size of volume.
	Maximum int64 `json:"maximum,omitempty"`

	// Minimum size in bytes up to which the volume shrinks automatically. This size cannot be greater than or equal to the maximum size of volume.
	Minimum int64 `json:"minimum,omitempty"`

	// Autosize mode for the volume.<br>grow &dash; Volume automatically grows when the amount of used space is above the 'grow_threshold' value.<br>grow_shrink &dash; Volume grows or shrinks in response to the amount of space used.<br>off &dash; Autosizing of the volume is disabled.
	// Enum: [grow grow_shrink off]
	Mode string `json:"mode,omitempty"`

	// Used space threshold size, in percentage, for the automatic shrinkage of the volume.  When the amount of used space in the volume drops below this threshold, the volume automatically shrinks unless it has reached the minimum size. The volume shrinks when the 'space.used' is less than the 'shrink_threshold' percent of 'space.size'. The 'shrink_threshold' size cannot be greater than or equal to the 'grow_threshold' size.
	ShrinkThreshold int64 `json:"shrink_threshold,omitempty"`
}

// Validate validates this volume autosize
func (m *VolumeAutosize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeAutosizeTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["grow","grow_shrink","off"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeAutosizeTypeModePropEnum = append(volumeAutosizeTypeModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeAutosize
	// VolumeAutosize
	// mode
	// Mode
	// grow
	// END DEBUGGING
	// VolumeAutosizeModeGrow captures enum value "grow"
	VolumeAutosizeModeGrow string = "grow"

	// BEGIN DEBUGGING
	// VolumeAutosize
	// VolumeAutosize
	// mode
	// Mode
	// grow_shrink
	// END DEBUGGING
	// VolumeAutosizeModeGrowShrink captures enum value "grow_shrink"
	VolumeAutosizeModeGrowShrink string = "grow_shrink"

	// BEGIN DEBUGGING
	// VolumeAutosize
	// VolumeAutosize
	// mode
	// Mode
	// off
	// END DEBUGGING
	// VolumeAutosizeModeOff captures enum value "off"
	VolumeAutosizeModeOff string = "off"
)

// prop value enum
func (m *VolumeAutosize) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeAutosizeTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeAutosize) validateMode(formats strfmt.Registry) error {
	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("autosize"+"."+"mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this volume autosize based on context it is used
func (m *VolumeAutosize) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeAutosize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeAutosize) UnmarshalBinary(b []byte) error {
	var res VolumeAutosize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeClone volume clone
//
// swagger:model VolumeClone
type VolumeClone struct {

	// Specifies if this volume is a normal FlexVol or FlexClone. This field needs to be set when creating a FlexClone. Valid in POST.
	IsFlexclone bool `json:"is_flexclone,omitempty"`

	// parent snapshot
	ParentSnapshot *SnapshotReference `json:"parent_snapshot,omitempty"`

	// parent svm
	ParentSvm *VolumeCloneParentSvm `json:"parent_svm,omitempty"`

	// parent volume
	ParentVolume *VolumeCloneParentVolume `json:"parent_volume,omitempty"`

	// Percentage of FlexClone blocks split from its parent volume.
	// Read Only: true
	SplitCompletePercent int64 `json:"split_complete_percent,omitempty"`

	// Space required by the containing-aggregate to split the FlexClone volume.
	// Read Only: true
	SplitEstimate int64 `json:"split_estimate,omitempty"`

	// This field is set when split is executed on any FlexClone, that is when the FlexClone volume is split from its parent FlexVol. This field needs to be set for splitting a FlexClone form FlexVol. Valid in PATCH.
	SplitInitiated bool `json:"split_initiated,omitempty"`
}

// Validate validates this volume clone
func (m *VolumeClone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateParentSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeClone) validateParentSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentSnapshot) { // not required
		return nil
	}

	if m.ParentSnapshot != nil {
		if err := m.ParentSnapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeClone) validateParentSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentSvm) { // not required
		return nil
	}

	if m.ParentSvm != nil {
		if err := m.ParentSvm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_svm")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeClone) validateParentVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentVolume) { // not required
		return nil
	}

	if m.ParentVolume != nil {
		if err := m.ParentVolume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume clone based on the context it is used
func (m *VolumeClone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateParentSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParentSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParentVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSplitCompletePercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSplitEstimate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeClone) contextValidateParentSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentSnapshot != nil {
		if err := m.ParentSnapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeClone) contextValidateParentSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentSvm != nil {
		if err := m.ParentSvm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_svm")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeClone) contextValidateParentVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentVolume != nil {
		if err := m.ParentVolume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_volume")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeClone) contextValidateSplitCompletePercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clone"+"."+"split_complete_percent", "body", int64(m.SplitCompletePercent)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeClone) contextValidateSplitEstimate(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clone"+"."+"split_estimate", "body", int64(m.SplitEstimate)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeClone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeClone) UnmarshalBinary(b []byte) error {
	var res VolumeClone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeCloneParentSvm volume clone parent svm
//
// swagger:model VolumeCloneParentSvm
type VolumeCloneParentSvm struct {

	// links
	Links *VolumeCloneParentSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume clone parent svm
func (m *VolumeCloneParentSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume clone parent svm based on the context it is used
func (m *VolumeCloneParentSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeCloneParentSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeCloneParentSvm) UnmarshalBinary(b []byte) error {
	var res VolumeCloneParentSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeCloneParentSvmLinks volume clone parent svm links
//
// swagger:model VolumeCloneParentSvmLinks
type VolumeCloneParentSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume clone parent svm links
func (m *VolumeCloneParentSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume clone parent svm links based on the context it is used
func (m *VolumeCloneParentSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeCloneParentSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeCloneParentSvmLinks) UnmarshalBinary(b []byte) error {
	var res VolumeCloneParentSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeCloneParentVolume volume clone parent volume
//
// swagger:model VolumeCloneParentVolume
type VolumeCloneParentVolume struct {

	// links
	Links *VolumeCloneParentVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume clone parent volume
func (m *VolumeCloneParentVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume clone parent volume based on the context it is used
func (m *VolumeCloneParentVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeCloneParentVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeCloneParentVolume) UnmarshalBinary(b []byte) error {
	var res VolumeCloneParentVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeCloneParentVolumeLinks volume clone parent volume links
//
// swagger:model VolumeCloneParentVolumeLinks
type VolumeCloneParentVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume clone parent volume links
func (m *VolumeCloneParentVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume clone parent volume links based on the context it is used
func (m *VolumeCloneParentVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeCloneParentVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "parent_volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeCloneParentVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeCloneParentVolumeLinks) UnmarshalBinary(b []byte) error {
	var res VolumeCloneParentVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConsistencyGroup Consistency group the volume is part of.
//
// swagger:model VolumeConsistencyGroup
type VolumeConsistencyGroup struct {

	// The name of the consistency group to which the volume belongs. Available only when the volume is part of a consistency group. If this volume belongs to a child consistency group, then this will be the UUID of the parent consistency group.
	// Example: consistency_group_1
	Name string `json:"name,omitempty"`

	// The UUID of the consistency group to which the volume belongs. Available only when the volume is part of a consistency group. If this volume belongs to a child consistency group, then this will be the UUID of the parent consistency group.
	// Example: 1cd8a442-86d1-11e0-ae1d-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume consistency group
func (m *VolumeConsistencyGroup) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume consistency group based on the context it is used
func (m *VolumeConsistencyGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConsistencyGroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "consistency_group"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConsistencyGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConsistencyGroup) UnmarshalBinary(b []byte) error {
	var res VolumeConsistencyGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0 volume constituents items0
//
// swagger:model VolumeConstituentsItems0
type VolumeConstituentsItems0 struct {

	// aggregates
	Aggregates *VolumeConstituentsItems0Aggregates `json:"aggregates,omitempty"`

	// movement
	Movement *VolumeConstituentsItems0Movement `json:"movement,omitempty"`

	// FlexGroup Constituents name
	// Read Only: true
	Name string `json:"name,omitempty"`

	// space
	Space *VolumeConstituentsItems0Space `json:"space,omitempty"`
}

// Validate validates this volume constituents items0
func (m *VolumeConstituentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMovement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0) validateAggregates(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregates) { // not required
		return nil
	}

	if m.Aggregates != nil {
		if err := m.Aggregates.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregates")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0) validateMovement(formats strfmt.Registry) error {
	if swag.IsZero(m.Movement) { // not required
		return nil
	}

	if m.Movement != nil {
		if err := m.Movement.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume constituents items0 based on the context it is used
func (m *VolumeConstituentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAggregates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMovement(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0) contextValidateAggregates(ctx context.Context, formats strfmt.Registry) error {

	if m.Aggregates != nil {
		if err := m.Aggregates.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregates")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0) contextValidateMovement(ctx context.Context, formats strfmt.Registry) error {

	if m.Movement != nil {
		if err := m.Movement.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0Aggregates volume constituents items0 aggregates
//
// swagger:model VolumeConstituentsItems0Aggregates
type VolumeConstituentsItems0Aggregates struct {

	// Name of the aggregate hosting the FlexGroup Constituent.
	// Read Only: true
	Name string `json:"name,omitempty"`

	// Unique identifier for the aggregate.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume constituents items0 aggregates
func (m *VolumeConstituentsItems0Aggregates) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume constituents items0 aggregates based on the context it is used
func (m *VolumeConstituentsItems0Aggregates) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0Aggregates) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregates"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Aggregates) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregates"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0Aggregates) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0Aggregates) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0Aggregates
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0Movement Volume movement. All attributes are modify, that is, not writable through POST. Set PATCH state to destination_aggregate to initiate a volume move operation. Volume movement on FlexGroup constituents are not supported.
//
// swagger:model VolumeConstituentsItems0Movement
type VolumeConstituentsItems0Movement struct {

	// Time window in seconds for cutover. The allowed range is between 30 to 300 seconds.
	// Example: 30
	CutoverWindow *int64 `json:"cutover_window,omitempty"`

	// destination aggregate
	DestinationAggregate *VolumeConstituentsItems0MovementDestinationAggregate `json:"destination_aggregate,omitempty"`

	// Completion percentage
	// Read Only: true
	PercentComplete int64 `json:"percent_complete,omitempty"`

	// State of volume move operation. PATCH the state to "aborted" to abort the move operation. PATCH the state to "cutover" to trigger cutover. PATCH the state to "paused" to pause the volume move operation in progress. PATCH the state to "replicating" to resume the paused volume move operation. PATCH the state to "cutover_wait" to go into cutover manually. When volume move operation is waiting to go into "cutover" state, this is indicated by the "cutover_pending" state. A change of state is only supported if volume movement is in progress.
	// Example: replicating
	// Enum: [aborted cutover cutover_wait cutover_pending failed paused queued replicating success]
	State string `json:"state,omitempty"`

	// Tiering policy for FabricPool
	// Enum: [all auto backup none snapshot_only]
	TieringPolicy string `json:"tiering_policy,omitempty"`
}

// Validate validates this volume constituents items0 movement
func (m *VolumeConstituentsItems0Movement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestinationAggregate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTieringPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0Movement) validateDestinationAggregate(formats strfmt.Registry) error {
	if swag.IsZero(m.DestinationAggregate) { // not required
		return nil
	}

	if m.DestinationAggregate != nil {
		if err := m.DestinationAggregate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate")
			}
			return err
		}
	}

	return nil
}

var volumeConstituentsItems0MovementTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aborted","cutover","cutover_wait","cutover_pending","failed","paused","queued","replicating","success"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeConstituentsItems0MovementTypeStatePropEnum = append(volumeConstituentsItems0MovementTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// aborted
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateAborted captures enum value "aborted"
	VolumeConstituentsItems0MovementStateAborted string = "aborted"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// cutover
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateCutover captures enum value "cutover"
	VolumeConstituentsItems0MovementStateCutover string = "cutover"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// cutover_wait
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateCutoverWait captures enum value "cutover_wait"
	VolumeConstituentsItems0MovementStateCutoverWait string = "cutover_wait"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// cutover_pending
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateCutoverPending captures enum value "cutover_pending"
	VolumeConstituentsItems0MovementStateCutoverPending string = "cutover_pending"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// failed
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateFailed captures enum value "failed"
	VolumeConstituentsItems0MovementStateFailed string = "failed"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// paused
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStatePaused captures enum value "paused"
	VolumeConstituentsItems0MovementStatePaused string = "paused"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// queued
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateQueued captures enum value "queued"
	VolumeConstituentsItems0MovementStateQueued string = "queued"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// replicating
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateReplicating captures enum value "replicating"
	VolumeConstituentsItems0MovementStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// state
	// State
	// success
	// END DEBUGGING
	// VolumeConstituentsItems0MovementStateSuccess captures enum value "success"
	VolumeConstituentsItems0MovementStateSuccess string = "success"
)

// prop value enum
func (m *VolumeConstituentsItems0Movement) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeConstituentsItems0MovementTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeConstituentsItems0Movement) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("movement"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var volumeConstituentsItems0MovementTypeTieringPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeConstituentsItems0MovementTypeTieringPolicyPropEnum = append(volumeConstituentsItems0MovementTypeTieringPolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// tiering_policy
	// TieringPolicy
	// all
	// END DEBUGGING
	// VolumeConstituentsItems0MovementTieringPolicyAll captures enum value "all"
	VolumeConstituentsItems0MovementTieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// tiering_policy
	// TieringPolicy
	// auto
	// END DEBUGGING
	// VolumeConstituentsItems0MovementTieringPolicyAuto captures enum value "auto"
	VolumeConstituentsItems0MovementTieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// tiering_policy
	// TieringPolicy
	// backup
	// END DEBUGGING
	// VolumeConstituentsItems0MovementTieringPolicyBackup captures enum value "backup"
	VolumeConstituentsItems0MovementTieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// tiering_policy
	// TieringPolicy
	// none
	// END DEBUGGING
	// VolumeConstituentsItems0MovementTieringPolicyNone captures enum value "none"
	VolumeConstituentsItems0MovementTieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// VolumeConstituentsItems0Movement
	// VolumeConstituentsItems0Movement
	// tiering_policy
	// TieringPolicy
	// snapshot_only
	// END DEBUGGING
	// VolumeConstituentsItems0MovementTieringPolicySnapshotOnly captures enum value "snapshot_only"
	VolumeConstituentsItems0MovementTieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *VolumeConstituentsItems0Movement) validateTieringPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeConstituentsItems0MovementTypeTieringPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeConstituentsItems0Movement) validateTieringPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.TieringPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateTieringPolicyEnum("movement"+"."+"tiering_policy", "body", m.TieringPolicy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume constituents items0 movement based on the context it is used
func (m *VolumeConstituentsItems0Movement) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestinationAggregate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0Movement) contextValidateDestinationAggregate(ctx context.Context, formats strfmt.Registry) error {

	if m.DestinationAggregate != nil {
		if err := m.DestinationAggregate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0Movement) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"percent_complete", "body", int64(m.PercentComplete)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0Movement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0Movement) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0Movement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0MovementDestinationAggregate Aggregate
//
// swagger:model VolumeConstituentsItems0MovementDestinationAggregate
type VolumeConstituentsItems0MovementDestinationAggregate struct {

	// links
	Links *VolumeConstituentsItems0MovementDestinationAggregateLinks `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume constituents items0 movement destination aggregate
func (m *VolumeConstituentsItems0MovementDestinationAggregate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0MovementDestinationAggregate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume constituents items0 movement destination aggregate based on the context it is used
func (m *VolumeConstituentsItems0MovementDestinationAggregate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0MovementDestinationAggregate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0MovementDestinationAggregate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0MovementDestinationAggregate) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0MovementDestinationAggregate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0MovementDestinationAggregateLinks volume constituents items0 movement destination aggregate links
//
// swagger:model VolumeConstituentsItems0MovementDestinationAggregateLinks
type VolumeConstituentsItems0MovementDestinationAggregateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume constituents items0 movement destination aggregate links
func (m *VolumeConstituentsItems0MovementDestinationAggregateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0MovementDestinationAggregateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume constituents items0 movement destination aggregate links based on the context it is used
func (m *VolumeConstituentsItems0MovementDestinationAggregateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0MovementDestinationAggregateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0MovementDestinationAggregateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0MovementDestinationAggregateLinks) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0MovementDestinationAggregateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0Space volume constituents items0 space
//
// swagger:model VolumeConstituentsItems0Space
type VolumeConstituentsItems0Space struct {

	// Total size of AFS, excluding snap-reserve, in bytes.
	AfsTotal int64 `json:"afs_total,omitempty"`

	// The available space, in bytes.
	// Read Only: true
	Available int64 `json:"available,omitempty"`

	// The space available, as a percent.
	AvailablePercent int64 `json:"available_percent,omitempty"`

	// The size that is physically used in the block storage of the volume and has a cold temperature. In bytes. This parameter is only supported if the volume is in an aggregate that is either attached to a cloud store or could be attached to a cloud store.
	// Read Only: true
	BlockStorageInactiveUserData int64 `json:"block_storage_inactive_user_data,omitempty"`

	// Space used by capacity tier for this volume in the FabricPool aggregate, in bytes.
	// Read Only: true
	CapacityTierFootprint int64 `json:"capacity_tier_footprint,omitempty"`

	// Data used for this volume in the aggregate, in bytes.
	// Read Only: true
	Footprint int64 `json:"footprint,omitempty"`

	// Space used by the local tier for this volume in the aggregate, in bytes.
	// Read Only: true
	LocalTierFootprint int64 `json:"local_tier_footprint,omitempty"`

	// logical space
	LogicalSpace *VolumeConstituentsItems0SpaceLogicalSpace `json:"logical_space,omitempty"`

	// Space used by the volume metadata in the aggregate, in bytes.
	// Read Only: true
	Metadata int64 `json:"metadata,omitempty"`

	// The amount of space not available for this volume in the aggregate, in bytes.
	// Read Only: true
	OverProvisioned int64 `json:"over_provisioned,omitempty"`

	// Space used by the performance tier for this volume in the FabricPool aggregate, in bytes.
	// Read Only: true
	PerformanceTierFootprint int64 `json:"performance_tier_footprint,omitempty"`

	// Total provisioned size. The default size is equal to the minimum size of 20MB, in bytes.
	Size int64 `json:"size,omitempty"`

	// snapshot
	Snapshot *VolumeConstituentsItems0SpaceSnapshot `json:"snapshot,omitempty"`

	// Data and metadata used for this volume in the aggregate, in bytes.
	// Read Only: true
	TotalFootprint int64 `json:"total_footprint,omitempty"`

	// The virtual space used (includes volume reserves) before storage efficiency, in bytes.
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// The space used by Active Filesystem, in bytes.
	UsedByAfs int64 `json:"used_by_afs,omitempty"`

	// The virtual space used (includes volume reserves) before storage efficiency, as a percent.
	UsedPercent int64 `json:"used_percent,omitempty"`
}

// Validate validates this volume constituents items0 space
func (m *VolumeConstituentsItems0Space) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLogicalSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0Space) validateLogicalSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.LogicalSpace) { // not required
		return nil
	}

	if m.LogicalSpace != nil {
		if err := m.LogicalSpace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "logical_space")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume constituents items0 space based on the context it is used
func (m *VolumeConstituentsItems0Space) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlockStorageInactiveUserData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCapacityTierFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalTierFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverProvisioned(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePerformanceTierFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotalFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateBlockStorageInactiveUserData(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage_inactive_user_data", "body", int64(m.BlockStorageInactiveUserData)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateCapacityTierFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"capacity_tier_footprint", "body", int64(m.CapacityTierFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"footprint", "body", int64(m.Footprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateLocalTierFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"local_tier_footprint", "body", int64(m.LocalTierFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateLogicalSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.LogicalSpace != nil {
		if err := m.LogicalSpace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "logical_space")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"metadata", "body", int64(m.Metadata)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateOverProvisioned(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"over_provisioned", "body", int64(m.OverProvisioned)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidatePerformanceTierFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"performance_tier_footprint", "body", int64(m.PerformanceTierFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {
		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateTotalFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"total_footprint", "body", int64(m.TotalFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0Space) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0Space) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0Space) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0Space
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0SpaceLogicalSpace volume constituents items0 space logical space
//
// swagger:model VolumeConstituentsItems0SpaceLogicalSpace
type VolumeConstituentsItems0SpaceLogicalSpace struct {

	// The amount of space available in this volume with storage efficiency space considered used, in bytes.
	// Read Only: true
	Available int64 `json:"available,omitempty"`

	// Specifies whether space accounting for operations on the volume is done along with storage efficiency.
	Enforcement *bool `json:"enforcement,omitempty"`

	// Specifies whether space reporting on the volume is done along with storage efficiency.
	Reporting *bool `json:"reporting,omitempty"`

	// The virtual space used by AFS alone (includes volume reserves) and along with storage efficiency, in bytes.
	// Read Only: true
	UsedByAfs int64 `json:"used_by_afs,omitempty"`
}

// Validate validates this volume constituents items0 space logical space
func (m *VolumeConstituentsItems0SpaceLogicalSpace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume constituents items0 space logical space based on the context it is used
func (m *VolumeConstituentsItems0SpaceLogicalSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedByAfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0SpaceLogicalSpace) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_space"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeConstituentsItems0SpaceLogicalSpace) contextValidateUsedByAfs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_space"+"."+"used_by_afs", "body", int64(m.UsedByAfs)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0SpaceLogicalSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0SpaceLogicalSpace) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0SpaceLogicalSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeConstituentsItems0SpaceSnapshot volume constituents items0 space snapshot
//
// swagger:model VolumeConstituentsItems0SpaceSnapshot
type VolumeConstituentsItems0SpaceSnapshot struct {

	// Specifies whether Snapshot copy autodelete is currently enabled on this volume.
	AutodeleteEnabled *bool `json:"autodelete_enabled,omitempty"`

	// The space that has been set aside as a reserve for Snapshot copy usage, in percent.
	ReservePercent *int64 `json:"reserve_percent,omitempty"`

	// The total space used by Snapshot copies in the volume, in bytes.
	// Read Only: true
	Used int64 `json:"used,omitempty"`
}

// Validate validates this volume constituents items0 space snapshot
func (m *VolumeConstituentsItems0SpaceSnapshot) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume constituents items0 space snapshot based on the context it is used
func (m *VolumeConstituentsItems0SpaceSnapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeConstituentsItems0SpaceSnapshot) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeConstituentsItems0SpaceSnapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeConstituentsItems0SpaceSnapshot) UnmarshalBinary(b []byte) error {
	var res VolumeConstituentsItems0SpaceSnapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeEfficiencyType volume efficiency type
//
// swagger:model VolumeEfficiencyType
type VolumeEfficiencyType struct {

	// Block size to use by compression. Valid for POST.
	// Enum: [8k auto]
	ApplicationIoSize string `json:"application_io_size,omitempty"`

	// The system can be enabled/disabled compaction.<br>inline &dash; Data will be compacted first and written to the volume.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are compaction enabled and some are disabled.
	// Enum: [inline none mixed]
	Compaction string `json:"compaction,omitempty"`

	// The system can be enabled/disabled compression.<br>inline &dash; Data will be compressed first and written to the volume.<br>background &dash; Data will be written to the volume and compressed later.<br>both &dash; Inline compression compresses the data and write to the volume, background compression compresses only the blocks on which inline compression is not run.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are compression enabled and some are disabled.
	// Enum: [inline background both none mixed]
	Compression string `json:"compression,omitempty"`

	// The system can be enabled/disabled cross volume dedupe. it can be enabled only when dedupe is enabled.<br>inline &dash; Data will be cross volume deduped first and written to the volume.<br>background &dash; Data will be written to the volume and cross volume deduped later.<br>both &dash; Inline cross volume dedupe dedupes the data and write to the volume, background cross volume dedupe dedupes only the blocks on which inline dedupe is not run.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are cross volume dedupe enabled and some are disabled.
	// Enum: [inline background both none mixed]
	CrossVolumeDedupe string `json:"cross_volume_dedupe,omitempty"`

	// The system can be enabled/disabled dedupe.<br>inline &dash; Data will be deduped first and written to the volume.<br>background &dash; Data will be written to the volume and deduped later.<br>both &dash; Inline dedupe dedupes the data and write to the volume, background dedupe dedupes only the blocks on which inline dedupe is not run.<br>none &dash; None<br>mixed &dash; Read only field for FlexGroups, where some of the constituent volumes are dedupe enabled and some are disabled.
	// Enum: [inline background both none mixed]
	Dedupe string `json:"dedupe,omitempty"`

	// Last sis operation begin timestamp.
	// Read Only: true
	LastOpBegin string `json:"last_op_begin,omitempty"`

	// Last sis operation end timestamp.
	// Read Only: true
	LastOpEnd string `json:"last_op_end,omitempty"`

	// Last sis operation error text.
	// Read Only: true
	LastOpErr string `json:"last_op_err,omitempty"`

	// Last sis operation size.
	// Read Only: true
	LastOpSize int64 `json:"last_op_size,omitempty"`

	// Last sis operation state.
	// Read Only: true
	LastOpState string `json:"last_op_state,omitempty"`

	// Sis status of the volume.
	// Read Only: true
	// Enum: [idle initializing active undoing pending downgrading disabled]
	OpState string `json:"op_state,omitempty"`

	// Absolute volume path of the volume.
	// Read Only: true
	Path string `json:"path,omitempty"`

	// policy
	Policy *VolumeEfficiencyTypePolicyType `json:"policy,omitempty"`

	// Sis progress of the volume.
	// Read Only: true
	Progress string `json:"progress,omitempty"`

	// Schedule associated with volume.
	// Read Only: true
	Schedule string `json:"schedule,omitempty"`

	// Storage efficiency state of the volume. Currently, this field supports POST/PATCH only for RW (Read-Write) volumes on FSx for ONTAP.<br>disabled &dash; All storage efficiency features are disabled.<br>mixed &dash; Read-only field for FlexGroup volumes, storage efficiency is enabled on certain constituents and disabled on others.<br>On FSx for ONTAP &dash; <br> &emsp; enabled &dash; All supported storage efficiency features for the volume are enabled.<br> &emsp; custom &dash; Read-only field currently only supported for the FSx for ONTAP, user-defined storage efficiency features are enabled.<br>For other platforms &dash; <br> &emsp; enabled &dash; At least one storage efficiency feature for the volume is enabled.
	// Enum: [disabled enabled mixed custom]
	State string `json:"state,omitempty"`

	// Storage efficiency mode used by volume. This parameter is supported only on AFF platform.
	// Enum: [default efficient]
	StorageEfficiencyMode string `json:"storage_efficiency_mode,omitempty"`

	// Sis Type of the volume.
	// Read Only: true
	// Enum: [regular snapvault]
	Type string `json:"type,omitempty"`
}

// Validate validates this volume efficiency type
func (m *VolumeEfficiencyType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplicationIoSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompaction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrossVolumeDedupe(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDedupe(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageEfficiencyMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeEfficiencyTypeTypeApplicationIoSizePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["8k","auto"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeApplicationIoSizePropEnum = append(volumeEfficiencyTypeTypeApplicationIoSizePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// application_io_size
	// ApplicationIoSize
	// 8k
	// END DEBUGGING
	// VolumeEfficiencyTypeApplicationIoSizeNr8k captures enum value "8k"
	VolumeEfficiencyTypeApplicationIoSizeNr8k string = "8k"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// application_io_size
	// ApplicationIoSize
	// auto
	// END DEBUGGING
	// VolumeEfficiencyTypeApplicationIoSizeAuto captures enum value "auto"
	VolumeEfficiencyTypeApplicationIoSizeAuto string = "auto"
)

// prop value enum
func (m *VolumeEfficiencyType) validateApplicationIoSizeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeApplicationIoSizePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateApplicationIoSize(formats strfmt.Registry) error {
	if swag.IsZero(m.ApplicationIoSize) { // not required
		return nil
	}

	// value enum
	if err := m.validateApplicationIoSizeEnum("efficiency"+"."+"application_io_size", "body", m.ApplicationIoSize); err != nil {
		return err
	}

	return nil
}

var volumeEfficiencyTypeTypeCompactionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["inline","none","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeCompactionPropEnum = append(volumeEfficiencyTypeTypeCompactionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compaction
	// Compaction
	// inline
	// END DEBUGGING
	// VolumeEfficiencyTypeCompactionInline captures enum value "inline"
	VolumeEfficiencyTypeCompactionInline string = "inline"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compaction
	// Compaction
	// none
	// END DEBUGGING
	// VolumeEfficiencyTypeCompactionNone captures enum value "none"
	VolumeEfficiencyTypeCompactionNone string = "none"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compaction
	// Compaction
	// mixed
	// END DEBUGGING
	// VolumeEfficiencyTypeCompactionMixed captures enum value "mixed"
	VolumeEfficiencyTypeCompactionMixed string = "mixed"
)

// prop value enum
func (m *VolumeEfficiencyType) validateCompactionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeCompactionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateCompaction(formats strfmt.Registry) error {
	if swag.IsZero(m.Compaction) { // not required
		return nil
	}

	// value enum
	if err := m.validateCompactionEnum("efficiency"+"."+"compaction", "body", m.Compaction); err != nil {
		return err
	}

	return nil
}

var volumeEfficiencyTypeTypeCompressionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["inline","background","both","none","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeCompressionPropEnum = append(volumeEfficiencyTypeTypeCompressionPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compression
	// Compression
	// inline
	// END DEBUGGING
	// VolumeEfficiencyTypeCompressionInline captures enum value "inline"
	VolumeEfficiencyTypeCompressionInline string = "inline"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compression
	// Compression
	// background
	// END DEBUGGING
	// VolumeEfficiencyTypeCompressionBackground captures enum value "background"
	VolumeEfficiencyTypeCompressionBackground string = "background"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compression
	// Compression
	// both
	// END DEBUGGING
	// VolumeEfficiencyTypeCompressionBoth captures enum value "both"
	VolumeEfficiencyTypeCompressionBoth string = "both"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compression
	// Compression
	// none
	// END DEBUGGING
	// VolumeEfficiencyTypeCompressionNone captures enum value "none"
	VolumeEfficiencyTypeCompressionNone string = "none"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// compression
	// Compression
	// mixed
	// END DEBUGGING
	// VolumeEfficiencyTypeCompressionMixed captures enum value "mixed"
	VolumeEfficiencyTypeCompressionMixed string = "mixed"
)

// prop value enum
func (m *VolumeEfficiencyType) validateCompressionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeCompressionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateCompression(formats strfmt.Registry) error {
	if swag.IsZero(m.Compression) { // not required
		return nil
	}

	// value enum
	if err := m.validateCompressionEnum("efficiency"+"."+"compression", "body", m.Compression); err != nil {
		return err
	}

	return nil
}

var volumeEfficiencyTypeTypeCrossVolumeDedupePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["inline","background","both","none","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeCrossVolumeDedupePropEnum = append(volumeEfficiencyTypeTypeCrossVolumeDedupePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// cross_volume_dedupe
	// CrossVolumeDedupe
	// inline
	// END DEBUGGING
	// VolumeEfficiencyTypeCrossVolumeDedupeInline captures enum value "inline"
	VolumeEfficiencyTypeCrossVolumeDedupeInline string = "inline"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// cross_volume_dedupe
	// CrossVolumeDedupe
	// background
	// END DEBUGGING
	// VolumeEfficiencyTypeCrossVolumeDedupeBackground captures enum value "background"
	VolumeEfficiencyTypeCrossVolumeDedupeBackground string = "background"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// cross_volume_dedupe
	// CrossVolumeDedupe
	// both
	// END DEBUGGING
	// VolumeEfficiencyTypeCrossVolumeDedupeBoth captures enum value "both"
	VolumeEfficiencyTypeCrossVolumeDedupeBoth string = "both"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// cross_volume_dedupe
	// CrossVolumeDedupe
	// none
	// END DEBUGGING
	// VolumeEfficiencyTypeCrossVolumeDedupeNone captures enum value "none"
	VolumeEfficiencyTypeCrossVolumeDedupeNone string = "none"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// cross_volume_dedupe
	// CrossVolumeDedupe
	// mixed
	// END DEBUGGING
	// VolumeEfficiencyTypeCrossVolumeDedupeMixed captures enum value "mixed"
	VolumeEfficiencyTypeCrossVolumeDedupeMixed string = "mixed"
)

// prop value enum
func (m *VolumeEfficiencyType) validateCrossVolumeDedupeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeCrossVolumeDedupePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateCrossVolumeDedupe(formats strfmt.Registry) error {
	if swag.IsZero(m.CrossVolumeDedupe) { // not required
		return nil
	}

	// value enum
	if err := m.validateCrossVolumeDedupeEnum("efficiency"+"."+"cross_volume_dedupe", "body", m.CrossVolumeDedupe); err != nil {
		return err
	}

	return nil
}

var volumeEfficiencyTypeTypeDedupePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["inline","background","both","none","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeDedupePropEnum = append(volumeEfficiencyTypeTypeDedupePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// dedupe
	// Dedupe
	// inline
	// END DEBUGGING
	// VolumeEfficiencyTypeDedupeInline captures enum value "inline"
	VolumeEfficiencyTypeDedupeInline string = "inline"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// dedupe
	// Dedupe
	// background
	// END DEBUGGING
	// VolumeEfficiencyTypeDedupeBackground captures enum value "background"
	VolumeEfficiencyTypeDedupeBackground string = "background"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// dedupe
	// Dedupe
	// both
	// END DEBUGGING
	// VolumeEfficiencyTypeDedupeBoth captures enum value "both"
	VolumeEfficiencyTypeDedupeBoth string = "both"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// dedupe
	// Dedupe
	// none
	// END DEBUGGING
	// VolumeEfficiencyTypeDedupeNone captures enum value "none"
	VolumeEfficiencyTypeDedupeNone string = "none"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// dedupe
	// Dedupe
	// mixed
	// END DEBUGGING
	// VolumeEfficiencyTypeDedupeMixed captures enum value "mixed"
	VolumeEfficiencyTypeDedupeMixed string = "mixed"
)

// prop value enum
func (m *VolumeEfficiencyType) validateDedupeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeDedupePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateDedupe(formats strfmt.Registry) error {
	if swag.IsZero(m.Dedupe) { // not required
		return nil
	}

	// value enum
	if err := m.validateDedupeEnum("efficiency"+"."+"dedupe", "body", m.Dedupe); err != nil {
		return err
	}

	return nil
}

var volumeEfficiencyTypeTypeOpStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["idle","initializing","active","undoing","pending","downgrading","disabled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeOpStatePropEnum = append(volumeEfficiencyTypeTypeOpStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// op_state
	// OpState
	// idle
	// END DEBUGGING
	// VolumeEfficiencyTypeOpStateIdle captures enum value "idle"
	VolumeEfficiencyTypeOpStateIdle string = "idle"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// op_state
	// OpState
	// initializing
	// END DEBUGGING
	// VolumeEfficiencyTypeOpStateInitializing captures enum value "initializing"
	VolumeEfficiencyTypeOpStateInitializing string = "initializing"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// op_state
	// OpState
	// active
	// END DEBUGGING
	// VolumeEfficiencyTypeOpStateActive captures enum value "active"
	VolumeEfficiencyTypeOpStateActive string = "active"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// op_state
	// OpState
	// undoing
	// END DEBUGGING
	// VolumeEfficiencyTypeOpStateUndoing captures enum value "undoing"
	VolumeEfficiencyTypeOpStateUndoing string = "undoing"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// op_state
	// OpState
	// pending
	// END DEBUGGING
	// VolumeEfficiencyTypeOpStatePending captures enum value "pending"
	VolumeEfficiencyTypeOpStatePending string = "pending"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// op_state
	// OpState
	// downgrading
	// END DEBUGGING
	// VolumeEfficiencyTypeOpStateDowngrading captures enum value "downgrading"
	VolumeEfficiencyTypeOpStateDowngrading string = "downgrading"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// op_state
	// OpState
	// disabled
	// END DEBUGGING
	// VolumeEfficiencyTypeOpStateDisabled captures enum value "disabled"
	VolumeEfficiencyTypeOpStateDisabled string = "disabled"
)

// prop value enum
func (m *VolumeEfficiencyType) validateOpStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeOpStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateOpState(formats strfmt.Registry) error {
	if swag.IsZero(m.OpState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOpStateEnum("efficiency"+"."+"op_state", "body", m.OpState); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("efficiency" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

var volumeEfficiencyTypeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["disabled","enabled","mixed","custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeStatePropEnum = append(volumeEfficiencyTypeTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// state
	// State
	// disabled
	// END DEBUGGING
	// VolumeEfficiencyTypeStateDisabled captures enum value "disabled"
	VolumeEfficiencyTypeStateDisabled string = "disabled"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// state
	// State
	// enabled
	// END DEBUGGING
	// VolumeEfficiencyTypeStateEnabled captures enum value "enabled"
	VolumeEfficiencyTypeStateEnabled string = "enabled"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// state
	// State
	// mixed
	// END DEBUGGING
	// VolumeEfficiencyTypeStateMixed captures enum value "mixed"
	VolumeEfficiencyTypeStateMixed string = "mixed"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// state
	// State
	// custom
	// END DEBUGGING
	// VolumeEfficiencyTypeStateCustom captures enum value "custom"
	VolumeEfficiencyTypeStateCustom string = "custom"
)

// prop value enum
func (m *VolumeEfficiencyType) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("efficiency"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var volumeEfficiencyTypeTypeStorageEfficiencyModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["default","efficient"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeStorageEfficiencyModePropEnum = append(volumeEfficiencyTypeTypeStorageEfficiencyModePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// storage_efficiency_mode
	// StorageEfficiencyMode
	// default
	// END DEBUGGING
	// VolumeEfficiencyTypeStorageEfficiencyModeDefault captures enum value "default"
	VolumeEfficiencyTypeStorageEfficiencyModeDefault string = "default"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// storage_efficiency_mode
	// StorageEfficiencyMode
	// efficient
	// END DEBUGGING
	// VolumeEfficiencyTypeStorageEfficiencyModeEfficient captures enum value "efficient"
	VolumeEfficiencyTypeStorageEfficiencyModeEfficient string = "efficient"
)

// prop value enum
func (m *VolumeEfficiencyType) validateStorageEfficiencyModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeStorageEfficiencyModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateStorageEfficiencyMode(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageEfficiencyMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateStorageEfficiencyModeEnum("efficiency"+"."+"storage_efficiency_mode", "body", m.StorageEfficiencyMode); err != nil {
		return err
	}

	return nil
}

var volumeEfficiencyTypeTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["regular","snapvault"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEfficiencyTypeTypeTypePropEnum = append(volumeEfficiencyTypeTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// type
	// Type
	// regular
	// END DEBUGGING
	// VolumeEfficiencyTypeTypeRegular captures enum value "regular"
	VolumeEfficiencyTypeTypeRegular string = "regular"

	// BEGIN DEBUGGING
	// VolumeEfficiencyType
	// VolumeEfficiencyType
	// type
	// Type
	// snapvault
	// END DEBUGGING
	// VolumeEfficiencyTypeTypeSnapvault captures enum value "snapvault"
	VolumeEfficiencyTypeTypeSnapvault string = "snapvault"
)

// prop value enum
func (m *VolumeEfficiencyType) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEfficiencyTypeTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEfficiencyType) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("efficiency"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume efficiency type based on the context it is used
func (m *VolumeEfficiencyType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastOpBegin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastOpEnd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastOpErr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastOpSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastOpState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePath(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchedule(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeEfficiencyType) contextValidateLastOpBegin(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"last_op_begin", "body", string(m.LastOpBegin)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateLastOpEnd(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"last_op_end", "body", string(m.LastOpEnd)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateLastOpErr(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"last_op_err", "body", string(m.LastOpErr)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateLastOpSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"last_op_size", "body", int64(m.LastOpSize)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateLastOpState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"last_op_state", "body", string(m.LastOpState)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateOpState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"op_state", "body", string(m.OpState)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidatePath(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"path", "body", string(m.Path)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("efficiency" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"progress", "body", string(m.Progress)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateSchedule(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"schedule", "body", string(m.Schedule)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEfficiencyType) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "efficiency"+"."+"type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeEfficiencyType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeEfficiencyType) UnmarshalBinary(b []byte) error {
	var res VolumeEfficiencyType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeEfficiencyTypePolicyType volume efficiency type policy type
//
// swagger:model VolumeEfficiencyTypePolicyType
type VolumeEfficiencyTypePolicyType struct {

	// Specifies the name of the efficiency policy. Valid for PATCH.
	Name string `json:"name,omitempty"`
}

// Validate validates this volume efficiency type policy type
func (m *VolumeEfficiencyTypePolicyType) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this volume efficiency type policy type based on context it is used
func (m *VolumeEfficiencyTypePolicyType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeEfficiencyTypePolicyType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeEfficiencyTypePolicyType) UnmarshalBinary(b []byte) error {
	var res VolumeEfficiencyTypePolicyType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeEncryption volume encryption
//
// swagger:model VolumeEncryption
type VolumeEncryption struct {

	// Creates an encrypted or an unencrypted volume. For POST, when set to 'true', a new key is generated and used to encrypt the given volume. In that case, the underlying SVM must be configured with the key manager. When set to 'false', the volume created will be unencrypted. For PATCH, when set to 'true', it encrypts an unencrypted volume. Specifying the parameter as 'false' in a PATCH operation for an encrypted volume is only supported when moving the volume to another aggregate.
	Enabled bool `json:"enabled,omitempty"`

	// The key ID used for creating encrypted volume. A new key-id is generated for creating an encrypted volume. This key-id is associated with the generated key.
	// Read Only: true
	KeyID string `json:"key_id,omitempty"`

	// Specifies an additional key manager attribute that is an identifier-value pair, separated by '='. For example, CRN=unique-value. This parameter is required when using the POST method and an IBM Key Lore key manager is configured on the SVM.
	// Example: CRN=v1:bluemix:public:containers-kubernetes:us-south:a/asdfghjkl1234:asdfghjkl1234:worker:kubernetes-asdfghjkl-worker1
	KeyManagerAttribute string `json:"key_manager_attribute,omitempty"`

	// If set to 'true', re-encrypts the volume with a new key. Valid in PATCH.
	Rekey bool `json:"rekey,omitempty"`

	// Volume encryption state.<br>encrypted &dash; The volume is completely encrypted.<br>encrypting &dash; Encryption operation is in progress.<br>partial &dash; Some constituents are encrypted and some are not. Applicable only for FlexGroup volume.<br>rekeying. Encryption of volume with a new key is in progress.<br>unencrypted &dash; The volume is a plain-text one.
	// Read Only: true
	// Enum: [encrypted encrypting partial rekeying unencrypted]
	State string `json:"state,omitempty"`

	// status
	Status *VolumeEncryptionStatus `json:"status,omitempty"`

	// Volume encryption type.<br>none &dash; The volume is a plain-text one.<br>volume &dash; The volume is encrypted with NVE (NetApp Volume Encryption).<br>aggregate &dash; The volume is encrypted with NAE (NetApp Aggregate Encryption).
	// Read Only: true
	// Enum: [none volume aggregate]
	Type string `json:"type,omitempty"`
}

// Validate validates this volume encryption
func (m *VolumeEncryption) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeEncryptionTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["encrypted","encrypting","partial","rekeying","unencrypted"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEncryptionTypeStatePropEnum = append(volumeEncryptionTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// state
	// State
	// encrypted
	// END DEBUGGING
	// VolumeEncryptionStateEncrypted captures enum value "encrypted"
	VolumeEncryptionStateEncrypted string = "encrypted"

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// state
	// State
	// encrypting
	// END DEBUGGING
	// VolumeEncryptionStateEncrypting captures enum value "encrypting"
	VolumeEncryptionStateEncrypting string = "encrypting"

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// state
	// State
	// partial
	// END DEBUGGING
	// VolumeEncryptionStatePartial captures enum value "partial"
	VolumeEncryptionStatePartial string = "partial"

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// state
	// State
	// rekeying
	// END DEBUGGING
	// VolumeEncryptionStateRekeying captures enum value "rekeying"
	VolumeEncryptionStateRekeying string = "rekeying"

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// state
	// State
	// unencrypted
	// END DEBUGGING
	// VolumeEncryptionStateUnencrypted captures enum value "unencrypted"
	VolumeEncryptionStateUnencrypted string = "unencrypted"
)

// prop value enum
func (m *VolumeEncryption) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEncryptionTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEncryption) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("encryption"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEncryption) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption" + "." + "status")
			}
			return err
		}
	}

	return nil
}

var volumeEncryptionTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","volume","aggregate"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeEncryptionTypeTypePropEnum = append(volumeEncryptionTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// type
	// Type
	// none
	// END DEBUGGING
	// VolumeEncryptionTypeNone captures enum value "none"
	VolumeEncryptionTypeNone string = "none"

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// type
	// Type
	// volume
	// END DEBUGGING
	// VolumeEncryptionTypeVolume captures enum value "volume"
	VolumeEncryptionTypeVolume string = "volume"

	// BEGIN DEBUGGING
	// VolumeEncryption
	// VolumeEncryption
	// type
	// Type
	// aggregate
	// END DEBUGGING
	// VolumeEncryptionTypeAggregate captures enum value "aggregate"
	VolumeEncryptionTypeAggregate string = "aggregate"
)

// prop value enum
func (m *VolumeEncryption) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeEncryptionTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeEncryption) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("encryption"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume encryption based on the context it is used
func (m *VolumeEncryption) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateKeyID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeEncryption) contextValidateKeyID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "encryption"+"."+"key_id", "body", string(m.KeyID)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEncryption) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "encryption"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEncryption) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption" + "." + "status")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeEncryption) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "encryption"+"."+"type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeEncryption) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeEncryption) UnmarshalBinary(b []byte) error {
	var res VolumeEncryption
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeEncryptionStatus volume encryption status
//
// swagger:model VolumeEncryptionStatus
type VolumeEncryptionStatus struct {

	// Encryption progress message code.
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Encryption progress message.
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this volume encryption status
func (m *VolumeEncryptionStatus) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume encryption status based on the context it is used
func (m *VolumeEncryptionStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeEncryptionStatus) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "encryption"+"."+"status"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeEncryptionStatus) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "encryption"+"."+"status"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeEncryptionStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeEncryptionStatus) UnmarshalBinary(b []byte) error {
	var res VolumeEncryptionStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeErrorState volume error state
//
// swagger:model VolumeErrorState
type VolumeErrorState struct {

	// Indicates whether the volume has any corrupt data blocks. If the damaged data block is accessed, an IO error, such as EIO for NFS or STATUS_FILE_CORRUPT for CIFS, is returned.
	// Read Only: true
	HasBadBlocks *bool `json:"has_bad_blocks,omitempty"`

	// Indicates whether the file system has any inconsistencies.<br>true &dash; File system is inconsistent.<br>false &dash; File system in not inconsistent.
	// Read Only: true
	IsInconsistent *bool `json:"is_inconsistent,omitempty"`
}

// Validate validates this volume error state
func (m *VolumeErrorState) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume error state based on the context it is used
func (m *VolumeErrorState) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHasBadBlocks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsInconsistent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeErrorState) contextValidateHasBadBlocks(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "error_state"+"."+"has_bad_blocks", "body", m.HasBadBlocks); err != nil {
		return err
	}

	return nil
}

func (m *VolumeErrorState) contextValidateIsInconsistent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "error_state"+"."+"is_inconsistent", "body", m.IsInconsistent); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeErrorState) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeErrorState) UnmarshalBinary(b []byte) error {
	var res VolumeErrorState
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeFiles volume files
//
// swagger:model VolumeFiles
type VolumeFiles struct {

	// The maximum number of files (inodes) for user-visible data allowed on the volume. This value can be increased or decreased. Increasing the maximum number of files does not immediately cause additional disk space to be used to track files. Instead, as more files are created on the volume, the system dynamically increases the number of disk blocks that are used to track files. The space assigned to track files is never freed, and this value cannot be decreased below the current number of files that can be tracked within the assigned space for the volume. Valid in PATCH.
	Maximum int64 `json:"maximum,omitempty"`

	// Number of files (inodes) used for user-visible data permitted on the volume. This field is valid only when the volume is online.
	// Read Only: true
	Used int64 `json:"used,omitempty"`
}

// Validate validates this volume files
func (m *VolumeFiles) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume files based on the context it is used
func (m *VolumeFiles) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeFiles) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "files"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeFiles) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeFiles) UnmarshalBinary(b []byte) error {
	var res VolumeFiles
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeFlashPool volume flash pool
//
// swagger:model VolumeFlashPool
type VolumeFlashPool struct {

	// If this parameter is specified, the command displays information only about the volume or volumes with the specified Flash Pool caching attributes.
	// Read Only: true
	// Enum: [read read_write none]
	CacheEligibility string `json:"cache_eligibility,omitempty"`

	// If this parameter is specified, the command displays the volumes that match the specified cache retention priority policy. A cache retention priority defines how long the blocks of a volume will be cached in the Flash Pool once they become cold.
	// Read Only: true
	// Enum: [normal low high]
	CacheRetentionPriority string `json:"cache_retention_priority,omitempty"`

	// This optionally specifies the caching policy to apply to the volume. A caching policy defines how the system caches a volume's data in Flash Cache modules. If a caching policy is not assigned to a volume, the system uses the caching policy that is assigned to the containing SVM. If a caching policy is not assigned to the containing SVM, the system uses the default cluster-wide policy.
	// Read Only: true
	// Enum: [none auto meta random_read random_read_write all_read all_read_random_write all noread_random_write meta_random_write random_read_write_random_write all_read_random_write_random_write all_random_write]
	CachingPolicy string `json:"caching_policy,omitempty"`
}

// Validate validates this volume flash pool
func (m *VolumeFlashPool) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCacheEligibility(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheRetentionPriority(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCachingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeFlashPoolTypeCacheEligibilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["read","read_write","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeFlashPoolTypeCacheEligibilityPropEnum = append(volumeFlashPoolTypeCacheEligibilityPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// cache_eligibility
	// CacheEligibility
	// read
	// END DEBUGGING
	// VolumeFlashPoolCacheEligibilityRead captures enum value "read"
	VolumeFlashPoolCacheEligibilityRead string = "read"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// cache_eligibility
	// CacheEligibility
	// read_write
	// END DEBUGGING
	// VolumeFlashPoolCacheEligibilityReadWrite captures enum value "read_write"
	VolumeFlashPoolCacheEligibilityReadWrite string = "read_write"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// cache_eligibility
	// CacheEligibility
	// none
	// END DEBUGGING
	// VolumeFlashPoolCacheEligibilityNone captures enum value "none"
	VolumeFlashPoolCacheEligibilityNone string = "none"
)

// prop value enum
func (m *VolumeFlashPool) validateCacheEligibilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeFlashPoolTypeCacheEligibilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeFlashPool) validateCacheEligibility(formats strfmt.Registry) error {
	if swag.IsZero(m.CacheEligibility) { // not required
		return nil
	}

	// value enum
	if err := m.validateCacheEligibilityEnum("flash_pool"+"."+"cache_eligibility", "body", m.CacheEligibility); err != nil {
		return err
	}

	return nil
}

var volumeFlashPoolTypeCacheRetentionPriorityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["normal","low","high"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeFlashPoolTypeCacheRetentionPriorityPropEnum = append(volumeFlashPoolTypeCacheRetentionPriorityPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// cache_retention_priority
	// CacheRetentionPriority
	// normal
	// END DEBUGGING
	// VolumeFlashPoolCacheRetentionPriorityNormal captures enum value "normal"
	VolumeFlashPoolCacheRetentionPriorityNormal string = "normal"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// cache_retention_priority
	// CacheRetentionPriority
	// low
	// END DEBUGGING
	// VolumeFlashPoolCacheRetentionPriorityLow captures enum value "low"
	VolumeFlashPoolCacheRetentionPriorityLow string = "low"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// cache_retention_priority
	// CacheRetentionPriority
	// high
	// END DEBUGGING
	// VolumeFlashPoolCacheRetentionPriorityHigh captures enum value "high"
	VolumeFlashPoolCacheRetentionPriorityHigh string = "high"
)

// prop value enum
func (m *VolumeFlashPool) validateCacheRetentionPriorityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeFlashPoolTypeCacheRetentionPriorityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeFlashPool) validateCacheRetentionPriority(formats strfmt.Registry) error {
	if swag.IsZero(m.CacheRetentionPriority) { // not required
		return nil
	}

	// value enum
	if err := m.validateCacheRetentionPriorityEnum("flash_pool"+"."+"cache_retention_priority", "body", m.CacheRetentionPriority); err != nil {
		return err
	}

	return nil
}

var volumeFlashPoolTypeCachingPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","auto","meta","random_read","random_read_write","all_read","all_read_random_write","all","noread_random_write","meta_random_write","random_read_write_random_write","all_read_random_write_random_write","all_random_write"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeFlashPoolTypeCachingPolicyPropEnum = append(volumeFlashPoolTypeCachingPolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// none
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyNone captures enum value "none"
	VolumeFlashPoolCachingPolicyNone string = "none"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// auto
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyAuto captures enum value "auto"
	VolumeFlashPoolCachingPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// meta
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyMeta captures enum value "meta"
	VolumeFlashPoolCachingPolicyMeta string = "meta"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// random_read
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyRandomRead captures enum value "random_read"
	VolumeFlashPoolCachingPolicyRandomRead string = "random_read"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// random_read_write
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyRandomReadWrite captures enum value "random_read_write"
	VolumeFlashPoolCachingPolicyRandomReadWrite string = "random_read_write"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// all_read
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyAllRead captures enum value "all_read"
	VolumeFlashPoolCachingPolicyAllRead string = "all_read"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// all_read_random_write
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyAllReadRandomWrite captures enum value "all_read_random_write"
	VolumeFlashPoolCachingPolicyAllReadRandomWrite string = "all_read_random_write"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// all
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyAll captures enum value "all"
	VolumeFlashPoolCachingPolicyAll string = "all"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// noread_random_write
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyNoreadRandomWrite captures enum value "noread_random_write"
	VolumeFlashPoolCachingPolicyNoreadRandomWrite string = "noread_random_write"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// meta_random_write
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyMetaRandomWrite captures enum value "meta_random_write"
	VolumeFlashPoolCachingPolicyMetaRandomWrite string = "meta_random_write"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// random_read_write_random_write
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyRandomReadWriteRandomWrite captures enum value "random_read_write_random_write"
	VolumeFlashPoolCachingPolicyRandomReadWriteRandomWrite string = "random_read_write_random_write"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// all_read_random_write_random_write
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyAllReadRandomWriteRandomWrite captures enum value "all_read_random_write_random_write"
	VolumeFlashPoolCachingPolicyAllReadRandomWriteRandomWrite string = "all_read_random_write_random_write"

	// BEGIN DEBUGGING
	// VolumeFlashPool
	// VolumeFlashPool
	// caching_policy
	// CachingPolicy
	// all_random_write
	// END DEBUGGING
	// VolumeFlashPoolCachingPolicyAllRandomWrite captures enum value "all_random_write"
	VolumeFlashPoolCachingPolicyAllRandomWrite string = "all_random_write"
)

// prop value enum
func (m *VolumeFlashPool) validateCachingPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeFlashPoolTypeCachingPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeFlashPool) validateCachingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.CachingPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateCachingPolicyEnum("flash_pool"+"."+"caching_policy", "body", m.CachingPolicy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume flash pool based on the context it is used
func (m *VolumeFlashPool) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCacheEligibility(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCacheRetentionPriority(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCachingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeFlashPool) contextValidateCacheEligibility(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flash_pool"+"."+"cache_eligibility", "body", string(m.CacheEligibility)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeFlashPool) contextValidateCacheRetentionPriority(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flash_pool"+"."+"cache_retention_priority", "body", string(m.CacheRetentionPriority)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeFlashPool) contextValidateCachingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flash_pool"+"."+"caching_policy", "body", string(m.CachingPolicy)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeFlashPool) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeFlashPool) UnmarshalBinary(b []byte) error {
	var res VolumeFlashPool
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeFlexgroup volume flexgroup
//
// swagger:model VolumeFlexgroup
type VolumeFlexgroup struct {

	// Name of the FlexGroup volume that the constituent is part of.
	// Example: my_flexgroup
	// Read Only: true
	// Max Length: 203
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// Unique identifier for the FlexGroup volume that the constituent is part of.
	// Example: 75c9cfb0-3eb4-11eb-9fb4-005056bb088a
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume flexgroup
func (m *VolumeFlexgroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeFlexgroup) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("flexgroup"+"."+"name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("flexgroup"+"."+"name", "body", m.Name, 203); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume flexgroup based on the context it is used
func (m *VolumeFlexgroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeFlexgroup) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flexgroup"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeFlexgroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "flexgroup"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeFlexgroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeFlexgroup) UnmarshalBinary(b []byte) error {
	var res VolumeFlexgroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeGuarantee volume guarantee
//
// swagger:model VolumeGuarantee
type VolumeGuarantee struct {

	// Is the space guarantee of this volume honored in the aggregate?
	// Read Only: true
	Honored *bool `json:"honored,omitempty"`

	// The type of space guarantee of this volume in the aggregate.
	// Enum: [volume none]
	Type string `json:"type,omitempty"`
}

// Validate validates this volume guarantee
func (m *VolumeGuarantee) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeGuaranteeTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["volume","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeGuaranteeTypeTypePropEnum = append(volumeGuaranteeTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeGuarantee
	// VolumeGuarantee
	// type
	// Type
	// volume
	// END DEBUGGING
	// VolumeGuaranteeTypeVolume captures enum value "volume"
	VolumeGuaranteeTypeVolume string = "volume"

	// BEGIN DEBUGGING
	// VolumeGuarantee
	// VolumeGuarantee
	// type
	// Type
	// none
	// END DEBUGGING
	// VolumeGuaranteeTypeNone captures enum value "none"
	VolumeGuaranteeTypeNone string = "none"
)

// prop value enum
func (m *VolumeGuarantee) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeGuaranteeTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeGuarantee) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("guarantee"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume guarantee based on the context it is used
func (m *VolumeGuarantee) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHonored(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeGuarantee) contextValidateHonored(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "guarantee"+"."+"honored", "body", m.Honored); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeGuarantee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeGuarantee) UnmarshalBinary(b []byte) error {
	var res VolumeGuarantee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeLinks volume links
//
// swagger:model VolumeLinks
type VolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume links
func (m *VolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume links based on the context it is used
func (m *VolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeLinks) UnmarshalBinary(b []byte) error {
	var res VolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetric Performance numbers, such as IOPS, latency and throughput.
//
// swagger:model VolumeMetric
type VolumeMetric struct {

	// links
	Links *VolumeMetricLinks `json:"_links,omitempty"`

	// cloud
	Cloud *VolumeMetricCloud `json:"cloud,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// flexcache
	Flexcache *VolumeMetricFlexcache `json:"flexcache,omitempty"`

	// iops
	Iops *VolumeMetricIops `json:"iops,omitempty"`

	// latency
	Latency *VolumeMetricLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *VolumeMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume metric
func (m *VolumeMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloud(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexcache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) validateCloud(formats strfmt.Registry) error {
	if swag.IsZero(m.Cloud) { // not required
		return nil
	}

	if m.Cloud != nil {
		if err := m.Cloud.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "cloud")
			}
			return err
		}
	}

	return nil
}

var volumeMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricTypeDurationPropEnum = append(volumeMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// VolumeMetricDurationPT15S captures enum value "PT15S"
	VolumeMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// VolumeMetricDurationPT4M captures enum value "PT4M"
	VolumeMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// VolumeMetricDurationPT30M captures enum value "PT30M"
	VolumeMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// VolumeMetricDurationPT2H captures enum value "PT2H"
	VolumeMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// VolumeMetricDurationP1D captures enum value "P1D"
	VolumeMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// VolumeMetricDurationPT5M captures enum value "PT5M"
	VolumeMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *VolumeMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetric) validateFlexcache(formats strfmt.Registry) error {
	if swag.IsZero(m.Flexcache) { // not required
		return nil
	}

	if m.Flexcache != nil {
		if err := m.Flexcache.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var volumeMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricTypeStatusPropEnum = append(volumeMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeMetricStatusOk captures enum value "ok"
	VolumeMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeMetricStatusError captures enum value "error"
	VolumeMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeMetricStatusPartialNoData captures enum value "partial_no_data"
	VolumeMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeMetricStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeMetricStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeMetricStatusPartialOtherError captures enum value "partial_other_error"
	VolumeMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeMetricStatusNegativeDelta captures enum value "negative_delta"
	VolumeMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeMetricStatusBackfilledData captures enum value "backfilled_data"
	VolumeMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeMetric
	// VolumeMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeMetricStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume metric based on the context it is used
func (m *VolumeMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloud(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexcache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) contextValidateCloud(ctx context.Context, formats strfmt.Registry) error {

	if m.Cloud != nil {
		if err := m.Cloud.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "cloud")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetric) contextValidateFlexcache(ctx context.Context, formats strfmt.Registry) error {

	if m.Flexcache != nil {
		if err := m.Flexcache.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "flexcache")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetric) UnmarshalBinary(b []byte) error {
	var res VolumeMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricCloud Performance numbers (IOPS and latency) for cloud store. These numbers are relevant only for volumes hosted on FabricPools.
//
// swagger:model VolumeMetricCloud
type VolumeMetricCloud struct {

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *VolumeMetricCloudIops `json:"iops,omitempty"`

	// latency
	Latency *VolumeMetricCloudLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume metric cloud
func (m *VolumeMetricCloud) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeMetricCloudTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricCloudTypeDurationPropEnum = append(volumeMetricCloudTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// VolumeMetricCloudDurationPT15S captures enum value "PT15S"
	VolumeMetricCloudDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// VolumeMetricCloudDurationPT4M captures enum value "PT4M"
	VolumeMetricCloudDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// VolumeMetricCloudDurationPT30M captures enum value "PT30M"
	VolumeMetricCloudDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// VolumeMetricCloudDurationPT2H captures enum value "PT2H"
	VolumeMetricCloudDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// VolumeMetricCloudDurationP1D captures enum value "P1D"
	VolumeMetricCloudDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// VolumeMetricCloudDurationPT5M captures enum value "PT5M"
	VolumeMetricCloudDurationPT5M string = "PT5M"
)

// prop value enum
func (m *VolumeMetricCloud) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricCloudTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricCloud) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"cloud"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricCloud) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "cloud" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetricCloud) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "cloud" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var volumeMetricCloudTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricCloudTypeStatusPropEnum = append(volumeMetricCloudTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeMetricCloudStatusOk captures enum value "ok"
	VolumeMetricCloudStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeMetricCloudStatusError captures enum value "error"
	VolumeMetricCloudStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeMetricCloudStatusPartialNoData captures enum value "partial_no_data"
	VolumeMetricCloudStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeMetricCloudStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeMetricCloudStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeMetricCloudStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeMetricCloudStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeMetricCloudStatusPartialOtherError captures enum value "partial_other_error"
	VolumeMetricCloudStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeMetricCloudStatusNegativeDelta captures enum value "negative_delta"
	VolumeMetricCloudStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeMetricCloudStatusBackfilledData captures enum value "backfilled_data"
	VolumeMetricCloudStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeMetricCloudStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeMetricCloudStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeMetricCloud
	// VolumeMetricCloud
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeMetricCloudStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeMetricCloudStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeMetricCloud) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricCloudTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricCloud) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"cloud"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricCloud) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"cloud"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume metric cloud based on the context it is used
func (m *VolumeMetricCloud) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricCloud) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"cloud"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricCloud) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "cloud" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetricCloud) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "cloud" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMetricCloud) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"cloud"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricCloud) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"cloud"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricCloud) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricCloud) UnmarshalBinary(b []byte) error {
	var res VolumeMetricCloud
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricCloudIops The rate of I/O operations observed at the storage object.
//
// swagger:model VolumeMetricCloudIops
type VolumeMetricCloudIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metric cloud iops
func (m *VolumeMetricCloudIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metric cloud iops based on the context it is used
func (m *VolumeMetricCloudIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricCloudIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricCloudIops) UnmarshalBinary(b []byte) error {
	var res VolumeMetricCloudIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricCloudLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model VolumeMetricCloudLatency
type VolumeMetricCloudLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metric cloud latency
func (m *VolumeMetricCloudLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metric cloud latency based on the context it is used
func (m *VolumeMetricCloudLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricCloudLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricCloudLatency) UnmarshalBinary(b []byte) error {
	var res VolumeMetricCloudLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricFlexcache Performance number for FlexCache used to measure cache effectiveness.
//
// swagger:model VolumeMetricFlexcache
type VolumeMetricFlexcache struct {

	// Bandwidth savings denoting the amount of data served locally by the cache, in bytes.
	// Example: 4096
	BandwidthSavings int64 `json:"bandwidth_savings,omitempty"`

	// Cache miss percentage.
	// Example: 20
	CacheMissPercent int64 `json:"cache_miss_percent,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT1D
	// Read Only: true
	// Enum: [PT15S PT5M PT30M PT2H PT1D]
	Duration string `json:"duration,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume metric flexcache
func (m *VolumeMetricFlexcache) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeMetricFlexcacheTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT5M","PT30M","PT2H","PT1D"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricFlexcacheTypeDurationPropEnum = append(volumeMetricFlexcacheTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// VolumeMetricFlexcacheDurationPT15S captures enum value "PT15S"
	VolumeMetricFlexcacheDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// VolumeMetricFlexcacheDurationPT5M captures enum value "PT5M"
	VolumeMetricFlexcacheDurationPT5M string = "PT5M"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// VolumeMetricFlexcacheDurationPT30M captures enum value "PT30M"
	VolumeMetricFlexcacheDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// VolumeMetricFlexcacheDurationPT2H captures enum value "PT2H"
	VolumeMetricFlexcacheDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// duration
	// Duration
	// PT1D
	// END DEBUGGING
	// VolumeMetricFlexcacheDurationPT1D captures enum value "PT1D"
	VolumeMetricFlexcacheDurationPT1D string = "PT1D"
)

// prop value enum
func (m *VolumeMetricFlexcache) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricFlexcacheTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricFlexcache) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"flexcache"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

var volumeMetricFlexcacheTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMetricFlexcacheTypeStatusPropEnum = append(volumeMetricFlexcacheTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusOk captures enum value "ok"
	VolumeMetricFlexcacheStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusError captures enum value "error"
	VolumeMetricFlexcacheStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusPartialNoData captures enum value "partial_no_data"
	VolumeMetricFlexcacheStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeMetricFlexcacheStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeMetricFlexcacheStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusPartialOtherError captures enum value "partial_other_error"
	VolumeMetricFlexcacheStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusNegativeDelta captures enum value "negative_delta"
	VolumeMetricFlexcacheStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusBackfilledData captures enum value "backfilled_data"
	VolumeMetricFlexcacheStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeMetricFlexcacheStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeMetricFlexcache
	// VolumeMetricFlexcache
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeMetricFlexcacheStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeMetricFlexcacheStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeMetricFlexcache) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMetricFlexcacheTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMetricFlexcache) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"flexcache"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricFlexcache) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"flexcache"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume metric flexcache based on the context it is used
func (m *VolumeMetricFlexcache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricFlexcache) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"flexcache"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricFlexcache) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"flexcache"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMetricFlexcache) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"flexcache"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricFlexcache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricFlexcache) UnmarshalBinary(b []byte) error {
	var res VolumeMetricFlexcache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model VolumeMetricIops
type VolumeMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metric iops
func (m *VolumeMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metric iops based on the context it is used
func (m *VolumeMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricIops) UnmarshalBinary(b []byte) error {
	var res VolumeMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model VolumeMetricLatency
type VolumeMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metric latency
func (m *VolumeMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metric latency based on the context it is used
func (m *VolumeMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricLatency) UnmarshalBinary(b []byte) error {
	var res VolumeMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricLinks volume metric links
//
// swagger:model VolumeMetricLinks
type VolumeMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume metric links
func (m *VolumeMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume metric links based on the context it is used
func (m *VolumeMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricLinks) UnmarshalBinary(b []byte) error {
	var res VolumeMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model VolumeMetricThroughput
type VolumeMetricThroughput struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume metric throughput
func (m *VolumeMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume metric throughput based on the context it is used
func (m *VolumeMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMetricThroughput) UnmarshalBinary(b []byte) error {
	var res VolumeMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMovement Volume movement. All attributes are modify, that is, not writable through POST. Set PATCH state to destination_aggregate to initiate a volume move operation. Volume movement on FlexGroup constituents are not supported.
//
// swagger:model VolumeMovement
type VolumeMovement struct {

	// Time window in seconds for cutover. The allowed range is between 30 to 300 seconds.
	// Example: 30
	CutoverWindow *int64 `json:"cutover_window,omitempty"`

	// destination aggregate
	DestinationAggregate *VolumeMovementDestinationAggregate `json:"destination_aggregate,omitempty"`

	// Completion percentage
	// Read Only: true
	PercentComplete int64 `json:"percent_complete,omitempty"`

	// Start time of volume move.
	// Example: 2020-12-07T03:45:12-05:00
	// Read Only: true
	// Format: date-time
	StartTime *strfmt.DateTime `json:"start_time,omitempty"`

	// State of volume move operation. PATCH the state to "aborted" to abort the move operation. PATCH the state to "cutover" to trigger cutover. PATCH the state to "paused" to pause the volume move operation in progress. PATCH the state to "replicating" to resume the paused volume move operation. PATCH the state to "cutover_wait" to go into cutover manually. When volume move operation is waiting to go into "cutover" state, this is indicated by the "cutover_pending" state. A change of state is only supported if volume movement is in progress.
	// Example: replicating
	// Enum: [aborted cutover cutover_wait cutover_pending failed paused queued replicating success]
	State string `json:"state,omitempty"`

	// Tiering policy for FabricPool
	// Enum: [all auto backup none snapshot_only]
	TieringPolicy string `json:"tiering_policy,omitempty"`
}

// Validate validates this volume movement
func (m *VolumeMovement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestinationAggregate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTieringPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMovement) validateDestinationAggregate(formats strfmt.Registry) error {
	if swag.IsZero(m.DestinationAggregate) { // not required
		return nil
	}

	if m.DestinationAggregate != nil {
		if err := m.DestinationAggregate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMovement) validateStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("movement"+"."+"start_time", "body", "date-time", m.StartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var volumeMovementTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aborted","cutover","cutover_wait","cutover_pending","failed","paused","queued","replicating","success"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMovementTypeStatePropEnum = append(volumeMovementTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// aborted
	// END DEBUGGING
	// VolumeMovementStateAborted captures enum value "aborted"
	VolumeMovementStateAborted string = "aborted"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// cutover
	// END DEBUGGING
	// VolumeMovementStateCutover captures enum value "cutover"
	VolumeMovementStateCutover string = "cutover"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// cutover_wait
	// END DEBUGGING
	// VolumeMovementStateCutoverWait captures enum value "cutover_wait"
	VolumeMovementStateCutoverWait string = "cutover_wait"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// cutover_pending
	// END DEBUGGING
	// VolumeMovementStateCutoverPending captures enum value "cutover_pending"
	VolumeMovementStateCutoverPending string = "cutover_pending"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// failed
	// END DEBUGGING
	// VolumeMovementStateFailed captures enum value "failed"
	VolumeMovementStateFailed string = "failed"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// paused
	// END DEBUGGING
	// VolumeMovementStatePaused captures enum value "paused"
	VolumeMovementStatePaused string = "paused"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// queued
	// END DEBUGGING
	// VolumeMovementStateQueued captures enum value "queued"
	VolumeMovementStateQueued string = "queued"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// replicating
	// END DEBUGGING
	// VolumeMovementStateReplicating captures enum value "replicating"
	VolumeMovementStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// state
	// State
	// success
	// END DEBUGGING
	// VolumeMovementStateSuccess captures enum value "success"
	VolumeMovementStateSuccess string = "success"
)

// prop value enum
func (m *VolumeMovement) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMovementTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMovement) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("movement"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var volumeMovementTypeTieringPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeMovementTypeTieringPolicyPropEnum = append(volumeMovementTypeTieringPolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// tiering_policy
	// TieringPolicy
	// all
	// END DEBUGGING
	// VolumeMovementTieringPolicyAll captures enum value "all"
	VolumeMovementTieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// tiering_policy
	// TieringPolicy
	// auto
	// END DEBUGGING
	// VolumeMovementTieringPolicyAuto captures enum value "auto"
	VolumeMovementTieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// tiering_policy
	// TieringPolicy
	// backup
	// END DEBUGGING
	// VolumeMovementTieringPolicyBackup captures enum value "backup"
	VolumeMovementTieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// tiering_policy
	// TieringPolicy
	// none
	// END DEBUGGING
	// VolumeMovementTieringPolicyNone captures enum value "none"
	VolumeMovementTieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// VolumeMovement
	// VolumeMovement
	// tiering_policy
	// TieringPolicy
	// snapshot_only
	// END DEBUGGING
	// VolumeMovementTieringPolicySnapshotOnly captures enum value "snapshot_only"
	VolumeMovementTieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *VolumeMovement) validateTieringPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeMovementTypeTieringPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeMovement) validateTieringPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.TieringPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateTieringPolicyEnum("movement"+"."+"tiering_policy", "body", m.TieringPolicy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume movement based on the context it is used
func (m *VolumeMovement) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestinationAggregate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMovement) contextValidateDestinationAggregate(ctx context.Context, formats strfmt.Registry) error {

	if m.DestinationAggregate != nil {
		if err := m.DestinationAggregate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeMovement) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"percent_complete", "body", int64(m.PercentComplete)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeMovement) contextValidateStartTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"start_time", "body", m.StartTime); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMovement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMovement) UnmarshalBinary(b []byte) error {
	var res VolumeMovement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMovementDestinationAggregate Aggregate
//
// swagger:model VolumeMovementDestinationAggregate
type VolumeMovementDestinationAggregate struct {

	// links
	Links *VolumeMovementDestinationAggregateLinks `json:"_links,omitempty"`

	// name
	// Example: aggr1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume movement destination aggregate
func (m *VolumeMovementDestinationAggregate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMovementDestinationAggregate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume movement destination aggregate based on the context it is used
func (m *VolumeMovementDestinationAggregate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMovementDestinationAggregate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMovementDestinationAggregate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMovementDestinationAggregate) UnmarshalBinary(b []byte) error {
	var res VolumeMovementDestinationAggregate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeMovementDestinationAggregateLinks volume movement destination aggregate links
//
// swagger:model VolumeMovementDestinationAggregateLinks
type VolumeMovementDestinationAggregateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume movement destination aggregate links
func (m *VolumeMovementDestinationAggregateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMovementDestinationAggregateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume movement destination aggregate links based on the context it is used
func (m *VolumeMovementDestinationAggregateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeMovementDestinationAggregateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "destination_aggregate" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeMovementDestinationAggregateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeMovementDestinationAggregateLinks) UnmarshalBinary(b []byte) error {
	var res VolumeMovementDestinationAggregateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeNas volume nas
//
// swagger:model VolumeNas
type VolumeNas struct {

	// export policy
	ExportPolicy *VolumeNasExportPolicy `json:"export_policy,omitempty"`

	// The UNIX group ID of the volume. Valid in POST or PATCH.
	Gid int64 `json:"gid,omitempty"`

	// junction parent
	JunctionParent *VolumeNasJunctionParent `json:"junction_parent,omitempty"`

	// The fully-qualified path in the owning SVM's namespace at which the volume is mounted. The path is case insensitive and must be unique within a SVM's namespace. Path must begin with '/' and must not end with '/'. Only one volume can be mounted at any given junction path. An empty path in POST creates an unmounted volume. An empty path in PATCH deactivates and unmounts the volume. Taking a volume offline or restricted state removes its junction path. This attribute is reported in GET only when the volume is mounted.
	// Example: /user/my_volume
	Path *string `json:"path,omitempty"`

	// Security style associated with the volume. Valid in POST or PATCH.<br>mixed &dash; Mixed-style security<br>ntfs &dash; NTFS/WIndows-style security<br>unified &dash; Unified-style security, unified UNIX, NFS and CIFS permissions<br>unix &dash; Unix-style security.
	// Enum: [mixed ntfs unified unix]
	SecurityStyle *string `json:"security_style,omitempty"`

	// The UNIX user ID of the volume. Valid in POST or PATCH.
	UID int64 `json:"uid,omitempty"`

	// UNIX permissions to be viewed as an octal number. It consists of 4 digits derived by adding up bits 4 (read), 2 (write) and 1 (execute). First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. The second digit selects permission for the owner of the file; the third selects permissions for other users in the same group; the fourth for other users not in the group. Valid in POST or PATCH. For security style "mixed" or "unix", the default setting is 0755 in octal (493 in decimal) and for security style "ntfs", the default setting is 0000. In cases where only owner, group and other permissions are given (as in 755, representing the second, third and fourth dight), first digit is assumed to be zero.
	// Example: 755
	UnixPermissions int64 `json:"unix_permissions,omitempty"`
}

// Validate validates this volume nas
func (m *VolumeNas) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExportPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJunctionParent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityStyle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNas) validateExportPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ExportPolicy) { // not required
		return nil
	}

	if m.ExportPolicy != nil {
		if err := m.ExportPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeNas) validateJunctionParent(formats strfmt.Registry) error {
	if swag.IsZero(m.JunctionParent) { // not required
		return nil
	}

	if m.JunctionParent != nil {
		if err := m.JunctionParent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent")
			}
			return err
		}
	}

	return nil
}

var volumeNasTypeSecurityStylePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["mixed","ntfs","unified","unix"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeNasTypeSecurityStylePropEnum = append(volumeNasTypeSecurityStylePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeNas
	// VolumeNas
	// security_style
	// SecurityStyle
	// mixed
	// END DEBUGGING
	// VolumeNasSecurityStyleMixed captures enum value "mixed"
	VolumeNasSecurityStyleMixed string = "mixed"

	// BEGIN DEBUGGING
	// VolumeNas
	// VolumeNas
	// security_style
	// SecurityStyle
	// ntfs
	// END DEBUGGING
	// VolumeNasSecurityStyleNtfs captures enum value "ntfs"
	VolumeNasSecurityStyleNtfs string = "ntfs"

	// BEGIN DEBUGGING
	// VolumeNas
	// VolumeNas
	// security_style
	// SecurityStyle
	// unified
	// END DEBUGGING
	// VolumeNasSecurityStyleUnified captures enum value "unified"
	VolumeNasSecurityStyleUnified string = "unified"

	// BEGIN DEBUGGING
	// VolumeNas
	// VolumeNas
	// security_style
	// SecurityStyle
	// unix
	// END DEBUGGING
	// VolumeNasSecurityStyleUnix captures enum value "unix"
	VolumeNasSecurityStyleUnix string = "unix"
)

// prop value enum
func (m *VolumeNas) validateSecurityStyleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeNasTypeSecurityStylePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeNas) validateSecurityStyle(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityStyle) { // not required
		return nil
	}

	// value enum
	if err := m.validateSecurityStyleEnum("nas"+"."+"security_style", "body", *m.SecurityStyle); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume nas based on the context it is used
func (m *VolumeNas) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExportPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJunctionParent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNas) contextValidateExportPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.ExportPolicy != nil {
		if err := m.ExportPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeNas) contextValidateJunctionParent(ctx context.Context, formats strfmt.Registry) error {

	if m.JunctionParent != nil {
		if err := m.JunctionParent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeNas) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeNas) UnmarshalBinary(b []byte) error {
	var res VolumeNas
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeNasExportPolicy Export Policy
//
// swagger:model VolumeNasExportPolicy
type VolumeNasExportPolicy struct {

	// links
	Links *VolumeNasExportPolicyLinks `json:"_links,omitempty"`

	// id
	// Example: 100
	ID int64 `json:"id,omitempty"`

	// name
	// Example: default
	Name string `json:"name,omitempty"`
}

// Validate validates this volume nas export policy
func (m *VolumeNasExportPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasExportPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume nas export policy based on the context it is used
func (m *VolumeNasExportPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasExportPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeNasExportPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeNasExportPolicy) UnmarshalBinary(b []byte) error {
	var res VolumeNasExportPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeNasExportPolicyLinks volume nas export policy links
//
// swagger:model VolumeNasExportPolicyLinks
type VolumeNasExportPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume nas export policy links
func (m *VolumeNasExportPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasExportPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume nas export policy links based on the context it is used
func (m *VolumeNasExportPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasExportPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "export_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeNasExportPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeNasExportPolicyLinks) UnmarshalBinary(b []byte) error {
	var res VolumeNasExportPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeNasJunctionParent volume nas junction parent
//
// swagger:model VolumeNasJunctionParent
type VolumeNasJunctionParent struct {

	// links
	Links *VolumeNasJunctionParentLinks `json:"_links,omitempty"`

	// The name of the parent volume that contains the junction inode of this volume. The junction parent volume must belong to the same SVM that owns this volume.
	// Example: vs1_root
	Name string `json:"name,omitempty"`

	// Unique identifier for the parent volume.
	// Example: 75c9cfb0-3eb4-11eb-9fb4-005056bb088a
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume nas junction parent
func (m *VolumeNasJunctionParent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasJunctionParent) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume nas junction parent based on the context it is used
func (m *VolumeNasJunctionParent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasJunctionParent) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeNasJunctionParent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeNasJunctionParent) UnmarshalBinary(b []byte) error {
	var res VolumeNasJunctionParent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeNasJunctionParentLinks volume nas junction parent links
//
// swagger:model VolumeNasJunctionParentLinks
type VolumeNasJunctionParentLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume nas junction parent links
func (m *VolumeNasJunctionParentLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasJunctionParentLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume nas junction parent links based on the context it is used
func (m *VolumeNasJunctionParentLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeNasJunctionParentLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nas" + "." + "junction_parent" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeNasJunctionParentLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeNasJunctionParentLinks) UnmarshalBinary(b []byte) error {
	var res VolumeNasJunctionParentLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeQos QoS information
//
// swagger:model VolumeQos
type VolumeQos struct {

	// policy
	Policy *VolumeQosPolicy `json:"policy,omitempty"`
}

// Validate validates this volume qos
func (m *VolumeQos) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeQos) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume qos based on the context it is used
func (m *VolumeQos) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeQos) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {
		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeQos) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeQos) UnmarshalBinary(b []byte) error {
	var res VolumeQos
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeQosPolicy When "min_throughput_iops", "min_throughput_mbps", "max_throughput_iops" or "max_throughput_mbps" attributes are specified, the storage object is assigned to an auto-generated QoS policy group. If the attributes are later modified, the auto-generated QoS policy-group attributes are modified. Attributes can be removed by specifying "0" and policy group by specifying "none". Upon deletion of the storage object or if the attributes are removed, then the QoS policy-group is also removed.
//
// swagger:model VolumeQosPolicy
type VolumeQosPolicy struct {

	// links
	Links *VolumeQosPolicyLinks `json:"_links,omitempty"`

	// Specifies the maximum throughput in IOPS, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 10000
	MaxThroughputIops int64 `json:"max_throughput_iops,omitempty"`

	// Specifies the maximum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MaxThroughputMbps int64 `json:"max_throughput_mbps,omitempty"`

	// Specifies the minimum throughput in IOPS, 0 means none. Setting "min_throughput" is supported on AFF platforms only, unless FabricPool tiering policies are set. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 2000
	MinThroughputIops int64 `json:"min_throughput_iops,omitempty"`

	// Specifies the minimum throughput in Megabytes per sec, 0 means none. This is mutually exclusive with name and UUID during POST and PATCH.
	// Example: 500
	MinThroughputMbps int64 `json:"min_throughput_mbps,omitempty"`

	// The QoS policy group name. This is mutually exclusive with UUID and other QoS attributes during POST and PATCH.
	// Example: performance
	Name string `json:"name,omitempty"`

	// The QoS policy group UUID. This is mutually exclusive with name and other QoS attributes during POST and PATCH.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume qos policy
func (m *VolumeQosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeQosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume qos policy based on the context it is used
func (m *VolumeQosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeQosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeQosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeQosPolicy) UnmarshalBinary(b []byte) error {
	var res VolumeQosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeQosPolicyLinks volume qos policy links
//
// swagger:model VolumeQosPolicyLinks
type VolumeQosPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume qos policy links
func (m *VolumeQosPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeQosPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume qos policy links based on the context it is used
func (m *VolumeQosPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeQosPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos" + "." + "policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeQosPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeQosPolicyLinks) UnmarshalBinary(b []byte) error {
	var res VolumeQosPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeQuota Quotas track the space or file usage of a user, group, or qtree in a FlexVol or a FlexGroup volume.
//
// swagger:model VolumeQuota
type VolumeQuota struct {

	// This option is used to enable or disable the quota for the volume. This option is valid only in PATCH. Quotas are enabled for FlexVols or FlexGroup volumes when the quota state is "on". Quotas are disabled for FlexVols or FlexGroup volumes when the quota state is "off".
	Enabled bool `json:"enabled,omitempty"`

	// Quota state of the volume
	// Read Only: true
	// Enum: [corrupt initializing mixed off on resizing]
	State string `json:"state,omitempty"`
}

// Validate validates this volume quota
func (m *VolumeQuota) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeQuotaTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["corrupt","initializing","mixed","off","on","resizing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeQuotaTypeStatePropEnum = append(volumeQuotaTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeQuota
	// VolumeQuota
	// state
	// State
	// corrupt
	// END DEBUGGING
	// VolumeQuotaStateCorrupt captures enum value "corrupt"
	VolumeQuotaStateCorrupt string = "corrupt"

	// BEGIN DEBUGGING
	// VolumeQuota
	// VolumeQuota
	// state
	// State
	// initializing
	// END DEBUGGING
	// VolumeQuotaStateInitializing captures enum value "initializing"
	VolumeQuotaStateInitializing string = "initializing"

	// BEGIN DEBUGGING
	// VolumeQuota
	// VolumeQuota
	// state
	// State
	// mixed
	// END DEBUGGING
	// VolumeQuotaStateMixed captures enum value "mixed"
	VolumeQuotaStateMixed string = "mixed"

	// BEGIN DEBUGGING
	// VolumeQuota
	// VolumeQuota
	// state
	// State
	// off
	// END DEBUGGING
	// VolumeQuotaStateOff captures enum value "off"
	VolumeQuotaStateOff string = "off"

	// BEGIN DEBUGGING
	// VolumeQuota
	// VolumeQuota
	// state
	// State
	// on
	// END DEBUGGING
	// VolumeQuotaStateOn captures enum value "on"
	VolumeQuotaStateOn string = "on"

	// BEGIN DEBUGGING
	// VolumeQuota
	// VolumeQuota
	// state
	// State
	// resizing
	// END DEBUGGING
	// VolumeQuotaStateResizing captures enum value "resizing"
	VolumeQuotaStateResizing string = "resizing"
)

// prop value enum
func (m *VolumeQuota) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeQuotaTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeQuota) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("quota"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume quota based on the context it is used
func (m *VolumeQuota) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeQuota) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "quota"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeQuota) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeQuota) UnmarshalBinary(b []byte) error {
	var res VolumeQuota
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSnaplock volume snaplock
//
// swagger:model VolumeSnaplock
type VolumeSnaplock struct {

	// Specifies if the volume append mode is enabled or disabled. When it is enabled, all the files created with write permissions on the volume are, by default, WORM appendable files. The user can append the data to a WORM appendable file but cannot modify the existing contents of the file nor delete the file until it expires.
	// Example: false
	AppendModeEnabled *bool `json:"append_mode_enabled,omitempty"`

	// Specifies the autocommit period for SnapLock volume. All files which are not modified for a period greater than the autocommit period of the volume are committed to the WORM state. The autocommit period value represents a duration and must be specified in the ISO-8601 duration format. The autocommit period can be in years, months, days, hours, and minutes. A period specified for years, months, and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The period string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the autocommit field also accepts the string "none".
	// Example: P30M
	AutocommitPeriod *string `json:"autocommit_period,omitempty"`

	// This is the volume compliance clock time which is used to manage the SnapLock objects in the volume.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	ComplianceClockTime *strfmt.DateTime `json:"compliance_clock_time,omitempty"`

	// Expiry time of the volume.
	// Example: Wed Sep  5 11:02:42 GMT 2018
	// Read Only: true
	// Format: date-time
	ExpiryTime *strfmt.DateTime `json:"expiry_time,omitempty"`

	// Indicates if this volume has been configured as SnapLock audit log volume for the SVM .
	// Example: true
	// Read Only: true
	IsAuditLog *bool `json:"is_audit_log,omitempty"`

	// Litigation count indicates the number of active legal-holds on the volume.
	// Example: 10
	// Read Only: true
	LitigationCount int64 `json:"litigation_count,omitempty"`

	// Specifies the privileged-delete attribute of a SnapLock volume. On a SnapLock Enterprise (SLE) volume, a designated privileged user can selectively delete files irrespective of the retention time of the file. SLE volumes can have privileged delete as disabled, enabled or permanently_disabled and for SnapLock Compliance (SLC) volumes it is always permanently_disabled.
	// Example: enabled
	// Enum: [disabled enabled permanently_disabled]
	PrivilegedDelete string `json:"privileged_delete,omitempty"`

	// retention
	Retention *VolumeSnaplockRetention `json:"retention,omitempty"`

	// The SnapLock type of the volume. <br>compliance &dash; A SnapLock Compliance(SLC) volume provides the highest level of WORM protection and an administrator cannot destroy a SLC volume if it contains unexpired WORM files. <br> enterprise &dash; An administrator can delete a SnapLock Enterprise(SLE) volume.<br> non_snaplock &dash; Indicates the volume is non-snaplock.
	// Example: enterprise
	// Enum: [compliance enterprise non_snaplock]
	Type *string `json:"type,omitempty"`

	// Indicates the number of files with an unspecified retention time in the volume.
	// Example: 10
	// Read Only: true
	UnspecifiedRetentionFileCount int64 `json:"unspecified_retention_file_count,omitempty"`
}

// Validate validates this volume snaplock
func (m *VolumeSnaplock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComplianceClockTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpiryTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivilegedDelete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetention(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnaplock) validateComplianceClockTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ComplianceClockTime) { // not required
		return nil
	}

	if err := validate.FormatOf("snaplock"+"."+"compliance_clock_time", "body", "date-time", m.ComplianceClockTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSnaplock) validateExpiryTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpiryTime) { // not required
		return nil
	}

	if err := validate.FormatOf("snaplock"+"."+"expiry_time", "body", "date-time", m.ExpiryTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var volumeSnaplockTypePrivilegedDeletePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["disabled","enabled","permanently_disabled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeSnaplockTypePrivilegedDeletePropEnum = append(volumeSnaplockTypePrivilegedDeletePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeSnaplock
	// VolumeSnaplock
	// privileged_delete
	// PrivilegedDelete
	// disabled
	// END DEBUGGING
	// VolumeSnaplockPrivilegedDeleteDisabled captures enum value "disabled"
	VolumeSnaplockPrivilegedDeleteDisabled string = "disabled"

	// BEGIN DEBUGGING
	// VolumeSnaplock
	// VolumeSnaplock
	// privileged_delete
	// PrivilegedDelete
	// enabled
	// END DEBUGGING
	// VolumeSnaplockPrivilegedDeleteEnabled captures enum value "enabled"
	VolumeSnaplockPrivilegedDeleteEnabled string = "enabled"

	// BEGIN DEBUGGING
	// VolumeSnaplock
	// VolumeSnaplock
	// privileged_delete
	// PrivilegedDelete
	// permanently_disabled
	// END DEBUGGING
	// VolumeSnaplockPrivilegedDeletePermanentlyDisabled captures enum value "permanently_disabled"
	VolumeSnaplockPrivilegedDeletePermanentlyDisabled string = "permanently_disabled"
)

// prop value enum
func (m *VolumeSnaplock) validatePrivilegedDeleteEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeSnaplockTypePrivilegedDeletePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeSnaplock) validatePrivilegedDelete(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivilegedDelete) { // not required
		return nil
	}

	// value enum
	if err := m.validatePrivilegedDeleteEnum("snaplock"+"."+"privileged_delete", "body", m.PrivilegedDelete); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSnaplock) validateRetention(formats strfmt.Registry) error {
	if swag.IsZero(m.Retention) { // not required
		return nil
	}

	if m.Retention != nil {
		if err := m.Retention.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock" + "." + "retention")
			}
			return err
		}
	}

	return nil
}

var volumeSnaplockTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["compliance","enterprise","non_snaplock"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeSnaplockTypeTypePropEnum = append(volumeSnaplockTypeTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeSnaplock
	// VolumeSnaplock
	// type
	// Type
	// compliance
	// END DEBUGGING
	// VolumeSnaplockTypeCompliance captures enum value "compliance"
	VolumeSnaplockTypeCompliance string = "compliance"

	// BEGIN DEBUGGING
	// VolumeSnaplock
	// VolumeSnaplock
	// type
	// Type
	// enterprise
	// END DEBUGGING
	// VolumeSnaplockTypeEnterprise captures enum value "enterprise"
	VolumeSnaplockTypeEnterprise string = "enterprise"

	// BEGIN DEBUGGING
	// VolumeSnaplock
	// VolumeSnaplock
	// type
	// Type
	// non_snaplock
	// END DEBUGGING
	// VolumeSnaplockTypeNonSnaplock captures enum value "non_snaplock"
	VolumeSnaplockTypeNonSnaplock string = "non_snaplock"
)

// prop value enum
func (m *VolumeSnaplock) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeSnaplockTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeSnaplock) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("snaplock"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume snaplock based on the context it is used
func (m *VolumeSnaplock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComplianceClockTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExpiryTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsAuditLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLitigationCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRetention(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnspecifiedRetentionFileCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnaplock) contextValidateComplianceClockTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snaplock"+"."+"compliance_clock_time", "body", m.ComplianceClockTime); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSnaplock) contextValidateExpiryTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snaplock"+"."+"expiry_time", "body", m.ExpiryTime); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSnaplock) contextValidateIsAuditLog(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snaplock"+"."+"is_audit_log", "body", m.IsAuditLog); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSnaplock) contextValidateLitigationCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snaplock"+"."+"litigation_count", "body", int64(m.LitigationCount)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSnaplock) contextValidateRetention(ctx context.Context, formats strfmt.Registry) error {

	if m.Retention != nil {
		if err := m.Retention.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snaplock" + "." + "retention")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeSnaplock) contextValidateUnspecifiedRetentionFileCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snaplock"+"."+"unspecified_retention_file_count", "body", int64(m.UnspecifiedRetentionFileCount)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSnaplock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSnaplock) UnmarshalBinary(b []byte) error {
	var res VolumeSnaplock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSnaplockRetention volume snaplock retention
//
// swagger:model VolumeSnaplockRetention
type VolumeSnaplockRetention struct {

	// Specifies the default retention period that is applied to files while committing them to the WORM state without an associated retention period. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, months, and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string "infinite" to set an infinite retention period and the string "unspecified" to set an unspecified retention period.
	// Example: P30Y
	Default string `json:"default,omitempty"`

	// Specifies the maximum allowed retention period for files committed to the WORM state on the volume. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, months, and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string "infinite" to set an infinite retention period.
	// Example: P30Y
	Maximum *string `json:"maximum,omitempty"`

	// Specifies the minimum allowed retention period for files committed to the WORM state on the volume. The retention value represents a duration and must be specified in the ISO-8601 duration format. The retention period can be in years, months, days, hours, and minutes. A duration specified for years, month,s and days is represented in the ISO-8601 format as "P<num>Y", "P<num>M", "P<num>D" respectively, for example "P10Y" represents a duration of 10 years. A duration in hours and minutes is represented by "PT<num>H" and "PT<num>M" respectively. The retention string must contain only a single time element that is, either years, months, days, hours, or minutes. A duration which combines different periods is not supported, for example "P1Y10M" is not supported. Apart from the duration specified in the ISO-8601 format, the duration field also accepts the string "infinite" to set an infinite retention period.
	// Example: P30Y
	Minimum *string `json:"minimum,omitempty"`
}

// Validate validates this volume snaplock retention
func (m *VolumeSnaplockRetention) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this volume snaplock retention based on context it is used
func (m *VolumeSnaplockRetention) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSnaplockRetention) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSnaplockRetention) UnmarshalBinary(b []byte) error {
	var res VolumeSnaplockRetention
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSnapmirror Specifies attributes for SnapMirror protection.
//
// swagger:model VolumeSnapmirror
type VolumeSnapmirror struct {

	// destinations
	Destinations *VolumeSnapmirrorDestinations `json:"destinations,omitempty"`

	// Specifies whether a volume is a SnapMirror source volume, using SnapMirror to protect its data.
	// Read Only: true
	IsProtected *bool `json:"is_protected,omitempty"`
}

// Validate validates this volume snapmirror
func (m *VolumeSnapmirror) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestinations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnapmirror) validateDestinations(formats strfmt.Registry) error {
	if swag.IsZero(m.Destinations) { // not required
		return nil
	}

	if m.Destinations != nil {
		if err := m.Destinations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror" + "." + "destinations")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume snapmirror based on the context it is used
func (m *VolumeSnapmirror) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestinations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsProtected(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnapmirror) contextValidateDestinations(ctx context.Context, formats strfmt.Registry) error {

	if m.Destinations != nil {
		if err := m.Destinations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapmirror" + "." + "destinations")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeSnapmirror) contextValidateIsProtected(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapmirror"+"."+"is_protected", "body", m.IsProtected); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSnapmirror) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSnapmirror) UnmarshalBinary(b []byte) error {
	var res VolumeSnapmirror
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSnapmirrorDestinations volume snapmirror destinations
//
// swagger:model VolumeSnapmirrorDestinations
type VolumeSnapmirrorDestinations struct {

	// Specifies whether a volume is a SnapMirror source volume, using SnapMirror to protect its data to a cloud destination.
	// Read Only: true
	IsCloud *bool `json:"is_cloud,omitempty"`

	// Specifies whether a volume is a SnapMirror source volume, using SnapMirror to protect its data to an ONTAP destination.
	// Read Only: true
	IsOntap *bool `json:"is_ontap,omitempty"`
}

// Validate validates this volume snapmirror destinations
func (m *VolumeSnapmirrorDestinations) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume snapmirror destinations based on the context it is used
func (m *VolumeSnapmirrorDestinations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIsCloud(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsOntap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnapmirrorDestinations) contextValidateIsCloud(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapmirror"+"."+"destinations"+"."+"is_cloud", "body", m.IsCloud); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSnapmirrorDestinations) contextValidateIsOntap(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapmirror"+"."+"destinations"+"."+"is_ontap", "body", m.IsOntap); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSnapmirrorDestinations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSnapmirrorDestinations) UnmarshalBinary(b []byte) error {
	var res VolumeSnapmirrorDestinations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSnapshotPolicy This is a reference to the Snapshot copy policy.
//
// swagger:model VolumeSnapshotPolicy
type VolumeSnapshotPolicy struct {

	// links
	Links *VolumeSnapshotPolicyLinks `json:"_links,omitempty"`

	// name
	// Example: default
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume snapshot policy
func (m *VolumeSnapshotPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnapshotPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume snapshot policy based on the context it is used
func (m *VolumeSnapshotPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnapshotPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSnapshotPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSnapshotPolicy) UnmarshalBinary(b []byte) error {
	var res VolumeSnapshotPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSnapshotPolicyLinks volume snapshot policy links
//
// swagger:model VolumeSnapshotPolicyLinks
type VolumeSnapshotPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume snapshot policy links
func (m *VolumeSnapshotPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnapshotPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume snapshot policy links based on the context it is used
func (m *VolumeSnapshotPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSnapshotPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSnapshotPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSnapshotPolicyLinks) UnmarshalBinary(b []byte) error {
	var res VolumeSnapshotPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSpace volume space
//
// swagger:model VolumeSpace
type VolumeSpace struct {

	// Total size of AFS, excluding snap-reserve, in bytes.
	AfsTotal int64 `json:"afs_total,omitempty"`

	// The available space, in bytes.
	// Read Only: true
	Available int64 `json:"available,omitempty"`

	// The space available, as a percent.
	AvailablePercent int64 `json:"available_percent,omitempty"`

	// The size that is physically used in the block storage of the volume and has a cold temperature. In bytes. This parameter is only supported if the volume is in an aggregate that is either attached to a cloud store or could be attached to a cloud store.
	// Read Only: true
	BlockStorageInactiveUserData int64 `json:"block_storage_inactive_user_data,omitempty"`

	// Percentage of size that is physically used in the performance tier of the volume.
	// Read Only: true
	BlockStorageInactiveUserDataPercent int64 `json:"block_storage_inactive_user_data_percent,omitempty"`

	// Space used by capacity tier for this volume in the FabricPool aggregate, in bytes.
	// Read Only: true
	CapacityTierFootprint int64 `json:"capacity_tier_footprint,omitempty"`

	// Cross volume deduplication metadata footprint, in bytes.
	// Read Only: true
	CrossVolumeDedupeMetafilesFootprint int64 `json:"cross_volume_dedupe_metafiles_footprint,omitempty"`

	// Cross volume temporary deduplication metadata footprint, in bytes.
	// Read Only: true
	CrossVolumeDedupeMetafilesTemporaryFootprint int64 `json:"cross_volume_dedupe_metafiles_temporary_footprint,omitempty"`

	// Deduplication metadata footprint, in bytes.
	// Read Only: true
	DedupeMetafilesFootprint int64 `json:"dedupe_metafiles_footprint,omitempty"`

	// Temporary deduplication metadata footprint, in bytes.
	// Read Only: true
	DedupeMetafilesTemporaryFootprint int64 `json:"dedupe_metafiles_temporary_footprint,omitempty"`

	// Delayed free blocks footprint, in bytes.
	// Read Only: true
	DelayedFreeFootprint int64 `json:"delayed_free_footprint,omitempty"`

	// Size that should be available for the volume, irrespective of available size in the aggregate, in bytes.
	ExpectedAvailable int64 `json:"expected_available,omitempty"`

	// File operation metadata footprint, in bytes.
	// Read Only: true
	FileOperationMetadata int64 `json:"file_operation_metadata,omitempty"`

	// Total usable size of the volume, in bytes.
	// Read Only: true
	FilesystemSize int64 `json:"filesystem_size,omitempty"`

	// Specifies whether the file system is to remain of the same size when set to true or to grow when set to false. This option is automatically set to true when a volume becomes SnapMirrored.
	FilesystemSizeFixed *bool `json:"filesystem_size_fixed,omitempty"`

	// Data used for this volume in the aggregate, in bytes.
	// Read Only: true
	Footprint int64 `json:"footprint,omitempty"`

	// Used to change the amount of space reserved for overwrites of reserved objects in a volume.
	FractionalReserve int64 `json:"fractional_reserve,omitempty"`

	// Volume full threshold percentage at which EMS warnings can be sent.
	FullThresholdPercent int64 `json:"full_threshold_percent,omitempty"`

	// Space used by the local tier for this volume in the aggregate, in bytes.
	// Read Only: true
	LocalTierFootprint int64 `json:"local_tier_footprint,omitempty"`

	// logical space
	LogicalSpace *VolumeSpaceLogicalSpace `json:"logical_space,omitempty"`

	// Space used by the volume metadata in the aggregate, in bytes.
	// Read Only: true
	Metadata int64 `json:"metadata,omitempty"`

	// Volume nearly full threshold percentage at which EMS warnings can be sent.
	NearlyFullThresholdPercent int64 `json:"nearly_full_threshold_percent,omitempty"`

	// The amount of space not available for this volume in the aggregate, in bytes.
	// Read Only: true
	OverProvisioned int64 `json:"over_provisioned,omitempty"`

	// Reserved space for overwrites, in bytes.
	// Read Only: true
	OverwriteReserve int64 `json:"overwrite_reserve,omitempty"`

	// Overwrite logical reserve space used, in bytes.
	// Read Only: true
	OverwriteReserveUsed int64 `json:"overwrite_reserve_used,omitempty"`

	// Percentage of the volume size that is used.
	// Read Only: true
	PercentUsed int64 `json:"percent_used,omitempty"`

	// Space used by the performance tier for this volume in the FabricPool aggregate, in bytes.
	// Read Only: true
	PerformanceTierFootprint int64 `json:"performance_tier_footprint,omitempty"`

	// Size that is physically used in the volume, in bytes.
	PhysicalUsed int64 `json:"physical_used,omitempty"`

	// Size that is physically used in the volume, as a percentage.
	PhysicalUsedPercent int64 `json:"physical_used_percent,omitempty"`

	// Total provisioned size. The default size is equal to the minimum size of 20MB, in bytes.
	Size int64 `json:"size,omitempty"`

	// Available space for Snapshot copies from snap-reserve, in bytes.
	// Read Only: true
	SizeAvailableForSnapshots int64 `json:"size_available_for_snapshots,omitempty"`

	// SnapMirror destination footprint, in bytes.
	// Read Only: true
	SnapmirrorDestinationFootprint int64 `json:"snapmirror_destination_footprint,omitempty"`

	// snapshot
	Snapshot *VolumeSpaceSnapshot `json:"snapshot,omitempty"`

	// Snapshot reserve that is not available for Snapshot copy creation, in bytes.
	// Read Only: true
	SnapshotReserveUnusable int64 `json:"snapshot_reserve_unusable,omitempty"`

	// Space used by the snapshot copies beyond the snap-reserve, in bytes.
	// Read Only: true
	SnapshotSpill int64 `json:"snapshot_spill,omitempty"`

	// Data and metadata used for this volume in the aggregate, in bytes.
	// Read Only: true
	TotalFootprint int64 `json:"total_footprint,omitempty"`

	// The virtual space used (includes volume reserves) before storage efficiency, in bytes.
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// The space used by Active Filesystem, in bytes.
	UsedByAfs int64 `json:"used_by_afs,omitempty"`

	// User data, in bytes.
	// Read Only: true
	UserData int64 `json:"user_data,omitempty"`

	// Space reserved for future writes in the volume, in bytes.
	// Read Only: true
	VolumeGuaranteeFootprint int64 `json:"volume_guarantee_footprint,omitempty"`
}

// Validate validates this volume space
func (m *VolumeSpace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLogicalSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSpace) validateLogicalSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.LogicalSpace) { // not required
		return nil
	}

	if m.LogicalSpace != nil {
		if err := m.LogicalSpace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "logical_space")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeSpace) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume space based on the context it is used
func (m *VolumeSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlockStorageInactiveUserData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlockStorageInactiveUserDataPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCapacityTierFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCrossVolumeDedupeMetafilesFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCrossVolumeDedupeMetafilesTemporaryFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDedupeMetafilesFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDedupeMetafilesTemporaryFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDelayedFreeFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileOperationMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilesystemSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalTierFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverProvisioned(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverwriteReserve(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverwriteReserveUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePerformanceTierFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSizeAvailableForSnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapmirrorDestinationFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotReserveUnusable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotSpill(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotalFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeGuaranteeFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSpace) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateBlockStorageInactiveUserData(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage_inactive_user_data", "body", int64(m.BlockStorageInactiveUserData)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateBlockStorageInactiveUserDataPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage_inactive_user_data_percent", "body", int64(m.BlockStorageInactiveUserDataPercent)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateCapacityTierFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"capacity_tier_footprint", "body", int64(m.CapacityTierFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateCrossVolumeDedupeMetafilesFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"cross_volume_dedupe_metafiles_footprint", "body", int64(m.CrossVolumeDedupeMetafilesFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateCrossVolumeDedupeMetafilesTemporaryFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"cross_volume_dedupe_metafiles_temporary_footprint", "body", int64(m.CrossVolumeDedupeMetafilesTemporaryFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateDedupeMetafilesFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"dedupe_metafiles_footprint", "body", int64(m.DedupeMetafilesFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateDedupeMetafilesTemporaryFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"dedupe_metafiles_temporary_footprint", "body", int64(m.DedupeMetafilesTemporaryFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateDelayedFreeFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"delayed_free_footprint", "body", int64(m.DelayedFreeFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateFileOperationMetadata(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"file_operation_metadata", "body", int64(m.FileOperationMetadata)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateFilesystemSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"filesystem_size", "body", int64(m.FilesystemSize)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"footprint", "body", int64(m.Footprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateLocalTierFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"local_tier_footprint", "body", int64(m.LocalTierFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateLogicalSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.LogicalSpace != nil {
		if err := m.LogicalSpace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "logical_space")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeSpace) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"metadata", "body", int64(m.Metadata)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateOverProvisioned(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"over_provisioned", "body", int64(m.OverProvisioned)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateOverwriteReserve(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"overwrite_reserve", "body", int64(m.OverwriteReserve)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateOverwriteReserveUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"overwrite_reserve_used", "body", int64(m.OverwriteReserveUsed)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidatePercentUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"percent_used", "body", int64(m.PercentUsed)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidatePerformanceTierFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"performance_tier_footprint", "body", int64(m.PerformanceTierFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateSizeAvailableForSnapshots(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"size_available_for_snapshots", "body", int64(m.SizeAvailableForSnapshots)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateSnapmirrorDestinationFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapmirror_destination_footprint", "body", int64(m.SnapmirrorDestinationFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {
		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeSpace) contextValidateSnapshotReserveUnusable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot_reserve_unusable", "body", int64(m.SnapshotReserveUnusable)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateSnapshotSpill(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot_spill", "body", int64(m.SnapshotSpill)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateTotalFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"total_footprint", "body", int64(m.TotalFootprint)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateUserData(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"user_data", "body", int64(m.UserData)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpace) contextValidateVolumeGuaranteeFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"volume_guarantee_footprint", "body", int64(m.VolumeGuaranteeFootprint)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSpace) UnmarshalBinary(b []byte) error {
	var res VolumeSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSpaceLogicalSpace volume space logical space
//
// swagger:model VolumeSpaceLogicalSpace
type VolumeSpaceLogicalSpace struct {

	// The amount of space available in this volume with storage efficiency space considered used, in bytes.
	// Read Only: true
	Available int64 `json:"available,omitempty"`

	// Specifies whether space accounting for operations on the volume is done along with storage efficiency.
	Enforcement *bool `json:"enforcement,omitempty"`

	// Specifies whether space reporting on the volume is done along with storage efficiency.
	Reporting *bool `json:"reporting,omitempty"`

	// SUM of (physical-used, shared_refs, compression_saved_in_plane0, vbn_zero, future_blk_cnt), in bytes.
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// The virtual space used by AFS alone (includes volume reserves) and along with storage efficiency, in bytes.
	// Read Only: true
	UsedByAfs int64 `json:"used_by_afs,omitempty"`

	// Size that is logically used across all Snapshot copies in the volume, in bytes.
	// Read Only: true
	UsedBySnapshots int64 `json:"used_by_snapshots,omitempty"`

	// SUM of (physical-used, shared_refs, compression_saved_in_plane0, vbn_zero, future_blk_cnt), as a percentage.
	// Read Only: true
	UsedPercent int64 `json:"used_percent,omitempty"`
}

// Validate validates this volume space logical space
func (m *VolumeSpaceLogicalSpace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume space logical space based on the context it is used
func (m *VolumeSpaceLogicalSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedByAfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedBySnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSpaceLogicalSpace) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_space"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpaceLogicalSpace) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpaceLogicalSpace) contextValidateUsedByAfs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_space"+"."+"used_by_afs", "body", int64(m.UsedByAfs)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpaceLogicalSpace) contextValidateUsedBySnapshots(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_space"+"."+"used_by_snapshots", "body", int64(m.UsedBySnapshots)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpaceLogicalSpace) contextValidateUsedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"logical_space"+"."+"used_percent", "body", int64(m.UsedPercent)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSpaceLogicalSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSpaceLogicalSpace) UnmarshalBinary(b []byte) error {
	var res VolumeSpaceLogicalSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSpaceSnapshot volume space snapshot
//
// swagger:model VolumeSpaceSnapshot
type VolumeSpaceSnapshot struct {

	// Specifies whether Snapshot copy autodelete is currently enabled on this volume.
	AutodeleteEnabled *bool `json:"autodelete_enabled,omitempty"`

	// Specifies when the system should trigger an autodelete of Snapshot copies. When set to _volume_, autodelete is triggered based on volume fullness. When set to _snap_reserve_, autodelete is triggered based on Snapshot reserve fullness. The default value is _volume_.
	// Enum: [volume snap_reserve]
	AutodeleteTrigger *string `json:"autodelete_trigger,omitempty"`

	// Size available for Snapshot copies within the Snapshot copy reserve, in bytes.
	// Read Only: true
	ReserveAvailable int64 `json:"reserve_available,omitempty"`

	// The space that has been set aside as a reserve for Snapshot copy usage, in percent.
	ReservePercent *int64 `json:"reserve_percent,omitempty"`

	// Size in the volume that has been set aside as a reserve for Snapshot copy usage, in bytes.
	// Read Only: true
	ReserveSize int64 `json:"reserve_size,omitempty"`

	// Percentage of snapshot reserve size that has been used.
	// Read Only: true
	SpaceUsedPercent int64 `json:"space_used_percent,omitempty"`

	// The total space used by Snapshot copies in the volume, in bytes.
	// Read Only: true
	Used int64 `json:"used,omitempty"`
}

// Validate validates this volume space snapshot
func (m *VolumeSpaceSnapshot) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAutodeleteTrigger(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeSpaceSnapshotTypeAutodeleteTriggerPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["volume","snap_reserve"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeSpaceSnapshotTypeAutodeleteTriggerPropEnum = append(volumeSpaceSnapshotTypeAutodeleteTriggerPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeSpaceSnapshot
	// VolumeSpaceSnapshot
	// autodelete_trigger
	// AutodeleteTrigger
	// volume
	// END DEBUGGING
	// VolumeSpaceSnapshotAutodeleteTriggerVolume captures enum value "volume"
	VolumeSpaceSnapshotAutodeleteTriggerVolume string = "volume"

	// BEGIN DEBUGGING
	// VolumeSpaceSnapshot
	// VolumeSpaceSnapshot
	// autodelete_trigger
	// AutodeleteTrigger
	// snap_reserve
	// END DEBUGGING
	// VolumeSpaceSnapshotAutodeleteTriggerSnapReserve captures enum value "snap_reserve"
	VolumeSpaceSnapshotAutodeleteTriggerSnapReserve string = "snap_reserve"
)

// prop value enum
func (m *VolumeSpaceSnapshot) validateAutodeleteTriggerEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeSpaceSnapshotTypeAutodeleteTriggerPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeSpaceSnapshot) validateAutodeleteTrigger(formats strfmt.Registry) error {
	if swag.IsZero(m.AutodeleteTrigger) { // not required
		return nil
	}

	// value enum
	if err := m.validateAutodeleteTriggerEnum("space"+"."+"snapshot"+"."+"autodelete_trigger", "body", *m.AutodeleteTrigger); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume space snapshot based on the context it is used
func (m *VolumeSpaceSnapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReserveAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReserveSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpaceUsedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSpaceSnapshot) contextValidateReserveAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"reserve_available", "body", int64(m.ReserveAvailable)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpaceSnapshot) contextValidateReserveSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"reserve_size", "body", int64(m.ReserveSize)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpaceSnapshot) contextValidateSpaceUsedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"space_used_percent", "body", int64(m.SpaceUsedPercent)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeSpaceSnapshot) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSpaceSnapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSpaceSnapshot) UnmarshalBinary(b []byte) error {
	var res VolumeSpaceSnapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatistics These are raw performance numbers, such as IOPS latency and throughput. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster.
//
// swagger:model VolumeStatistics
type VolumeStatistics struct {

	// cloud
	Cloud *VolumeStatisticsCloud `json:"cloud,omitempty"`

	// flexcache raw
	FlexcacheRaw *VolumeStatisticsFlexcacheRaw `json:"flexcache_raw,omitempty"`

	// iops raw
	IopsRaw *VolumeStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *VolumeStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *VolumeStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume statistics
func (m *VolumeStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCloud(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexcacheRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeStatistics) validateCloud(formats strfmt.Registry) error {
	if swag.IsZero(m.Cloud) { // not required
		return nil
	}

	if m.Cloud != nil {
		if err := m.Cloud.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "cloud")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) validateFlexcacheRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.FlexcacheRaw) { // not required
		return nil
	}

	if m.FlexcacheRaw != nil {
		if err := m.FlexcacheRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "flexcache_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var volumeStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeStatisticsTypeStatusPropEnum = append(volumeStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeStatisticsStatusOk captures enum value "ok"
	VolumeStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeStatisticsStatusError captures enum value "error"
	VolumeStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeStatisticsStatusPartialNoData captures enum value "partial_no_data"
	VolumeStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeStatisticsStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	VolumeStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeStatisticsStatusNegativeDelta captures enum value "negative_delta"
	VolumeStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeStatisticsStatusBackfilledData captures enum value "backfilled_data"
	VolumeStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeStatistics
	// VolumeStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeStatisticsStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume statistics based on the context it is used
func (m *VolumeStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCloud(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexcacheRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeStatistics) contextValidateCloud(ctx context.Context, formats strfmt.Registry) error {

	if m.Cloud != nil {
		if err := m.Cloud.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "cloud")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) contextValidateFlexcacheRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.FlexcacheRaw != nil {
		if err := m.FlexcacheRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "flexcache_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatistics) UnmarshalBinary(b []byte) error {
	var res VolumeStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatisticsCloud These are raw performance numbers (IOPS and latency) for the cloud store. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster. These numbers are relevant only for volumes hosted on FabricPools.
//
// swagger:model VolumeStatisticsCloud
type VolumeStatisticsCloud struct {

	// iops raw
	IopsRaw *VolumeStatisticsCloudIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *VolumeStatisticsCloudLatencyRaw `json:"latency_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume statistics cloud
func (m *VolumeStatisticsCloud) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeStatisticsCloud) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "cloud" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatisticsCloud) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "cloud" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var volumeStatisticsCloudTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeStatisticsCloudTypeStatusPropEnum = append(volumeStatisticsCloudTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeStatisticsCloudStatusOk captures enum value "ok"
	VolumeStatisticsCloudStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeStatisticsCloudStatusError captures enum value "error"
	VolumeStatisticsCloudStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeStatisticsCloudStatusPartialNoData captures enum value "partial_no_data"
	VolumeStatisticsCloudStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeStatisticsCloudStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeStatisticsCloudStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeStatisticsCloudStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeStatisticsCloudStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeStatisticsCloudStatusPartialOtherError captures enum value "partial_other_error"
	VolumeStatisticsCloudStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeStatisticsCloudStatusNegativeDelta captures enum value "negative_delta"
	VolumeStatisticsCloudStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeStatisticsCloudStatusBackfilledData captures enum value "backfilled_data"
	VolumeStatisticsCloudStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeStatisticsCloudStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeStatisticsCloudStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeStatisticsCloud
	// VolumeStatisticsCloud
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeStatisticsCloudStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeStatisticsCloudStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeStatisticsCloud) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeStatisticsCloudTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeStatisticsCloud) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"cloud"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeStatisticsCloud) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"cloud"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume statistics cloud based on the context it is used
func (m *VolumeStatisticsCloud) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeStatisticsCloud) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "cloud" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatisticsCloud) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "cloud" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *VolumeStatisticsCloud) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"cloud"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeStatisticsCloud) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"cloud"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatisticsCloud) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatisticsCloud) UnmarshalBinary(b []byte) error {
	var res VolumeStatisticsCloud
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatisticsCloudIopsRaw The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model VolumeStatisticsCloudIopsRaw
type VolumeStatisticsCloudIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume statistics cloud iops raw
func (m *VolumeStatisticsCloudIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume statistics cloud iops raw based on the context it is used
func (m *VolumeStatisticsCloudIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatisticsCloudIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatisticsCloudIopsRaw) UnmarshalBinary(b []byte) error {
	var res VolumeStatisticsCloudIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatisticsCloudLatencyRaw The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model VolumeStatisticsCloudLatencyRaw
type VolumeStatisticsCloudLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume statistics cloud latency raw
func (m *VolumeStatisticsCloudLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume statistics cloud latency raw based on the context it is used
func (m *VolumeStatisticsCloudLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatisticsCloudLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatisticsCloudLatencyRaw) UnmarshalBinary(b []byte) error {
	var res VolumeStatisticsCloudLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatisticsFlexcacheRaw Performance numbers for FlexCache used to measure cache effectiveness.
//
// swagger:model VolumeStatisticsFlexcacheRaw
type VolumeStatisticsFlexcacheRaw struct {

	// Blocks retrieved from origin in case of a cache miss. This can be divided by the raw client_requested_blocks and multiplied by 100 to calculate the cache miss percentage.
	// Example: 10
	CacheMissBlocks int64 `json:"cache_miss_blocks,omitempty"`

	// Total blocks requested by the client.
	// Example: 500
	ClientRequestedBlocks int64 `json:"client_requested_blocks,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this volume statistics flexcache raw
func (m *VolumeStatisticsFlexcacheRaw) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var volumeStatisticsFlexcacheRawTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeStatisticsFlexcacheRawTypeStatusPropEnum = append(volumeStatisticsFlexcacheRawTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// ok
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusOk captures enum value "ok"
	VolumeStatisticsFlexcacheRawStatusOk string = "ok"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// error
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusError captures enum value "error"
	VolumeStatisticsFlexcacheRawStatusError string = "error"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusPartialNoData captures enum value "partial_no_data"
	VolumeStatisticsFlexcacheRawStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusPartialNoUUID captures enum value "partial_no_uuid"
	VolumeStatisticsFlexcacheRawStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusPartialNoResponse captures enum value "partial_no_response"
	VolumeStatisticsFlexcacheRawStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusPartialOtherError captures enum value "partial_other_error"
	VolumeStatisticsFlexcacheRawStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusNegativeDelta captures enum value "negative_delta"
	VolumeStatisticsFlexcacheRawStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusBackfilledData captures enum value "backfilled_data"
	VolumeStatisticsFlexcacheRawStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	VolumeStatisticsFlexcacheRawStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// VolumeStatisticsFlexcacheRaw
	// VolumeStatisticsFlexcacheRaw
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// VolumeStatisticsFlexcacheRawStatusInconsistentOldData captures enum value "inconsistent_old_data"
	VolumeStatisticsFlexcacheRawStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *VolumeStatisticsFlexcacheRaw) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeStatisticsFlexcacheRawTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeStatisticsFlexcacheRaw) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"flexcache_raw"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *VolumeStatisticsFlexcacheRaw) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"flexcache_raw"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this volume statistics flexcache raw based on the context it is used
func (m *VolumeStatisticsFlexcacheRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeStatisticsFlexcacheRaw) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"flexcache_raw"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *VolumeStatisticsFlexcacheRaw) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"flexcache_raw"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatisticsFlexcacheRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatisticsFlexcacheRaw) UnmarshalBinary(b []byte) error {
	var res VolumeStatisticsFlexcacheRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatisticsIopsRaw The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model VolumeStatisticsIopsRaw
type VolumeStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume statistics iops raw
func (m *VolumeStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume statistics iops raw based on the context it is used
func (m *VolumeStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res VolumeStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model VolumeStatisticsLatencyRaw
type VolumeStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume statistics latency raw
func (m *VolumeStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume statistics latency raw based on the context it is used
func (m *VolumeStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res VolumeStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeStatisticsThroughputRaw Throughput bytes observed at the storage object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model VolumeStatisticsThroughputRaw
type VolumeStatisticsThroughputRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this volume statistics throughput raw
func (m *VolumeStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this volume statistics throughput raw based on the context it is used
func (m *VolumeStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res VolumeStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSvm SVM containing the volume. Required on POST.
//
// swagger:model VolumeSvm
type VolumeSvm struct {

	// links
	Links *VolumeSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this volume svm
func (m *VolumeSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume svm based on the context it is used
func (m *VolumeSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSvm) UnmarshalBinary(b []byte) error {
	var res VolumeSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeSvmLinks volume svm links
//
// swagger:model VolumeSvmLinks
type VolumeSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this volume svm links
func (m *VolumeSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this volume svm links based on the context it is used
func (m *VolumeSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VolumeSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeSvmLinks) UnmarshalBinary(b []byte) error {
	var res VolumeSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VolumeTiering volume tiering
//
// swagger:model VolumeTiering
type VolumeTiering struct {

	// This parameter specifies the minimum number of days that user data blocks of the volume must be cooled before they can be considered cold and tiered out to the cloud tier. Note that this parameter is only used for tiering purposes and does not affect the reporting of inactive data. The value specified should be greater than the frequency with which applications in the volume shift between different sets of data. This parameter cannot be set when volume tiering policy is either "none" or "all". The default value of this parameter depends on the volume's tiering policy. See the tiering policy section of this documentation for corresponding default values. If the tiering policy on the volume gets changed, then this parameter will be reset to the default value corresponding to the new tiering policy.
	// Maximum: 183
	// Minimum: 2
	MinCoolingDays int64 `json:"min_cooling_days,omitempty"`

	// This parameter specifies tags of a volume for objects stored on a FabricPool-enabled aggregate. Each tag is a key,value pair and should be in the format "key=value".
	// Max Items: 4
	// Min Items: 0
	// Unique: true
	ObjectTags []string `json:"object_tags,omitempty"`

	// Policy that determines whether the user data blocks of a volume in a FabricPool will be tiered to the cloud store when they become cold. FabricPool combines flash (performance tier) with a cloud store into a single aggregate. Temperature of a volume block increases if it is accessed frequently and decreases when it is not. Valid in POST or PATCH.<br>all &dash; This policy allows tiering of both Snapshot copies and active file system user data to the cloud store as soon as possible by ignoring the temperature on the volume blocks.<br>auto &dash; This policy allows tiering of both snapshot and active file system user data to the cloud store<br>none &dash; Volume blocks will not be tiered to the cloud store.<br>snapshot_only &dash; This policy allows tiering of only the volume Snapshot copies not associated with the active file system. The default tiering policy is "snapshot-only" for a FlexVol and "none" for a FlexGroup. The default minimum cooling period for the "snapshot-only" tiering policy is 2 days and for the "auto" tiering policy is 31 days.
	// Enum: [all auto backup none snapshot_only]
	Policy string `json:"policy,omitempty"`

	// This parameter specifies whether or not FabricPools are selected when provisioning a FlexGroup without specifying "aggregates.name" or "aggregates.uuid". Only FabricPool aggregates are used if this parameter is set to true and only non FabricPool aggregates are used if this parameter is set to false. Tiering support for a FlexGroup can be changed by moving all of the constituents to the required aggregates. Note that in order to tier data, not only does the volume need to support tiering by using FabricPools, the tiering "policy" must not be 'none'. A volume that uses FabricPools but has a tiering "policy" of 'none' supports tiering, but will not tier any data.
	Supported *bool `json:"supported,omitempty"`
}

// Validate validates this volume tiering
func (m *VolumeTiering) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMinCoolingDays(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VolumeTiering) validateMinCoolingDays(formats strfmt.Registry) error {
	if swag.IsZero(m.MinCoolingDays) { // not required
		return nil
	}

	if err := validate.MinimumInt("tiering"+"."+"min_cooling_days", "body", m.MinCoolingDays, 2, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("tiering"+"."+"min_cooling_days", "body", m.MinCoolingDays, 183, false); err != nil {
		return err
	}

	return nil
}

func (m *VolumeTiering) validateObjectTags(formats strfmt.Registry) error {
	if swag.IsZero(m.ObjectTags) { // not required
		return nil
	}

	iObjectTagsSize := int64(len(m.ObjectTags))

	if err := validate.MinItems("tiering"+"."+"object_tags", "body", iObjectTagsSize, 0); err != nil {
		return err
	}

	if err := validate.MaxItems("tiering"+"."+"object_tags", "body", iObjectTagsSize, 4); err != nil {
		return err
	}

	if err := validate.UniqueItems("tiering"+"."+"object_tags", "body", m.ObjectTags); err != nil {
		return err
	}

	for i := 0; i < len(m.ObjectTags); i++ {

		if err := validate.MaxLength("tiering"+"."+"object_tags"+"."+strconv.Itoa(i), "body", m.ObjectTags[i], 257); err != nil {
			return err
		}

		if err := validate.Pattern("tiering"+"."+"object_tags"+"."+strconv.Itoa(i), "body", m.ObjectTags[i], `[_a-zA-Z][_a-zA-Z0-9]{0,126}=[_a-zA-Z0-9]{1,127}`); err != nil {
			return err
		}

	}

	return nil
}

var volumeTieringTypePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","auto","backup","none","snapshot_only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		volumeTieringTypePolicyPropEnum = append(volumeTieringTypePolicyPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// VolumeTiering
	// VolumeTiering
	// policy
	// Policy
	// all
	// END DEBUGGING
	// VolumeTieringPolicyAll captures enum value "all"
	VolumeTieringPolicyAll string = "all"

	// BEGIN DEBUGGING
	// VolumeTiering
	// VolumeTiering
	// policy
	// Policy
	// auto
	// END DEBUGGING
	// VolumeTieringPolicyAuto captures enum value "auto"
	VolumeTieringPolicyAuto string = "auto"

	// BEGIN DEBUGGING
	// VolumeTiering
	// VolumeTiering
	// policy
	// Policy
	// backup
	// END DEBUGGING
	// VolumeTieringPolicyBackup captures enum value "backup"
	VolumeTieringPolicyBackup string = "backup"

	// BEGIN DEBUGGING
	// VolumeTiering
	// VolumeTiering
	// policy
	// Policy
	// none
	// END DEBUGGING
	// VolumeTieringPolicyNone captures enum value "none"
	VolumeTieringPolicyNone string = "none"

	// BEGIN DEBUGGING
	// VolumeTiering
	// VolumeTiering
	// policy
	// Policy
	// snapshot_only
	// END DEBUGGING
	// VolumeTieringPolicySnapshotOnly captures enum value "snapshot_only"
	VolumeTieringPolicySnapshotOnly string = "snapshot_only"
)

// prop value enum
func (m *VolumeTiering) validatePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, volumeTieringTypePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VolumeTiering) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyEnum("tiering"+"."+"policy", "body", m.Policy); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this volume tiering based on context it is used
func (m *VolumeTiering) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VolumeTiering) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VolumeTiering) UnmarshalBinary(b []byte) error {
	var res VolumeTiering
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

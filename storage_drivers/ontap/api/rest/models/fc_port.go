// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FcPort A Fibre Channel (FC) port is the physical port of an FC adapter on an ONTAP cluster node that can be connected to an FC network to provide FC network connectivity. An FC port defines the location of an FC interface within the ONTAP cluster.
//
//
// swagger:model fc_port
type FcPort struct {

	// links
	Links *FcPortLinks `json:"_links,omitempty"`

	// A description of the FC port.
	//
	// Example: Fibre Channel Target Adapter 0a (ACME Fibre Channel Adapter, rev. 1.0.0, 8G)
	// Read Only: true
	Description string `json:"description,omitempty"`

	// The administrative state of the FC port. If this property is set to _false_, all FC connectivity to FC interfaces are blocked. Optional in PATCH.
	//
	Enabled bool `json:"enabled,omitempty"`

	// fabric
	Fabric *FcPortFabric `json:"fabric,omitempty"`

	// metric
	Metric *FcPortMetric `json:"metric,omitempty"`

	// The FC port name.
	//
	// Example: 0a
	// Read Only: true
	Name string `json:"name,omitempty"`

	// node
	Node *FcPortNode `json:"node,omitempty"`

	// The physical network protocol of the FC port.
	//
	// Read Only: true
	// Enum: [fibre_channel ethernet]
	PhysicalProtocol string `json:"physical_protocol,omitempty"`

	// speed
	Speed *FcPortSpeed `json:"speed,omitempty"`

	// The operational state of the FC port.
	// - startup - The port is booting up.
	// - link_not_connected - The port has finished initialization, but a link with the fabric is not established.
	// - online - The port is initialized and a link with the fabric has been established.
	// - link_disconnected - The link was present at one point on this port but is currently not established.
	// - offlined_by_user - The port is administratively disabled.
	// - offlined_by_system - The port is set to offline by the system. This happens when the port encounters too many errors.
	// - node_offline - The state information for the port cannot be retrieved. The node is offline or inaccessible.
	//
	// Example: online
	// Read Only: true
	// Enum: [startup link_not_connected online link_disconnected offlined_by_user offlined_by_system node_offline unknown]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *FcPortStatistics `json:"statistics,omitempty"`

	// The network protocols supported by the FC port.
	//
	// Read Only: true
	SupportedProtocols []string `json:"supported_protocols,omitempty"`

	// transceiver
	Transceiver *FcPortTransceiver `json:"transceiver,omitempty"`

	// The unique identifier of the FC port.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// The base world wide node name (WWNN) for the FC port.
	//
	// Example: 20:00:00:50:56:b4:13:a8
	// Read Only: true
	Wwnn string `json:"wwnn,omitempty"`

	// The base world wide port name (WWPN) for the FC port.
	//
	// Example: 20:00:00:50:56:b4:13:a8
	// Read Only: true
	Wwpn string `json:"wwpn,omitempty"`
}

// Validate validates this fc port
func (m *FcPort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFabric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhysicalProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpeed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedProtocols(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransceiver(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) validateFabric(formats strfmt.Registry) error {
	if swag.IsZero(m.Fabric) { // not required
		return nil
	}

	if m.Fabric != nil {
		if err := m.Fabric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fabric")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

var fcPortTypePhysicalProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fibre_channel","ethernet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTypePhysicalProtocolPropEnum = append(fcPortTypePhysicalProtocolPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// physical_protocol
	// PhysicalProtocol
	// fibre_channel
	// END DEBUGGING
	// FcPortPhysicalProtocolFibreChannel captures enum value "fibre_channel"
	FcPortPhysicalProtocolFibreChannel string = "fibre_channel"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// physical_protocol
	// PhysicalProtocol
	// ethernet
	// END DEBUGGING
	// FcPortPhysicalProtocolEthernet captures enum value "ethernet"
	FcPortPhysicalProtocolEthernet string = "ethernet"
)

// prop value enum
func (m *FcPort) validatePhysicalProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortTypePhysicalProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPort) validatePhysicalProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.PhysicalProtocol) { // not required
		return nil
	}

	// value enum
	if err := m.validatePhysicalProtocolEnum("physical_protocol", "body", m.PhysicalProtocol); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) validateSpeed(formats strfmt.Registry) error {
	if swag.IsZero(m.Speed) { // not required
		return nil
	}

	if m.Speed != nil {
		if err := m.Speed.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("speed")
			}
			return err
		}
	}

	return nil
}

var fcPortTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["startup","link_not_connected","online","link_disconnected","offlined_by_user","offlined_by_system","node_offline","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTypeStatePropEnum = append(fcPortTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// startup
	// END DEBUGGING
	// FcPortStateStartup captures enum value "startup"
	FcPortStateStartup string = "startup"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// link_not_connected
	// END DEBUGGING
	// FcPortStateLinkNotConnected captures enum value "link_not_connected"
	FcPortStateLinkNotConnected string = "link_not_connected"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// online
	// END DEBUGGING
	// FcPortStateOnline captures enum value "online"
	FcPortStateOnline string = "online"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// link_disconnected
	// END DEBUGGING
	// FcPortStateLinkDisconnected captures enum value "link_disconnected"
	FcPortStateLinkDisconnected string = "link_disconnected"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// offlined_by_user
	// END DEBUGGING
	// FcPortStateOfflinedByUser captures enum value "offlined_by_user"
	FcPortStateOfflinedByUser string = "offlined_by_user"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// offlined_by_system
	// END DEBUGGING
	// FcPortStateOfflinedBySystem captures enum value "offlined_by_system"
	FcPortStateOfflinedBySystem string = "offlined_by_system"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// node_offline
	// END DEBUGGING
	// FcPortStateNodeOffline captures enum value "node_offline"
	FcPortStateNodeOffline string = "node_offline"

	// BEGIN DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// unknown
	// END DEBUGGING
	// FcPortStateUnknown captures enum value "unknown"
	FcPortStateUnknown string = "unknown"
)

// prop value enum
func (m *FcPort) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPort) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

var fcPortSupportedProtocolsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fcp","fc_nvme"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortSupportedProtocolsItemsEnum = append(fcPortSupportedProtocolsItemsEnum, v)
	}
}

func (m *FcPort) validateSupportedProtocolsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortSupportedProtocolsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPort) validateSupportedProtocols(formats strfmt.Registry) error {
	if swag.IsZero(m.SupportedProtocols) { // not required
		return nil
	}

	for i := 0; i < len(m.SupportedProtocols); i++ {

		// value enum
		if err := m.validateSupportedProtocolsItemsEnum("supported_protocols"+"."+strconv.Itoa(i), "body", m.SupportedProtocols[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *FcPort) validateTransceiver(formats strfmt.Registry) error {
	if swag.IsZero(m.Transceiver) { // not required
		return nil
	}

	if m.Transceiver != nil {
		if err := m.Transceiver.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transceiver")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port based on the context it is used
func (m *FcPort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFabric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalProtocol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpeed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupportedProtocols(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransceiver(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWwnn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWwpn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateFabric(ctx context.Context, formats strfmt.Registry) error {

	if m.Fabric != nil {
		if err := m.Fabric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fabric")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidatePhysicalProtocol(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "physical_protocol", "body", string(m.PhysicalProtocol)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateSpeed(ctx context.Context, formats strfmt.Registry) error {

	if m.Speed != nil {
		if err := m.Speed.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("speed")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateSupportedProtocols(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "supported_protocols", "body", []string(m.SupportedProtocols)); err != nil {
		return err
	}

	for i := 0; i < len(m.SupportedProtocols); i++ {

		if err := validate.ReadOnly(ctx, "supported_protocols"+"."+strconv.Itoa(i), "body", string(m.SupportedProtocols[i])); err != nil {
			return err
		}

	}

	return nil
}

func (m *FcPort) contextValidateTransceiver(ctx context.Context, formats strfmt.Registry) error {

	if m.Transceiver != nil {
		if err := m.Transceiver.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transceiver")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateWwnn(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "wwnn", "body", string(m.Wwnn)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateWwpn(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "wwpn", "body", string(m.Wwpn)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPort) UnmarshalBinary(b []byte) error {
	var res FcPort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortFabric Properties of the fabric to which the FC port is attached.
//
//
// swagger:model FcPortFabric
type FcPortFabric struct {

	// Reports if the physical port has established a connection with the FC fabric.
	//
	// Read Only: true
	Connected *bool `json:"connected,omitempty"`

	// The negotiated data rate between the target FC port and the fabric in gigabits per second.
	//
	// Example: 16
	// Read Only: true
	ConnectedSpeed int64 `json:"connected_speed,omitempty"`

	// The name of the fabric to which the port is connected. This is only available when the FC port is connected to a fabric.<br/>
	// There is an added cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The FC port address of the host bus adapter (HBA) physical port.<br/>
	// Each FC port in an FC switched fabric has its own unique FC port address for routing purposes. The FC port address is assigned by a switch in the fabric when that port logs in to the fabric. This property refers to the FC port address given to the physical host bus adapter (HBA) port when the port performs a fabric login (FLOGI).<br/>
	// This is useful for obtaining statistics and diagnostic information from FC switches.<br/>
	// This is a six-digit hexadecimal encoded numeric value.
	//
	// Example: 52100A
	// Read Only: true
	PortAddress string `json:"port_address,omitempty"`

	// The switch port to which the FC port is connected.
	//
	// Example: ssan-g620-03:33
	// Read Only: true
	SwitchPort string `json:"switch_port,omitempty"`
}

// Validate validates this fc port fabric
func (m *FcPortFabric) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port fabric based on the context it is used
func (m *FcPortFabric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConnected(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectedSpeed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePortAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSwitchPort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortFabric) contextValidateConnected(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"connected", "body", m.Connected); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidateConnectedSpeed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"connected_speed", "body", int64(m.ConnectedSpeed)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidatePortAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"port_address", "body", string(m.PortAddress)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidateSwitchPort(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"switch_port", "body", string(m.SwitchPort)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortFabric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortFabric) UnmarshalBinary(b []byte) error {
	var res FcPortFabric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortLinks fc port links
//
// swagger:model FcPortLinks
type FcPortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc port links
func (m *FcPortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port links based on the context it is used
func (m *FcPortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortLinks) UnmarshalBinary(b []byte) error {
	var res FcPortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortMetric Performance numbers, such as IOPS latency and throughput
//
// swagger:model FcPortMetric
type FcPortMetric struct {

	// links
	Links *FcPortMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *FcPortMetricIops `json:"iops,omitempty"`

	// latency
	Latency *FcPortMetricLatency `json:"latency,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *FcPortMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this fc port metric
func (m *FcPortMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var fcPortMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortMetricTypeDurationPropEnum = append(fcPortMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// FcPortMetricDurationPT15S captures enum value "PT15S"
	FcPortMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// FcPortMetricDurationPT4M captures enum value "PT4M"
	FcPortMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// FcPortMetricDurationPT30M captures enum value "PT30M"
	FcPortMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// FcPortMetricDurationPT2H captures enum value "PT2H"
	FcPortMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// FcPortMetricDurationP1D captures enum value "P1D"
	FcPortMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// FcPortMetricDurationPT5M captures enum value "PT5M"
	FcPortMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *FcPortMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *FcPortMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var fcPortMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortMetricTypeStatusPropEnum = append(fcPortMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// FcPortMetricStatusOk captures enum value "ok"
	FcPortMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// FcPortMetricStatusError captures enum value "error"
	FcPortMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// FcPortMetricStatusPartialNoData captures enum value "partial_no_data"
	FcPortMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// FcPortMetricStatusPartialNoResponse captures enum value "partial_no_response"
	FcPortMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// FcPortMetricStatusPartialOtherError captures enum value "partial_other_error"
	FcPortMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// FcPortMetricStatusNegativeDelta captures enum value "negative_delta"
	FcPortMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// not_found
	// END DEBUGGING
	// FcPortMetricStatusNotFound captures enum value "not_found"
	FcPortMetricStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// FcPortMetricStatusBackfilledData captures enum value "backfilled_data"
	FcPortMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// FcPortMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	FcPortMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// FcPortMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	FcPortMetricStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// FcPortMetric
	// FcPortMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// FcPortMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	FcPortMetricStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *FcPortMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *FcPortMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc port metric based on the context it is used
func (m *FcPortMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortMetric) UnmarshalBinary(b []byte) error {
	var res FcPortMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model FcPortMetricIops
type FcPortMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc port metric iops
func (m *FcPortMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port metric iops based on the context it is used
func (m *FcPortMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcPortMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortMetricIops) UnmarshalBinary(b []byte) error {
	var res FcPortMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model FcPortMetricLatency
type FcPortMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc port metric latency
func (m *FcPortMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port metric latency based on the context it is used
func (m *FcPortMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcPortMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortMetricLatency) UnmarshalBinary(b []byte) error {
	var res FcPortMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortMetricLinks fc port metric links
//
// swagger:model FcPortMetricLinks
type FcPortMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc port metric links
func (m *FcPortMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port metric links based on the context it is used
func (m *FcPortMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortMetricLinks) UnmarshalBinary(b []byte) error {
	var res FcPortMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model FcPortMetricThroughput
type FcPortMetricThroughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc port metric throughput
func (m *FcPortMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port metric throughput based on the context it is used
func (m *FcPortMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcPortMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortMetricThroughput) UnmarshalBinary(b []byte) error {
	var res FcPortMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortNode fc port node
//
// swagger:model FcPortNode
type FcPortNode struct {

	// links
	Links *FcPortNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this fc port node
func (m *FcPortNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port node based on the context it is used
func (m *FcPortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortNode) UnmarshalBinary(b []byte) error {
	var res FcPortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortNodeLinks fc port node links
//
// swagger:model FcPortNodeLinks
type FcPortNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc port node links
func (m *FcPortNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port node links based on the context it is used
func (m *FcPortNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortNodeLinks) UnmarshalBinary(b []byte) error {
	var res FcPortNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortSpeed The physical device speed related properties of the FC port.
//
//
// swagger:model FcPortSpeed
type FcPortSpeed struct {

	// The configured speed of the FC port in gigabits per second.
	//
	// Example: auto
	// Read Only: true
	// Enum: [1 2 4 8 10 16 32 auto]
	Configured string `json:"configured,omitempty"`

	// The maximum speed supported by the FC port in gigabits per second.
	//
	// Example: 32
	// Read Only: true
	// Enum: [1 2 4 8 10 16 32 auto]
	Maximum string `json:"maximum,omitempty"`
}

// Validate validates this fc port speed
func (m *FcPortSpeed) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConfigured(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaximum(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var fcPortSpeedTypeConfiguredPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["1","2","4","8","10","16","32","auto"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortSpeedTypeConfiguredPropEnum = append(fcPortSpeedTypeConfiguredPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 1
	// END DEBUGGING
	// FcPortSpeedConfiguredNr1 captures enum value "1"
	FcPortSpeedConfiguredNr1 string = "1"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 2
	// END DEBUGGING
	// FcPortSpeedConfiguredNr2 captures enum value "2"
	FcPortSpeedConfiguredNr2 string = "2"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 4
	// END DEBUGGING
	// FcPortSpeedConfiguredNr4 captures enum value "4"
	FcPortSpeedConfiguredNr4 string = "4"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 8
	// END DEBUGGING
	// FcPortSpeedConfiguredNr8 captures enum value "8"
	FcPortSpeedConfiguredNr8 string = "8"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 10
	// END DEBUGGING
	// FcPortSpeedConfiguredNr10 captures enum value "10"
	FcPortSpeedConfiguredNr10 string = "10"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 16
	// END DEBUGGING
	// FcPortSpeedConfiguredNr16 captures enum value "16"
	FcPortSpeedConfiguredNr16 string = "16"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 32
	// END DEBUGGING
	// FcPortSpeedConfiguredNr32 captures enum value "32"
	FcPortSpeedConfiguredNr32 string = "32"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// auto
	// END DEBUGGING
	// FcPortSpeedConfiguredAuto captures enum value "auto"
	FcPortSpeedConfiguredAuto string = "auto"
)

// prop value enum
func (m *FcPortSpeed) validateConfiguredEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortSpeedTypeConfiguredPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortSpeed) validateConfigured(formats strfmt.Registry) error {
	if swag.IsZero(m.Configured) { // not required
		return nil
	}

	// value enum
	if err := m.validateConfiguredEnum("speed"+"."+"configured", "body", m.Configured); err != nil {
		return err
	}

	return nil
}

var fcPortSpeedTypeMaximumPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["1","2","4","8","10","16","32","auto"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortSpeedTypeMaximumPropEnum = append(fcPortSpeedTypeMaximumPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 1
	// END DEBUGGING
	// FcPortSpeedMaximumNr1 captures enum value "1"
	FcPortSpeedMaximumNr1 string = "1"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 2
	// END DEBUGGING
	// FcPortSpeedMaximumNr2 captures enum value "2"
	FcPortSpeedMaximumNr2 string = "2"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 4
	// END DEBUGGING
	// FcPortSpeedMaximumNr4 captures enum value "4"
	FcPortSpeedMaximumNr4 string = "4"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 8
	// END DEBUGGING
	// FcPortSpeedMaximumNr8 captures enum value "8"
	FcPortSpeedMaximumNr8 string = "8"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 10
	// END DEBUGGING
	// FcPortSpeedMaximumNr10 captures enum value "10"
	FcPortSpeedMaximumNr10 string = "10"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 16
	// END DEBUGGING
	// FcPortSpeedMaximumNr16 captures enum value "16"
	FcPortSpeedMaximumNr16 string = "16"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 32
	// END DEBUGGING
	// FcPortSpeedMaximumNr32 captures enum value "32"
	FcPortSpeedMaximumNr32 string = "32"

	// BEGIN DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// auto
	// END DEBUGGING
	// FcPortSpeedMaximumAuto captures enum value "auto"
	FcPortSpeedMaximumAuto string = "auto"
)

// prop value enum
func (m *FcPortSpeed) validateMaximumEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortSpeedTypeMaximumPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortSpeed) validateMaximum(formats strfmt.Registry) error {
	if swag.IsZero(m.Maximum) { // not required
		return nil
	}

	// value enum
	if err := m.validateMaximumEnum("speed"+"."+"maximum", "body", m.Maximum); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc port speed based on the context it is used
func (m *FcPortSpeed) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConfigured(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaximum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortSpeed) contextValidateConfigured(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "speed"+"."+"configured", "body", string(m.Configured)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortSpeed) contextValidateMaximum(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "speed"+"."+"maximum", "body", string(m.Maximum)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortSpeed) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortSpeed) UnmarshalBinary(b []byte) error {
	var res FcPortSpeed
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortStatistics These are raw performance numbers, such as IOPS latency and throughput. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster.
//
// swagger:model FcPortStatistics
type FcPortStatistics struct {

	// iops raw
	IopsRaw *FcPortStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *FcPortStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, "ok" on success, or "error" on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *FcPortStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this fc port statistics
func (m *FcPortStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var fcPortStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortStatisticsTypeStatusPropEnum = append(fcPortStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// FcPortStatisticsStatusOk captures enum value "ok"
	FcPortStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// FcPortStatisticsStatusError captures enum value "error"
	FcPortStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// FcPortStatisticsStatusPartialNoData captures enum value "partial_no_data"
	FcPortStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// FcPortStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	FcPortStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// FcPortStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	FcPortStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// FcPortStatisticsStatusNegativeDelta captures enum value "negative_delta"
	FcPortStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// not_found
	// END DEBUGGING
	// FcPortStatisticsStatusNotFound captures enum value "not_found"
	FcPortStatisticsStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// FcPortStatisticsStatusBackfilledData captures enum value "backfilled_data"
	FcPortStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// FcPortStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	FcPortStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// FcPortStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	FcPortStatisticsStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// FcPortStatistics
	// FcPortStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// FcPortStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	FcPortStatisticsStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *FcPortStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *FcPortStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc port statistics based on the context it is used
func (m *FcPortStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *FcPortStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortStatistics) UnmarshalBinary(b []byte) error {
	var res FcPortStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortStatisticsIopsRaw The number of I/O operations observed at the storage object. This should be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model FcPortStatisticsIopsRaw
type FcPortStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc port statistics iops raw
func (m *FcPortStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port statistics iops raw based on the context it is used
func (m *FcPortStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcPortStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res FcPortStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This should be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model FcPortStatisticsLatencyRaw
type FcPortStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc port statistics latency raw
func (m *FcPortStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port statistics latency raw based on the context it is used
func (m *FcPortStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcPortStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res FcPortStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortStatisticsThroughputRaw Throughput bytes observed at the storage object. This should be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model FcPortStatisticsThroughputRaw
type FcPortStatisticsThroughputRaw struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this fc port statistics throughput raw
func (m *FcPortStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port statistics throughput raw based on the context it is used
func (m *FcPortStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *FcPortStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res FcPortStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortTransceiver Properties of the transceiver connected to the FC port.
//
//
// swagger:model FcPortTransceiver
type FcPortTransceiver struct {

	// The speeds of which the transceiver is capable in gigabits per second.
	//
	// Read Only: true
	Capabilities []int64 `json:"capabilities,omitempty"`

	// The form factor of the transceiver. Possible values are:
	// - _sfp_ - Small Form Factor - Pluggable
	// - _sff_ - Small Form Factor
	// - _unknown_ - Unknown
	//
	// Read Only: true
	// Enum: [sfp sff unknown]
	FormFactor string `json:"form_factor,omitempty"`

	// The manufacturer of the transceiver.
	//
	// Example: Acme, Inc.
	// Read Only: true
	Manufacturer string `json:"manufacturer,omitempty"`

	// The part number of the transceiver.
	// Read Only: true
	PartNumber string `json:"part_number,omitempty"`
}

// Validate validates this fc port transceiver
func (m *FcPortTransceiver) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCapabilities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormFactor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var fcPortTransceiverCapabilitiesItemsEnum []interface{}

func init() {
	var res []int64
	if err := json.Unmarshal([]byte(`[1,2,4,8,10,16,32]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTransceiverCapabilitiesItemsEnum = append(fcPortTransceiverCapabilitiesItemsEnum, v)
	}
}

func (m *FcPortTransceiver) validateCapabilitiesItemsEnum(path, location string, value int64) error {
	if err := validate.EnumCase(path, location, value, fcPortTransceiverCapabilitiesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortTransceiver) validateCapabilities(formats strfmt.Registry) error {
	if swag.IsZero(m.Capabilities) { // not required
		return nil
	}

	for i := 0; i < len(m.Capabilities); i++ {

		// value enum
		if err := m.validateCapabilitiesItemsEnum("transceiver"+"."+"capabilities"+"."+strconv.Itoa(i), "body", m.Capabilities[i]); err != nil {
			return err
		}

	}

	return nil
}

var fcPortTransceiverTypeFormFactorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["sfp","sff","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTransceiverTypeFormFactorPropEnum = append(fcPortTransceiverTypeFormFactorPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// FcPortTransceiver
	// FcPortTransceiver
	// form_factor
	// FormFactor
	// sfp
	// END DEBUGGING
	// FcPortTransceiverFormFactorSfp captures enum value "sfp"
	FcPortTransceiverFormFactorSfp string = "sfp"

	// BEGIN DEBUGGING
	// FcPortTransceiver
	// FcPortTransceiver
	// form_factor
	// FormFactor
	// sff
	// END DEBUGGING
	// FcPortTransceiverFormFactorSff captures enum value "sff"
	FcPortTransceiverFormFactorSff string = "sff"

	// BEGIN DEBUGGING
	// FcPortTransceiver
	// FcPortTransceiver
	// form_factor
	// FormFactor
	// unknown
	// END DEBUGGING
	// FcPortTransceiverFormFactorUnknown captures enum value "unknown"
	FcPortTransceiverFormFactorUnknown string = "unknown"
)

// prop value enum
func (m *FcPortTransceiver) validateFormFactorEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortTransceiverTypeFormFactorPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortTransceiver) validateFormFactor(formats strfmt.Registry) error {
	if swag.IsZero(m.FormFactor) { // not required
		return nil
	}

	// value enum
	if err := m.validateFormFactorEnum("transceiver"+"."+"form_factor", "body", m.FormFactor); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc port transceiver based on the context it is used
func (m *FcPortTransceiver) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapabilities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormFactor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManufacturer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortTransceiver) contextValidateCapabilities(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"capabilities", "body", []int64(m.Capabilities)); err != nil {
		return err
	}

	for i := 0; i < len(m.Capabilities); i++ {

		if err := validate.ReadOnly(ctx, "transceiver"+"."+"capabilities"+"."+strconv.Itoa(i), "body", int64(m.Capabilities[i])); err != nil {
			return err
		}

	}

	return nil
}

func (m *FcPortTransceiver) contextValidateFormFactor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"form_factor", "body", string(m.FormFactor)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortTransceiver) contextValidateManufacturer(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"manufacturer", "body", string(m.Manufacturer)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortTransceiver) contextValidatePartNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"part_number", "body", string(m.PartNumber)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortTransceiver) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortTransceiver) UnmarshalBinary(b []byte) error {
	var res FcPortTransceiver
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

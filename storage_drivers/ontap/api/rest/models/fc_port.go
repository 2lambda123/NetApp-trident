// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FcPort A Fibre Channel (FC) port is the physical port of an FC adapter on an ONTAP cluster node that can be connected to an FC network to provide FC network connectivity. An FC port defines the location of an FC interface within the ONTAP cluster.
//
//
// swagger:model fc_port
type FcPort struct {

	// links
	Links *FcPortLinks `json:"_links,omitempty"`

	// A description of the FC port.
	//
	// Example: Fibre Channel Target Adapter 0a (ACME Fibre Channel Adapter, rev. 1.0.0, 8G)
	// Read Only: true
	Description string `json:"description,omitempty"`

	// The administrative state of the FC port. If this property is set to _false_, all FC connectivity to FC interfaces are blocked. Optional in PATCH.
	//
	Enabled bool `json:"enabled,omitempty"`

	// fabric
	Fabric *FcPortFabric `json:"fabric,omitempty"`

	// The FC port name.
	//
	// Example: 0a
	// Read Only: true
	Name string `json:"name,omitempty"`

	// node
	Node *FcPortNode `json:"node,omitempty"`

	// The physical network protocol of the FC port.
	//
	// Read Only: true
	// Enum: [fibre_channel ethernet]
	PhysicalProtocol string `json:"physical_protocol,omitempty"`

	// speed
	Speed *FcPortSpeed `json:"speed,omitempty"`

	// The operational state of the FC port.
	// - startup - The port is booting up.
	// - link_not_connected - The port has finished initialization, but a link with the fabric is not established.
	// - online - The port is initialized and a link with the fabric has been established.
	// - link_disconnected - The link was present at one point on this port but is currently not established.
	// - offlined_by_user - The port is administratively disabled.
	// - offlined_by_system - The port is set to offline by the system. This happens when the port encounters too many errors.
	// - node_offline - The state information for the port cannot be retrieved. The node is offline or inaccessible.
	//
	// Example: online
	// Read Only: true
	// Enum: [startup link_not_connected online link_disconnected offlined_by_user offlined_by_system node_offline unknown]
	State string `json:"state,omitempty"`

	// The network protocols supported by the FC port.
	//
	// Read Only: true
	SupportedProtocols []string `json:"supported_protocols,omitempty"`

	// transceiver
	Transceiver *FcPortTransceiver `json:"transceiver,omitempty"`

	// The unique identifier of the FC port.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// The base world wide node name (WWNN) for the FC port.
	//
	// Example: 20:00:00:50:56:b4:13:a8
	// Read Only: true
	Wwnn string `json:"wwnn,omitempty"`

	// The base world wide port name (WWPN) for the FC port.
	//
	// Example: 20:00:00:50:56:b4:13:a8
	// Read Only: true
	Wwpn string `json:"wwpn,omitempty"`
}

// Validate validates this fc port
func (m *FcPort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFabric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhysicalProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpeed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedProtocols(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransceiver(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) validateFabric(formats strfmt.Registry) error {
	if swag.IsZero(m.Fabric) { // not required
		return nil
	}

	if m.Fabric != nil {
		if err := m.Fabric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fabric")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

var fcPortTypePhysicalProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fibre_channel","ethernet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTypePhysicalProtocolPropEnum = append(fcPortTypePhysicalProtocolPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// physical_protocol
	// PhysicalProtocol
	// fibre_channel
	// END RIPPY DEBUGGING
	// FcPortPhysicalProtocolFibreChannel captures enum value "fibre_channel"
	FcPortPhysicalProtocolFibreChannel string = "fibre_channel"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// physical_protocol
	// PhysicalProtocol
	// ethernet
	// END RIPPY DEBUGGING
	// FcPortPhysicalProtocolEthernet captures enum value "ethernet"
	FcPortPhysicalProtocolEthernet string = "ethernet"
)

// prop value enum
func (m *FcPort) validatePhysicalProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortTypePhysicalProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPort) validatePhysicalProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.PhysicalProtocol) { // not required
		return nil
	}

	// value enum
	if err := m.validatePhysicalProtocolEnum("physical_protocol", "body", m.PhysicalProtocol); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) validateSpeed(formats strfmt.Registry) error {
	if swag.IsZero(m.Speed) { // not required
		return nil
	}

	if m.Speed != nil {
		if err := m.Speed.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("speed")
			}
			return err
		}
	}

	return nil
}

var fcPortTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["startup","link_not_connected","online","link_disconnected","offlined_by_user","offlined_by_system","node_offline","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTypeStatePropEnum = append(fcPortTypeStatePropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// startup
	// END RIPPY DEBUGGING
	// FcPortStateStartup captures enum value "startup"
	FcPortStateStartup string = "startup"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// link_not_connected
	// END RIPPY DEBUGGING
	// FcPortStateLinkNotConnected captures enum value "link_not_connected"
	FcPortStateLinkNotConnected string = "link_not_connected"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// online
	// END RIPPY DEBUGGING
	// FcPortStateOnline captures enum value "online"
	FcPortStateOnline string = "online"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// link_disconnected
	// END RIPPY DEBUGGING
	// FcPortStateLinkDisconnected captures enum value "link_disconnected"
	FcPortStateLinkDisconnected string = "link_disconnected"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// offlined_by_user
	// END RIPPY DEBUGGING
	// FcPortStateOfflinedByUser captures enum value "offlined_by_user"
	FcPortStateOfflinedByUser string = "offlined_by_user"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// offlined_by_system
	// END RIPPY DEBUGGING
	// FcPortStateOfflinedBySystem captures enum value "offlined_by_system"
	FcPortStateOfflinedBySystem string = "offlined_by_system"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// node_offline
	// END RIPPY DEBUGGING
	// FcPortStateNodeOffline captures enum value "node_offline"
	FcPortStateNodeOffline string = "node_offline"

	// BEGIN RIPPY DEBUGGING
	// fc_port
	// FcPort
	// state
	// State
	// unknown
	// END RIPPY DEBUGGING
	// FcPortStateUnknown captures enum value "unknown"
	FcPortStateUnknown string = "unknown"
)

// prop value enum
func (m *FcPort) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPort) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var fcPortSupportedProtocolsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fcp","fc_nvme"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortSupportedProtocolsItemsEnum = append(fcPortSupportedProtocolsItemsEnum, v)
	}
}

func (m *FcPort) validateSupportedProtocolsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortSupportedProtocolsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPort) validateSupportedProtocols(formats strfmt.Registry) error {
	if swag.IsZero(m.SupportedProtocols) { // not required
		return nil
	}

	for i := 0; i < len(m.SupportedProtocols); i++ {

		// value enum
		if err := m.validateSupportedProtocolsItemsEnum("supported_protocols"+"."+strconv.Itoa(i), "body", m.SupportedProtocols[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *FcPort) validateTransceiver(formats strfmt.Registry) error {
	if swag.IsZero(m.Transceiver) { // not required
		return nil
	}

	if m.Transceiver != nil {
		if err := m.Transceiver.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transceiver")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port based on the context it is used
func (m *FcPort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFabric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalProtocol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpeed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupportedProtocols(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransceiver(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWwnn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWwpn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateDescription(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateFabric(ctx context.Context, formats strfmt.Registry) error {

	if m.Fabric != nil {
		if err := m.Fabric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fabric")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidatePhysicalProtocol(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "physical_protocol", "body", string(m.PhysicalProtocol)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateSpeed(ctx context.Context, formats strfmt.Registry) error {

	if m.Speed != nil {
		if err := m.Speed.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("speed")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateSupportedProtocols(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "supported_protocols", "body", []string(m.SupportedProtocols)); err != nil {
		return err
	}

	for i := 0; i < len(m.SupportedProtocols); i++ {

		if err := validate.ReadOnly(ctx, "supported_protocols"+"."+strconv.Itoa(i), "body", string(m.SupportedProtocols[i])); err != nil {
			return err
		}

	}

	return nil
}

func (m *FcPort) contextValidateTransceiver(ctx context.Context, formats strfmt.Registry) error {

	if m.Transceiver != nil {
		if err := m.Transceiver.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transceiver")
			}
			return err
		}
	}

	return nil
}

func (m *FcPort) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateWwnn(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "wwnn", "body", string(m.Wwnn)); err != nil {
		return err
	}

	return nil
}

func (m *FcPort) contextValidateWwpn(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "wwpn", "body", string(m.Wwpn)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPort) UnmarshalBinary(b []byte) error {
	var res FcPort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortFabric Properties of the fabric to which the FC port is attached.
//
//
// swagger:model FcPortFabric
type FcPortFabric struct {

	// Reports if the physical port has established a connection with the FC fabric.
	//
	// Read Only: true
	Connected *bool `json:"connected,omitempty"`

	// The negotiated data rate between the target FC port and the fabric in gigabits per second.
	//
	// Example: 16
	// Read Only: true
	ConnectedSpeed int64 `json:"connected_speed,omitempty"`

	// The name of the fabric to which the port is connected. This is only available when the FC port is connected to a fabric.<br/>
	// There is an added cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
	//
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The FC port address of the host bus adapter (HBA) physical port.<br/>
	// Each FC port in an FC switched fabric has its own unique FC port address for routing purposes. The FC port address is assigned by a switch in the fabric when that port logs in to the fabric. This property refers to the FC port address given to the physical host bus adapter (HBA) port when the port performs a fabric login (FLOGI).<br/>
	// This is useful for obtaining statistics and diagnostic information from FC switches.<br/>
	// This is a six-digit hexadecimal encoded numeric value.
	//
	// Example: 52100A
	// Read Only: true
	PortAddress string `json:"port_address,omitempty"`

	// The switch port to which the FC port is connected.
	//
	// Example: ssan-g620-03:33
	// Read Only: true
	SwitchPort string `json:"switch_port,omitempty"`
}

// Validate validates this fc port fabric
func (m *FcPortFabric) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this fc port fabric based on the context it is used
func (m *FcPortFabric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConnected(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectedSpeed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePortAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSwitchPort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortFabric) contextValidateConnected(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"connected", "body", m.Connected); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidateConnectedSpeed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"connected_speed", "body", int64(m.ConnectedSpeed)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidatePortAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"port_address", "body", string(m.PortAddress)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortFabric) contextValidateSwitchPort(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fabric"+"."+"switch_port", "body", string(m.SwitchPort)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortFabric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortFabric) UnmarshalBinary(b []byte) error {
	var res FcPortFabric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortLinks fc port links
//
// swagger:model FcPortLinks
type FcPortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc port links
func (m *FcPortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port links based on the context it is used
func (m *FcPortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortLinks) UnmarshalBinary(b []byte) error {
	var res FcPortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortNode fc port node
//
// swagger:model FcPortNode
type FcPortNode struct {

	// links
	Links *FcPortNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this fc port node
func (m *FcPortNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port node based on the context it is used
func (m *FcPortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortNode) UnmarshalBinary(b []byte) error {
	var res FcPortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortNodeLinks fc port node links
//
// swagger:model FcPortNodeLinks
type FcPortNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this fc port node links
func (m *FcPortNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this fc port node links based on the context it is used
func (m *FcPortNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortNodeLinks) UnmarshalBinary(b []byte) error {
	var res FcPortNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortSpeed The physical device speed related properties of the FC port.
//
//
// swagger:model FcPortSpeed
type FcPortSpeed struct {

	// The configured speed of the FC port in gigabits per second.
	//
	// Example: auto
	// Read Only: true
	// Enum: [1 2 4 8 10 16 32 auto]
	Configured string `json:"configured,omitempty"`

	// The maximum speed supported by the FC port in gigabits per second.
	//
	// Example: 32
	// Read Only: true
	// Enum: [1 2 4 8 10 16 32 auto]
	Maximum string `json:"maximum,omitempty"`
}

// Validate validates this fc port speed
func (m *FcPortSpeed) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConfigured(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaximum(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var fcPortSpeedTypeConfiguredPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["1","2","4","8","10","16","32","auto"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortSpeedTypeConfiguredPropEnum = append(fcPortSpeedTypeConfiguredPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 1
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredNr1 captures enum value "1"
	FcPortSpeedConfiguredNr1 string = "1"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 2
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredNr2 captures enum value "2"
	FcPortSpeedConfiguredNr2 string = "2"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 4
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredNr4 captures enum value "4"
	FcPortSpeedConfiguredNr4 string = "4"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 8
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredNr8 captures enum value "8"
	FcPortSpeedConfiguredNr8 string = "8"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 10
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredNr10 captures enum value "10"
	FcPortSpeedConfiguredNr10 string = "10"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 16
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredNr16 captures enum value "16"
	FcPortSpeedConfiguredNr16 string = "16"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// 32
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredNr32 captures enum value "32"
	FcPortSpeedConfiguredNr32 string = "32"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// configured
	// Configured
	// auto
	// END RIPPY DEBUGGING
	// FcPortSpeedConfiguredAuto captures enum value "auto"
	FcPortSpeedConfiguredAuto string = "auto"
)

// prop value enum
func (m *FcPortSpeed) validateConfiguredEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortSpeedTypeConfiguredPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortSpeed) validateConfigured(formats strfmt.Registry) error {
	if swag.IsZero(m.Configured) { // not required
		return nil
	}

	// value enum
	if err := m.validateConfiguredEnum("speed"+"."+"configured", "body", m.Configured); err != nil {
		return err
	}

	return nil
}

var fcPortSpeedTypeMaximumPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["1","2","4","8","10","16","32","auto"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortSpeedTypeMaximumPropEnum = append(fcPortSpeedTypeMaximumPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 1
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumNr1 captures enum value "1"
	FcPortSpeedMaximumNr1 string = "1"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 2
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumNr2 captures enum value "2"
	FcPortSpeedMaximumNr2 string = "2"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 4
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumNr4 captures enum value "4"
	FcPortSpeedMaximumNr4 string = "4"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 8
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumNr8 captures enum value "8"
	FcPortSpeedMaximumNr8 string = "8"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 10
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumNr10 captures enum value "10"
	FcPortSpeedMaximumNr10 string = "10"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 16
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumNr16 captures enum value "16"
	FcPortSpeedMaximumNr16 string = "16"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// 32
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumNr32 captures enum value "32"
	FcPortSpeedMaximumNr32 string = "32"

	// BEGIN RIPPY DEBUGGING
	// FcPortSpeed
	// FcPortSpeed
	// maximum
	// Maximum
	// auto
	// END RIPPY DEBUGGING
	// FcPortSpeedMaximumAuto captures enum value "auto"
	FcPortSpeedMaximumAuto string = "auto"
)

// prop value enum
func (m *FcPortSpeed) validateMaximumEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortSpeedTypeMaximumPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortSpeed) validateMaximum(formats strfmt.Registry) error {
	if swag.IsZero(m.Maximum) { // not required
		return nil
	}

	// value enum
	if err := m.validateMaximumEnum("speed"+"."+"maximum", "body", m.Maximum); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc port speed based on the context it is used
func (m *FcPortSpeed) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConfigured(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaximum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortSpeed) contextValidateConfigured(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "speed"+"."+"configured", "body", string(m.Configured)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortSpeed) contextValidateMaximum(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "speed"+"."+"maximum", "body", string(m.Maximum)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortSpeed) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortSpeed) UnmarshalBinary(b []byte) error {
	var res FcPortSpeed
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FcPortTransceiver Properties of the transceiver connected to the FC port.
//
//
// swagger:model FcPortTransceiver
type FcPortTransceiver struct {

	// The speeds of which the transceiver is capable in gigabits per second.
	//
	// Read Only: true
	Capabilities []int64 `json:"capabilities,omitempty"`

	// The form factor of the transceiver. Possible values are:
	// - _sfp_ - Small Form Factor - Pluggable
	// - _sff_ - Small Form Factor
	// - _unk_ - Unknown
	//
	// Read Only: true
	// Enum: [sfp sff unk]
	FormFactor string `json:"form-factor,omitempty"`

	// The manufacturer of the transceiver.
	//
	// Example: Acme, Inc.
	// Read Only: true
	Manufacturer string `json:"manufacturer,omitempty"`

	// The part number of the transceiver.
	// Read Only: true
	PartNumber string `json:"part_number,omitempty"`
}

// Validate validates this fc port transceiver
func (m *FcPortTransceiver) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCapabilities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormFactor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var fcPortTransceiverCapabilitiesItemsEnum []interface{}

func init() {
	var res []int64
	if err := json.Unmarshal([]byte(`[1,2,4,8,10,16,32]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTransceiverCapabilitiesItemsEnum = append(fcPortTransceiverCapabilitiesItemsEnum, v)
	}
}

func (m *FcPortTransceiver) validateCapabilitiesItemsEnum(path, location string, value int64) error {
	if err := validate.EnumCase(path, location, value, fcPortTransceiverCapabilitiesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortTransceiver) validateCapabilities(formats strfmt.Registry) error {
	if swag.IsZero(m.Capabilities) { // not required
		return nil
	}

	for i := 0; i < len(m.Capabilities); i++ {

		// value enum
		if err := m.validateCapabilitiesItemsEnum("transceiver"+"."+"capabilities"+"."+strconv.Itoa(i), "body", m.Capabilities[i]); err != nil {
			return err
		}

	}

	return nil
}

var fcPortTransceiverTypeFormFactorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["sfp","sff","unk"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fcPortTransceiverTypeFormFactorPropEnum = append(fcPortTransceiverTypeFormFactorPropEnum, v)
	}
}

const (

	// BEGIN RIPPY DEBUGGING
	// FcPortTransceiver
	// FcPortTransceiver
	// form-factor
	// FormFactor
	// sfp
	// END RIPPY DEBUGGING
	// FcPortTransceiverFormFactorSfp captures enum value "sfp"
	FcPortTransceiverFormFactorSfp string = "sfp"

	// BEGIN RIPPY DEBUGGING
	// FcPortTransceiver
	// FcPortTransceiver
	// form-factor
	// FormFactor
	// sff
	// END RIPPY DEBUGGING
	// FcPortTransceiverFormFactorSff captures enum value "sff"
	FcPortTransceiverFormFactorSff string = "sff"

	// BEGIN RIPPY DEBUGGING
	// FcPortTransceiver
	// FcPortTransceiver
	// form-factor
	// FormFactor
	// unk
	// END RIPPY DEBUGGING
	// FcPortTransceiverFormFactorUnk captures enum value "unk"
	FcPortTransceiverFormFactorUnk string = "unk"
)

// prop value enum
func (m *FcPortTransceiver) validateFormFactorEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fcPortTransceiverTypeFormFactorPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FcPortTransceiver) validateFormFactor(formats strfmt.Registry) error {
	if swag.IsZero(m.FormFactor) { // not required
		return nil
	}

	// value enum
	if err := m.validateFormFactorEnum("transceiver"+"."+"form-factor", "body", m.FormFactor); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this fc port transceiver based on the context it is used
func (m *FcPortTransceiver) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapabilities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormFactor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManufacturer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FcPortTransceiver) contextValidateCapabilities(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"capabilities", "body", []int64(m.Capabilities)); err != nil {
		return err
	}

	for i := 0; i < len(m.Capabilities); i++ {

		if err := validate.ReadOnly(ctx, "transceiver"+"."+"capabilities"+"."+strconv.Itoa(i), "body", int64(m.Capabilities[i])); err != nil {
			return err
		}

	}

	return nil
}

func (m *FcPortTransceiver) contextValidateFormFactor(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"form-factor", "body", string(m.FormFactor)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortTransceiver) contextValidateManufacturer(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"manufacturer", "body", string(m.Manufacturer)); err != nil {
		return err
	}

	return nil
}

func (m *FcPortTransceiver) contextValidatePartNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "transceiver"+"."+"part_number", "body", string(m.PartNumber)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FcPortTransceiver) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FcPortTransceiver) UnmarshalBinary(b []byte) error {
	var res FcPortTransceiver
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// HELLO RIPPY

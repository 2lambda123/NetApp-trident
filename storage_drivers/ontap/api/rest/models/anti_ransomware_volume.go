// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AntiRansomwareVolume Anti-ransomware properties of volumes.
//
// swagger:model anti_ransomware_volume
type AntiRansomwareVolume struct {

	// Probability of a ransomware attack.<br>`none` No files are suspected of ransomware activity.<br>`low` A number of files are suspected of ransomware activity.<br>`moderate` A moderate number of files are suspected of ransomware activity.<br>`high` A large number of files are suspected of ransomware activity.
	// Read Only: true
	// Enum: [none low moderate high]
	AttackProbability string `json:"attack_probability,omitempty"`

	// attack reports
	AttackReports []*AntiRansomwareAttackReport `json:"attack_reports,omitempty"`

	// Time when Anti-ransomware monitoring `state` is set to dry-run value for starting evaluation mode.
	// Read Only: true
	// Format: date-time
	DryRunStartTime *strfmt.DateTime `json:"dry_run_start_time,omitempty"`

	// space
	Space *AntiRansomwareVolumeSpace `json:"space,omitempty"`

	// Anti-ransomware state.<br>`disabled` Anti-ransomware monitoring is disabled on the volume.  This is the default state in a POST operation.<br>`disable_in_progress` Anti-ransomware monitoring is being disabled and a cleanup operation is in effect. Valid in GET operation.<br>`dry_run` Anti-ransomware monitoring is enabled in the evaluation mode.<br>`enabled` Anti-ransomware monitoring is active on the volume.<br>`paused` Anti-ransomware monitoring is paused on the volume.<br>`enable_paused` Anti-ransomware monitoring is paused on the volume from its earlier enabled state. Valid in GET operation. <br>`dry_run_paused` Anti-ransomware monitoring is paused on the volume from its earlier dry_run state. Valid in GET operation. <br>For POST, the valid Anti-ransomware states are only `disabled`, `enabled` and `dry_run`, whereas for PATCH, `paused` is also valid along with the three valid states for POST.
	// Enum: [disabled disable_in_progress dry_run enabled paused enable_paused dry_run_paused]
	State string `json:"state,omitempty"`

	// Indicates whether or not to set the surge values as historical values.
	SurgeAsNormal bool `json:"surge_as_normal,omitempty"`

	// suspect files
	SuspectFiles []*AntiRansomwareVolumeSuspectFilesItems0 `json:"suspect_files,omitempty"`
}

// Validate validates this anti ransomware volume
func (m *AntiRansomwareVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttackProbability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttackReports(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDryRunStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuspectFiles(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var antiRansomwareVolumeTypeAttackProbabilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","low","moderate","high"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		antiRansomwareVolumeTypeAttackProbabilityPropEnum = append(antiRansomwareVolumeTypeAttackProbabilityPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// attack_probability
	// AttackProbability
	// none
	// END DEBUGGING
	// AntiRansomwareVolumeAttackProbabilityNone captures enum value "none"
	AntiRansomwareVolumeAttackProbabilityNone string = "none"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// attack_probability
	// AttackProbability
	// low
	// END DEBUGGING
	// AntiRansomwareVolumeAttackProbabilityLow captures enum value "low"
	AntiRansomwareVolumeAttackProbabilityLow string = "low"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// attack_probability
	// AttackProbability
	// moderate
	// END DEBUGGING
	// AntiRansomwareVolumeAttackProbabilityModerate captures enum value "moderate"
	AntiRansomwareVolumeAttackProbabilityModerate string = "moderate"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// attack_probability
	// AttackProbability
	// high
	// END DEBUGGING
	// AntiRansomwareVolumeAttackProbabilityHigh captures enum value "high"
	AntiRansomwareVolumeAttackProbabilityHigh string = "high"
)

// prop value enum
func (m *AntiRansomwareVolume) validateAttackProbabilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, antiRansomwareVolumeTypeAttackProbabilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AntiRansomwareVolume) validateAttackProbability(formats strfmt.Registry) error {
	if swag.IsZero(m.AttackProbability) { // not required
		return nil
	}

	// value enum
	if err := m.validateAttackProbabilityEnum("attack_probability", "body", m.AttackProbability); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolume) validateAttackReports(formats strfmt.Registry) error {
	if swag.IsZero(m.AttackReports) { // not required
		return nil
	}

	for i := 0; i < len(m.AttackReports); i++ {
		if swag.IsZero(m.AttackReports[i]) { // not required
			continue
		}

		if m.AttackReports[i] != nil {
			if err := m.AttackReports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attack_reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AntiRansomwareVolume) validateDryRunStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.DryRunStartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("dry_run_start_time", "body", "date-time", m.DryRunStartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolume) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

var antiRansomwareVolumeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["disabled","disable_in_progress","dry_run","enabled","paused","enable_paused","dry_run_paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		antiRansomwareVolumeTypeStatePropEnum = append(antiRansomwareVolumeTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// state
	// State
	// disabled
	// END DEBUGGING
	// AntiRansomwareVolumeStateDisabled captures enum value "disabled"
	AntiRansomwareVolumeStateDisabled string = "disabled"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// state
	// State
	// disable_in_progress
	// END DEBUGGING
	// AntiRansomwareVolumeStateDisableInProgress captures enum value "disable_in_progress"
	AntiRansomwareVolumeStateDisableInProgress string = "disable_in_progress"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// state
	// State
	// dry_run
	// END DEBUGGING
	// AntiRansomwareVolumeStateDryRun captures enum value "dry_run"
	AntiRansomwareVolumeStateDryRun string = "dry_run"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// state
	// State
	// enabled
	// END DEBUGGING
	// AntiRansomwareVolumeStateEnabled captures enum value "enabled"
	AntiRansomwareVolumeStateEnabled string = "enabled"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// state
	// State
	// paused
	// END DEBUGGING
	// AntiRansomwareVolumeStatePaused captures enum value "paused"
	AntiRansomwareVolumeStatePaused string = "paused"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// state
	// State
	// enable_paused
	// END DEBUGGING
	// AntiRansomwareVolumeStateEnablePaused captures enum value "enable_paused"
	AntiRansomwareVolumeStateEnablePaused string = "enable_paused"

	// BEGIN DEBUGGING
	// anti_ransomware_volume
	// AntiRansomwareVolume
	// state
	// State
	// dry_run_paused
	// END DEBUGGING
	// AntiRansomwareVolumeStateDryRunPaused captures enum value "dry_run_paused"
	AntiRansomwareVolumeStateDryRunPaused string = "dry_run_paused"
)

// prop value enum
func (m *AntiRansomwareVolume) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, antiRansomwareVolumeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AntiRansomwareVolume) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolume) validateSuspectFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.SuspectFiles) { // not required
		return nil
	}

	for i := 0; i < len(m.SuspectFiles); i++ {
		if swag.IsZero(m.SuspectFiles[i]) { // not required
			continue
		}

		if m.SuspectFiles[i] != nil {
			if err := m.SuspectFiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("suspect_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this anti ransomware volume based on the context it is used
func (m *AntiRansomwareVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttackProbability(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAttackReports(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDryRunStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuspectFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AntiRansomwareVolume) contextValidateAttackProbability(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "attack_probability", "body", string(m.AttackProbability)); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolume) contextValidateAttackReports(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AttackReports); i++ {

		if m.AttackReports[i] != nil {
			if err := m.AttackReports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attack_reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AntiRansomwareVolume) contextValidateDryRunStartTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "dry_run_start_time", "body", m.DryRunStartTime); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolume) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *AntiRansomwareVolume) contextValidateSuspectFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SuspectFiles); i++ {

		if m.SuspectFiles[i] != nil {
			if err := m.SuspectFiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("suspect_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AntiRansomwareVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AntiRansomwareVolume) UnmarshalBinary(b []byte) error {
	var res AntiRansomwareVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AntiRansomwareVolumeSpace anti ransomware volume space
//
// swagger:model AntiRansomwareVolumeSpace
type AntiRansomwareVolumeSpace struct {

	// Total number of Anti-ransomware backup Snapshot copies.
	// Read Only: true
	SnapshotCount int64 `json:"snapshot_count,omitempty"`

	// Total space in bytes used by the Anti-ransomware feature.
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// Space in bytes used by the Anti-ransomware analytics logs.
	// Read Only: true
	UsedByLogs int64 `json:"used_by_logs,omitempty"`

	// Space in bytes used by the Anti-ransomware backup Snapshot copies.
	// Read Only: true
	UsedBySnapshots int64 `json:"used_by_snapshots,omitempty"`
}

// Validate validates this anti ransomware volume space
func (m *AntiRansomwareVolumeSpace) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this anti ransomware volume space based on the context it is used
func (m *AntiRansomwareVolumeSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSnapshotCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedByLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedBySnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AntiRansomwareVolumeSpace) contextValidateSnapshotCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot_count", "body", int64(m.SnapshotCount)); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolumeSpace) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolumeSpace) contextValidateUsedByLogs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used_by_logs", "body", int64(m.UsedByLogs)); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolumeSpace) contextValidateUsedBySnapshots(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used_by_snapshots", "body", int64(m.UsedBySnapshots)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AntiRansomwareVolumeSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AntiRansomwareVolumeSpace) UnmarshalBinary(b []byte) error {
	var res AntiRansomwareVolumeSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AntiRansomwareVolumeSuspectFilesItems0 anti ransomware volume suspect files items0
//
// swagger:model AntiRansomwareVolumeSuspectFilesItems0
type AntiRansomwareVolumeSuspectFilesItems0 struct {

	// Total number of `suspect_files.format` files observed by the Anti-ransomware analytics engine on the volume.
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// Indicates the entropy level of this file type.
	// Read Only: true
	Entropy string `json:"entropy,omitempty"`

	// File formats observed by the Anti-ransomware analytics engine on the volume.
	// Read Only: true
	Format string `json:"format,omitempty"`
}

// Validate validates this anti ransomware volume suspect files items0
func (m *AntiRansomwareVolumeSuspectFilesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this anti ransomware volume suspect files items0 based on the context it is used
func (m *AntiRansomwareVolumeSuspectFilesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntropy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AntiRansomwareVolumeSuspectFilesItems0) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "count", "body", int64(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolumeSuspectFilesItems0) contextValidateEntropy(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "entropy", "body", string(m.Entropy)); err != nil {
		return err
	}

	return nil
}

func (m *AntiRansomwareVolumeSuspectFilesItems0) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "format", "body", string(m.Format)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AntiRansomwareVolumeSuspectFilesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AntiRansomwareVolumeSuspectFilesItems0) UnmarshalBinary(b []byte) error {
	var res AntiRansomwareVolumeSuspectFilesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

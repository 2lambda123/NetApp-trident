// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BgpPeerGroup A BGP peer group between a local network interface and a router, for the purpose of announcing VIP interface locations for SVMs in this IPspace.
//
// swagger:model bgp_peer_group
type BgpPeerGroup struct {

	// ipspace
	Ipspace *BgpPeerGroupIpspace `json:"ipspace,omitempty"`

	// local
	Local *BgpPeerGroupLocal `json:"local,omitempty"`

	// Name of the peer group
	// Example: bgpv4peer
	Name string `json:"name,omitempty"`

	// peer
	Peer *BgpPeerGroupPeer `json:"peer,omitempty"`

	// State of the peer group
	// Read Only: true
	// Enum: [up down]
	State string `json:"state,omitempty"`

	// UUID of the peer group
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this bgp peer group
func (m *BgpPeerGroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroup) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroup) validateLocal(formats strfmt.Registry) error {
	if swag.IsZero(m.Local) { // not required
		return nil
	}

	if m.Local != nil {
		if err := m.Local.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroup) validatePeer(formats strfmt.Registry) error {
	if swag.IsZero(m.Peer) { // not required
		return nil
	}

	if m.Peer != nil {
		if err := m.Peer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("peer")
			}
			return err
		}
	}

	return nil
}

var bgpPeerGroupTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		bgpPeerGroupTypeStatePropEnum = append(bgpPeerGroupTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// bgp_peer_group
	// BgpPeerGroup
	// state
	// State
	// up
	// END DEBUGGING
	// BgpPeerGroupStateUp captures enum value "up"
	BgpPeerGroupStateUp string = "up"

	// BEGIN DEBUGGING
	// bgp_peer_group
	// BgpPeerGroup
	// state
	// State
	// down
	// END DEBUGGING
	// BgpPeerGroupStateDown captures enum value "down"
	BgpPeerGroupStateDown string = "down"
)

// prop value enum
func (m *BgpPeerGroup) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, bgpPeerGroupTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BgpPeerGroup) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this bgp peer group based on the context it is used
func (m *BgpPeerGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroup) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroup) contextValidateLocal(ctx context.Context, formats strfmt.Registry) error {

	if m.Local != nil {
		if err := m.Local.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroup) contextValidatePeer(ctx context.Context, formats strfmt.Registry) error {

	if m.Peer != nil {
		if err := m.Peer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("peer")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroup) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *BgpPeerGroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroup) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupIpspace Either the UUID or name is supplied on input.
//
// swagger:model BgpPeerGroupIpspace
type BgpPeerGroupIpspace struct {

	// links
	Links *BgpPeerGroupIpspaceLinks `json:"_links,omitempty"`

	// IPspace name
	// Example: exchange
	Name string `json:"name,omitempty"`

	// IPspace UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this bgp peer group ipspace
func (m *BgpPeerGroupIpspace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupIpspace) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this bgp peer group ipspace based on the context it is used
func (m *BgpPeerGroupIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupIpspace) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupIpspace) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupIpspaceLinks bgp peer group ipspace links
//
// swagger:model BgpPeerGroupIpspaceLinks
type BgpPeerGroupIpspaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this bgp peer group ipspace links
func (m *BgpPeerGroupIpspaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupIpspaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this bgp peer group ipspace links based on the context it is used
func (m *BgpPeerGroupIpspaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupIpspaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupIpspaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupIpspaceLinks) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupIpspaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocal Information describing the local interface that is being used to peer with a router using BGP. On a POST operation, an existing BGP interface is used by specifying the interface, or create a new one by specifying the port and IP address.
//
// swagger:model BgpPeerGroupLocal
type BgpPeerGroupLocal struct {

	// interface
	Interface *BgpPeerGroupLocalInterface `json:"interface,omitempty"`

	// ip
	IP *BgpPeerGroupLocalIP `json:"ip,omitempty"`

	// port
	Port *BgpPeerGroupLocalPort `json:"port,omitempty"`
}

// Validate validates this bgp peer group local
func (m *BgpPeerGroupLocal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocal) validateInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.Interface) { // not required
		return nil
	}

	if m.Interface != nil {
		if err := m.Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocal) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocal) validatePort(formats strfmt.Registry) error {
	if swag.IsZero(m.Port) { // not required
		return nil
	}

	if m.Port != nil {
		if err := m.Port.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this bgp peer group local based on the context it is used
func (m *BgpPeerGroupLocal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocal) contextValidateInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.Interface != nil {
		if err := m.Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocal) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocal) contextValidatePort(ctx context.Context, formats strfmt.Registry) error {

	if m.Port != nil {
		if err := m.Port.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocal) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocalIP IP information to create a new interface.
//
// swagger:model BgpPeerGroupLocalIP
type BgpPeerGroupLocalIP struct {

	// address
	Address IPAddress `json:"address,omitempty"`

	// netmask
	Netmask IPNetmask `json:"netmask,omitempty"`
}

// Validate validates this bgp peer group local IP
func (m *BgpPeerGroupLocalIP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetmask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalIP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("local" + "." + "ip" + "." + "address")
		}
		return err
	}

	return nil
}

func (m *BgpPeerGroupLocalIP) validateNetmask(formats strfmt.Registry) error {
	if swag.IsZero(m.Netmask) { // not required
		return nil
	}

	if err := m.Netmask.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("local" + "." + "ip" + "." + "netmask")
		}
		return err
	}

	return nil
}

// ContextValidate validate this bgp peer group local IP based on the context it is used
func (m *BgpPeerGroupLocalIP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetmask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalIP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("local" + "." + "ip" + "." + "address")
		}
		return err
	}

	return nil
}

func (m *BgpPeerGroupLocalIP) contextValidateNetmask(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Netmask.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("local" + "." + "ip" + "." + "netmask")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocalIP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocalIP) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocalIP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocalInterface bgp peer group local interface
//
// swagger:model BgpPeerGroupLocalInterface
type BgpPeerGroupLocalInterface struct {

	// links
	Links *BgpPeerGroupLocalInterfaceLinks `json:"_links,omitempty"`

	// ip
	IP *BgpPeerGroupLocalInterfaceIP `json:"ip,omitempty"`

	// The name of the interface.
	// Example: lif1
	Name string `json:"name,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this bgp peer group local interface
func (m *BgpPeerGroupLocalInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalInterface) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocalInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this bgp peer group local interface based on the context it is used
func (m *BgpPeerGroupLocalInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalInterface) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocalInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface" + "." + "ip")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocalInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocalInterface) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocalInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocalInterfaceIP IP information
//
// swagger:model BgpPeerGroupLocalInterfaceIP
type BgpPeerGroupLocalInterfaceIP struct {

	// address
	Address IPAddressReadonly `json:"address,omitempty"`
}

// Validate validates this bgp peer group local interface IP
func (m *BgpPeerGroupLocalInterfaceIP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalInterfaceIP) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if err := m.Address.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("local" + "." + "interface" + "." + "ip" + "." + "address")
		}
		return err
	}

	return nil
}

// ContextValidate validate this bgp peer group local interface IP based on the context it is used
func (m *BgpPeerGroupLocalInterfaceIP) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalInterfaceIP) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Address.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("local" + "." + "interface" + "." + "ip" + "." + "address")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocalInterfaceIP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocalInterfaceIP) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocalInterfaceIP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocalInterfaceLinks bgp peer group local interface links
//
// swagger:model BgpPeerGroupLocalInterfaceLinks
type BgpPeerGroupLocalInterfaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this bgp peer group local interface links
func (m *BgpPeerGroupLocalInterfaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalInterfaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this bgp peer group local interface links based on the context it is used
func (m *BgpPeerGroupLocalInterfaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalInterfaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "interface" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocalInterfaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocalInterfaceLinks) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocalInterfaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocalPort bgp peer group local port
//
// swagger:model BgpPeerGroupLocalPort
type BgpPeerGroupLocalPort struct {

	// links
	Links *BgpPeerGroupLocalPortLinks `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *BgpPeerGroupLocalPortNode `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this bgp peer group local port
func (m *BgpPeerGroupLocalPort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalPort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocalPort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this bgp peer group local port based on the context it is used
func (m *BgpPeerGroupLocalPort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalPort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *BgpPeerGroupLocalPort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocalPort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocalPort) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocalPort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocalPortLinks bgp peer group local port links
//
// swagger:model BgpPeerGroupLocalPortLinks
type BgpPeerGroupLocalPortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this bgp peer group local port links
func (m *BgpPeerGroupLocalPortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalPortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this bgp peer group local port links based on the context it is used
func (m *BgpPeerGroupLocalPortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BgpPeerGroupLocalPortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("local" + "." + "port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocalPortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocalPortLinks) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocalPortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupLocalPortNode bgp peer group local port node
//
// swagger:model BgpPeerGroupLocalPortNode
type BgpPeerGroupLocalPortNode struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this bgp peer group local port node
func (m *BgpPeerGroupLocalPortNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this bgp peer group local port node based on context it is used
func (m *BgpPeerGroupLocalPortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupLocalPortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupLocalPortNode) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupLocalPortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BgpPeerGroupPeer Information describing the router to peer with
//
// swagger:model BgpPeerGroupPeer
type BgpPeerGroupPeer struct {

	// Peer router address
	// Example: 10.10.10.7
	Address string `json:"address,omitempty"`

	// Autonomous system number of peer
	Asn int64 `json:"asn,omitempty"`

	// Use peer address as next hop.
	IsNextHop bool `json:"is_next_hop,omitempty"`
}

// Validate validates this bgp peer group peer
func (m *BgpPeerGroupPeer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this bgp peer group peer based on context it is used
func (m *BgpPeerGroupPeer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BgpPeerGroupPeer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BgpPeerGroupPeer) UnmarshalBinary(b []byte) error {
	var res BgpPeerGroupPeer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MetroclusterDiagnostics metrocluster diagnostics
//
// swagger:model metrocluster_diagnostics
type MetroclusterDiagnostics struct {

	// aggregate
	Aggregate *MetroclusterDiagnosticsAggregate `json:"aggregate,omitempty"`

	// cluster
	Cluster *MetroclusterDiagnosticsCluster `json:"cluster,omitempty"`

	// config replication
	ConfigReplication *MetroclusterDiagnosticsConfigReplication `json:"config-replication,omitempty"`

	// connection
	Connection *MetroclusterDiagnosticsConnection `json:"connection,omitempty"`

	// interface
	Interface *MetroclusterDiagnosticsInterface `json:"interface,omitempty"`

	// node
	Node *MetroclusterDiagnosticsNode `json:"node,omitempty"`

	// volume
	Volume *MetroclusterDiagnosticsVolume `json:"volume,omitempty"`
}

// Validate validates this metrocluster diagnostics
func (m *MetroclusterDiagnostics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigReplication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnostics) validateAggregate(formats strfmt.Registry) error {
	if swag.IsZero(m.Aggregate) { // not required
		return nil
	}

	if m.Aggregate != nil {
		if err := m.Aggregate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) validateCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Cluster) { // not required
		return nil
	}

	if m.Cluster != nil {
		if err := m.Cluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) validateConfigReplication(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigReplication) { // not required
		return nil
	}

	if m.ConfigReplication != nil {
		if err := m.ConfigReplication.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("config-replication")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) validateConnection(formats strfmt.Registry) error {
	if swag.IsZero(m.Connection) { // not required
		return nil
	}

	if m.Connection != nil {
		if err := m.Connection.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) validateInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.Interface) { // not required
		return nil
	}

	if m.Interface != nil {
		if err := m.Interface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("interface")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics based on the context it is used
func (m *MetroclusterDiagnostics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAggregate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigReplication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnostics) contextValidateAggregate(ctx context.Context, formats strfmt.Registry) error {

	if m.Aggregate != nil {
		if err := m.Aggregate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) contextValidateCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Cluster != nil {
		if err := m.Cluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) contextValidateConfigReplication(ctx context.Context, formats strfmt.Registry) error {

	if m.ConfigReplication != nil {
		if err := m.ConfigReplication.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("config-replication")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) contextValidateConnection(ctx context.Context, formats strfmt.Registry) error {

	if m.Connection != nil {
		if err := m.Connection.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) contextValidateInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.Interface != nil {
		if err := m.Interface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("interface")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnostics) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnostics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnostics) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnostics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsAggregate metrocluster diagnostics aggregate
//
// swagger:model MetroclusterDiagnosticsAggregate
type MetroclusterDiagnosticsAggregate struct {

	// Display details of the MetroCluster check for aggregates.
	// Read Only: true
	Details []*MetroclusterDiagDetails `json:"details,omitempty"`

	// Status of diagnostic operation for this component.
	// Read Only: true
	// Enum: [ok warning not_run not_applicable]
	State string `json:"state,omitempty"`

	// summary
	Summary *MetroclusterDiagnosticsAggregateSummary `json:"summary,omitempty"`

	// Time of the most recent diagnostic operation for this component
	// Example: 2016-03-10T14:35:16-08:00
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this metrocluster diagnostics aggregate
func (m *MetroclusterDiagnosticsAggregate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsAggregate) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.Details) { // not required
		return nil
	}

	for i := 0; i < len(m.Details); i++ {
		if swag.IsZero(m.Details[i]) { // not required
			continue
		}

		if m.Details[i] != nil {
			if err := m.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregate" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var metroclusterDiagnosticsAggregateTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","warning","not_run","not_applicable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterDiagnosticsAggregateTypeStatePropEnum = append(metroclusterDiagnosticsAggregateTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsAggregate
	// MetroclusterDiagnosticsAggregate
	// state
	// State
	// ok
	// END DEBUGGING
	// MetroclusterDiagnosticsAggregateStateOk captures enum value "ok"
	MetroclusterDiagnosticsAggregateStateOk string = "ok"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsAggregate
	// MetroclusterDiagnosticsAggregate
	// state
	// State
	// warning
	// END DEBUGGING
	// MetroclusterDiagnosticsAggregateStateWarning captures enum value "warning"
	MetroclusterDiagnosticsAggregateStateWarning string = "warning"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsAggregate
	// MetroclusterDiagnosticsAggregate
	// state
	// State
	// not_run
	// END DEBUGGING
	// MetroclusterDiagnosticsAggregateStateNotRun captures enum value "not_run"
	MetroclusterDiagnosticsAggregateStateNotRun string = "not_run"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsAggregate
	// MetroclusterDiagnosticsAggregate
	// state
	// State
	// not_applicable
	// END DEBUGGING
	// MetroclusterDiagnosticsAggregateStateNotApplicable captures enum value "not_applicable"
	MetroclusterDiagnosticsAggregateStateNotApplicable string = "not_applicable"
)

// prop value enum
func (m *MetroclusterDiagnosticsAggregate) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterDiagnosticsAggregateTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterDiagnosticsAggregate) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("aggregate"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsAggregate) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsAggregate) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("aggregate"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics aggregate based on the context it is used
func (m *MetroclusterDiagnosticsAggregate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsAggregate) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregate"+"."+"details", "body", []*MetroclusterDiagDetails(m.Details)); err != nil {
		return err
	}

	for i := 0; i < len(m.Details); i++ {

		if m.Details[i] != nil {
			if err := m.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregate" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MetroclusterDiagnosticsAggregate) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregate"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsAggregate) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aggregate" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsAggregate) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregate"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsAggregate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsAggregate) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsAggregate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsAggregateSummary Additional information or recovery steps to take.
//
// swagger:model MetroclusterDiagnosticsAggregateSummary
type MetroclusterDiagnosticsAggregateSummary struct {

	// Argument code
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message argument
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this metrocluster diagnostics aggregate summary
func (m *MetroclusterDiagnosticsAggregateSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster diagnostics aggregate summary based on the context it is used
func (m *MetroclusterDiagnosticsAggregateSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsAggregateSummary) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregate"+"."+"summary"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsAggregateSummary) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "aggregate"+"."+"summary"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsAggregateSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsAggregateSummary) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsAggregateSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsCluster metrocluster diagnostics cluster
//
// swagger:model MetroclusterDiagnosticsCluster
type MetroclusterDiagnosticsCluster struct {

	// Status of diagnostic operation for this component.
	// Read Only: true
	// Enum: [ok warning not_run not_applicable]
	State string `json:"state,omitempty"`

	// summary
	Summary *MetroclusterDiagnosticsClusterSummary `json:"summary,omitempty"`

	// Time of the most recent diagnostic operation for this component
	// Example: 2016-03-10T14:35:16-08:00
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this metrocluster diagnostics cluster
func (m *MetroclusterDiagnosticsCluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var metroclusterDiagnosticsClusterTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","warning","not_run","not_applicable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterDiagnosticsClusterTypeStatePropEnum = append(metroclusterDiagnosticsClusterTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsCluster
	// MetroclusterDiagnosticsCluster
	// state
	// State
	// ok
	// END DEBUGGING
	// MetroclusterDiagnosticsClusterStateOk captures enum value "ok"
	MetroclusterDiagnosticsClusterStateOk string = "ok"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsCluster
	// MetroclusterDiagnosticsCluster
	// state
	// State
	// warning
	// END DEBUGGING
	// MetroclusterDiagnosticsClusterStateWarning captures enum value "warning"
	MetroclusterDiagnosticsClusterStateWarning string = "warning"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsCluster
	// MetroclusterDiagnosticsCluster
	// state
	// State
	// not_run
	// END DEBUGGING
	// MetroclusterDiagnosticsClusterStateNotRun captures enum value "not_run"
	MetroclusterDiagnosticsClusterStateNotRun string = "not_run"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsCluster
	// MetroclusterDiagnosticsCluster
	// state
	// State
	// not_applicable
	// END DEBUGGING
	// MetroclusterDiagnosticsClusterStateNotApplicable captures enum value "not_applicable"
	MetroclusterDiagnosticsClusterStateNotApplicable string = "not_applicable"
)

// prop value enum
func (m *MetroclusterDiagnosticsCluster) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterDiagnosticsClusterTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterDiagnosticsCluster) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("cluster"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsCluster) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsCluster) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("cluster"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics cluster based on the context it is used
func (m *MetroclusterDiagnosticsCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsCluster) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsCluster) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsCluster) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsCluster) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsClusterSummary Additional information or recovery steps to take.
//
// swagger:model MetroclusterDiagnosticsClusterSummary
type MetroclusterDiagnosticsClusterSummary struct {

	// Argument code
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message argument
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this metrocluster diagnostics cluster summary
func (m *MetroclusterDiagnosticsClusterSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster diagnostics cluster summary based on the context it is used
func (m *MetroclusterDiagnosticsClusterSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsClusterSummary) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster"+"."+"summary"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsClusterSummary) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster"+"."+"summary"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsClusterSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsClusterSummary) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsClusterSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsConfigReplication metrocluster diagnostics config replication
//
// swagger:model MetroclusterDiagnosticsConfigReplication
type MetroclusterDiagnosticsConfigReplication struct {

	// Status of diagnostic operation for this component.
	// Read Only: true
	// Enum: [ok warning not_run not_applicable]
	State string `json:"state,omitempty"`

	// summary
	Summary *MetroclusterDiagnosticsConfigReplicationSummary `json:"summary,omitempty"`

	// Time of the most recent diagnostic operation for this component
	// Example: 2016-03-14T14:35:16-08:00
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this metrocluster diagnostics config replication
func (m *MetroclusterDiagnosticsConfigReplication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var metroclusterDiagnosticsConfigReplicationTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","warning","not_run","not_applicable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterDiagnosticsConfigReplicationTypeStatePropEnum = append(metroclusterDiagnosticsConfigReplicationTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConfigReplication
	// MetroclusterDiagnosticsConfigReplication
	// state
	// State
	// ok
	// END DEBUGGING
	// MetroclusterDiagnosticsConfigReplicationStateOk captures enum value "ok"
	MetroclusterDiagnosticsConfigReplicationStateOk string = "ok"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConfigReplication
	// MetroclusterDiagnosticsConfigReplication
	// state
	// State
	// warning
	// END DEBUGGING
	// MetroclusterDiagnosticsConfigReplicationStateWarning captures enum value "warning"
	MetroclusterDiagnosticsConfigReplicationStateWarning string = "warning"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConfigReplication
	// MetroclusterDiagnosticsConfigReplication
	// state
	// State
	// not_run
	// END DEBUGGING
	// MetroclusterDiagnosticsConfigReplicationStateNotRun captures enum value "not_run"
	MetroclusterDiagnosticsConfigReplicationStateNotRun string = "not_run"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConfigReplication
	// MetroclusterDiagnosticsConfigReplication
	// state
	// State
	// not_applicable
	// END DEBUGGING
	// MetroclusterDiagnosticsConfigReplicationStateNotApplicable captures enum value "not_applicable"
	MetroclusterDiagnosticsConfigReplicationStateNotApplicable string = "not_applicable"
)

// prop value enum
func (m *MetroclusterDiagnosticsConfigReplication) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterDiagnosticsConfigReplicationTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterDiagnosticsConfigReplication) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("config-replication"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsConfigReplication) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("config-replication" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsConfigReplication) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("config-replication"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics config replication based on the context it is used
func (m *MetroclusterDiagnosticsConfigReplication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsConfigReplication) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "config-replication"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsConfigReplication) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("config-replication" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsConfigReplication) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "config-replication"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConfigReplication) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConfigReplication) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsConfigReplication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsConfigReplicationSummary Additional information or recovery steps to take.
//
// swagger:model MetroclusterDiagnosticsConfigReplicationSummary
type MetroclusterDiagnosticsConfigReplicationSummary struct {

	// Argument code
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message argument
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this metrocluster diagnostics config replication summary
func (m *MetroclusterDiagnosticsConfigReplicationSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster diagnostics config replication summary based on the context it is used
func (m *MetroclusterDiagnosticsConfigReplicationSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsConfigReplicationSummary) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "config-replication"+"."+"summary"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsConfigReplicationSummary) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "config-replication"+"."+"summary"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConfigReplicationSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConfigReplicationSummary) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsConfigReplicationSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsConnection metrocluster diagnostics connection
//
// swagger:model MetroclusterDiagnosticsConnection
type MetroclusterDiagnosticsConnection struct {

	// Status of diagnostic operation for this component.
	// Read Only: true
	// Enum: [ok warning not_run not_applicable]
	State string `json:"state,omitempty"`

	// summary
	Summary *MetroclusterDiagnosticsConnectionSummary `json:"summary,omitempty"`

	// Time of the most recent diagnostic operation for this component
	// Example: 2016-03-10T14:35:16-08:00
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this metrocluster diagnostics connection
func (m *MetroclusterDiagnosticsConnection) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var metroclusterDiagnosticsConnectionTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","warning","not_run","not_applicable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterDiagnosticsConnectionTypeStatePropEnum = append(metroclusterDiagnosticsConnectionTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConnection
	// MetroclusterDiagnosticsConnection
	// state
	// State
	// ok
	// END DEBUGGING
	// MetroclusterDiagnosticsConnectionStateOk captures enum value "ok"
	MetroclusterDiagnosticsConnectionStateOk string = "ok"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConnection
	// MetroclusterDiagnosticsConnection
	// state
	// State
	// warning
	// END DEBUGGING
	// MetroclusterDiagnosticsConnectionStateWarning captures enum value "warning"
	MetroclusterDiagnosticsConnectionStateWarning string = "warning"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConnection
	// MetroclusterDiagnosticsConnection
	// state
	// State
	// not_run
	// END DEBUGGING
	// MetroclusterDiagnosticsConnectionStateNotRun captures enum value "not_run"
	MetroclusterDiagnosticsConnectionStateNotRun string = "not_run"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsConnection
	// MetroclusterDiagnosticsConnection
	// state
	// State
	// not_applicable
	// END DEBUGGING
	// MetroclusterDiagnosticsConnectionStateNotApplicable captures enum value "not_applicable"
	MetroclusterDiagnosticsConnectionStateNotApplicable string = "not_applicable"
)

// prop value enum
func (m *MetroclusterDiagnosticsConnection) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterDiagnosticsConnectionTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterDiagnosticsConnection) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("connection"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsConnection) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsConnection) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("connection"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics connection based on the context it is used
func (m *MetroclusterDiagnosticsConnection) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsConnection) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connection"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsConnection) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsConnection) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connection"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConnection) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConnection) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsConnection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsConnectionSummary Additional information or recovery steps to take.
//
// swagger:model MetroclusterDiagnosticsConnectionSummary
type MetroclusterDiagnosticsConnectionSummary struct {

	// Argument code
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message argument
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this metrocluster diagnostics connection summary
func (m *MetroclusterDiagnosticsConnectionSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster diagnostics connection summary based on the context it is used
func (m *MetroclusterDiagnosticsConnectionSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsConnectionSummary) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connection"+"."+"summary"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsConnectionSummary) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connection"+"."+"summary"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConnectionSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsConnectionSummary) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsConnectionSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsInterface metrocluster diagnostics interface
//
// swagger:model MetroclusterDiagnosticsInterface
type MetroclusterDiagnosticsInterface struct {

	// Status of diagnostic operation for this component.
	// Read Only: true
	// Enum: [ok warning not_run not_applicable]
	State string `json:"state,omitempty"`

	// summary
	Summary *MetroclusterDiagnosticsInterfaceSummary `json:"summary,omitempty"`

	// Time of the most recent diagnostic operation for this component
	// Example: 2016-03-10T14:35:16-08:00
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this metrocluster diagnostics interface
func (m *MetroclusterDiagnosticsInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var metroclusterDiagnosticsInterfaceTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","warning","not_run","not_applicable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterDiagnosticsInterfaceTypeStatePropEnum = append(metroclusterDiagnosticsInterfaceTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsInterface
	// MetroclusterDiagnosticsInterface
	// state
	// State
	// ok
	// END DEBUGGING
	// MetroclusterDiagnosticsInterfaceStateOk captures enum value "ok"
	MetroclusterDiagnosticsInterfaceStateOk string = "ok"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsInterface
	// MetroclusterDiagnosticsInterface
	// state
	// State
	// warning
	// END DEBUGGING
	// MetroclusterDiagnosticsInterfaceStateWarning captures enum value "warning"
	MetroclusterDiagnosticsInterfaceStateWarning string = "warning"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsInterface
	// MetroclusterDiagnosticsInterface
	// state
	// State
	// not_run
	// END DEBUGGING
	// MetroclusterDiagnosticsInterfaceStateNotRun captures enum value "not_run"
	MetroclusterDiagnosticsInterfaceStateNotRun string = "not_run"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsInterface
	// MetroclusterDiagnosticsInterface
	// state
	// State
	// not_applicable
	// END DEBUGGING
	// MetroclusterDiagnosticsInterfaceStateNotApplicable captures enum value "not_applicable"
	MetroclusterDiagnosticsInterfaceStateNotApplicable string = "not_applicable"
)

// prop value enum
func (m *MetroclusterDiagnosticsInterface) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterDiagnosticsInterfaceTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterDiagnosticsInterface) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("interface"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsInterface) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("interface" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsInterface) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("interface"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics interface based on the context it is used
func (m *MetroclusterDiagnosticsInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsInterface) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "interface"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsInterface) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("interface" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsInterface) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "interface"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsInterface) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsInterfaceSummary Additional information or recovery steps to take.
//
// swagger:model MetroclusterDiagnosticsInterfaceSummary
type MetroclusterDiagnosticsInterfaceSummary struct {

	// Argument code
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message argument
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this metrocluster diagnostics interface summary
func (m *MetroclusterDiagnosticsInterfaceSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster diagnostics interface summary based on the context it is used
func (m *MetroclusterDiagnosticsInterfaceSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsInterfaceSummary) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "interface"+"."+"summary"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsInterfaceSummary) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "interface"+"."+"summary"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsInterfaceSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsInterfaceSummary) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsInterfaceSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsNode metrocluster diagnostics node
//
// swagger:model MetroclusterDiagnosticsNode
type MetroclusterDiagnosticsNode struct {

	// Displays details of the MetroCluster check for nodes.
	// Read Only: true
	Details []*MetroclusterDiagDetails `json:"details,omitempty"`

	// Status of diagnostic operation for this component.
	// Read Only: true
	// Enum: [ok warning not_run not_applicable]
	State string `json:"state,omitempty"`

	// summary
	Summary *MetroclusterDiagnosticsNodeSummary `json:"summary,omitempty"`

	// Time of the most recent diagnostic operation for this component
	// Example: 2016-03-10T14:35:16-08:00
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this metrocluster diagnostics node
func (m *MetroclusterDiagnosticsNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsNode) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.Details) { // not required
		return nil
	}

	for i := 0; i < len(m.Details); i++ {
		if swag.IsZero(m.Details[i]) { // not required
			continue
		}

		if m.Details[i] != nil {
			if err := m.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var metroclusterDiagnosticsNodeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","warning","not_run","not_applicable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterDiagnosticsNodeTypeStatePropEnum = append(metroclusterDiagnosticsNodeTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsNode
	// MetroclusterDiagnosticsNode
	// state
	// State
	// ok
	// END DEBUGGING
	// MetroclusterDiagnosticsNodeStateOk captures enum value "ok"
	MetroclusterDiagnosticsNodeStateOk string = "ok"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsNode
	// MetroclusterDiagnosticsNode
	// state
	// State
	// warning
	// END DEBUGGING
	// MetroclusterDiagnosticsNodeStateWarning captures enum value "warning"
	MetroclusterDiagnosticsNodeStateWarning string = "warning"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsNode
	// MetroclusterDiagnosticsNode
	// state
	// State
	// not_run
	// END DEBUGGING
	// MetroclusterDiagnosticsNodeStateNotRun captures enum value "not_run"
	MetroclusterDiagnosticsNodeStateNotRun string = "not_run"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsNode
	// MetroclusterDiagnosticsNode
	// state
	// State
	// not_applicable
	// END DEBUGGING
	// MetroclusterDiagnosticsNodeStateNotApplicable captures enum value "not_applicable"
	MetroclusterDiagnosticsNodeStateNotApplicable string = "not_applicable"
)

// prop value enum
func (m *MetroclusterDiagnosticsNode) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterDiagnosticsNodeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterDiagnosticsNode) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("node"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsNode) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsNode) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("node"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics node based on the context it is used
func (m *MetroclusterDiagnosticsNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsNode) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "node"+"."+"details", "body", []*MetroclusterDiagDetails(m.Details)); err != nil {
		return err
	}

	for i := 0; i < len(m.Details); i++ {

		if m.Details[i] != nil {
			if err := m.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MetroclusterDiagnosticsNode) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "node"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsNode) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsNode) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "node"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsNode) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsNodeSummary Additional information or recovery steps to take.
//
// swagger:model MetroclusterDiagnosticsNodeSummary
type MetroclusterDiagnosticsNodeSummary struct {

	// Argument code
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message argument
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this metrocluster diagnostics node summary
func (m *MetroclusterDiagnosticsNodeSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster diagnostics node summary based on the context it is used
func (m *MetroclusterDiagnosticsNodeSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsNodeSummary) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "node"+"."+"summary"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsNodeSummary) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "node"+"."+"summary"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsNodeSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsNodeSummary) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsNodeSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsVolume metrocluster diagnostics volume
//
// swagger:model MetroclusterDiagnosticsVolume
type MetroclusterDiagnosticsVolume struct {

	// Status of diagnostic operation for this component.
	// Read Only: true
	// Enum: [ok warning not_run not_applicable]
	State string `json:"state,omitempty"`

	// summary
	Summary *MetroclusterDiagnosticsVolumeSummary `json:"summary,omitempty"`

	// Time of the most recent diagnostic operation for this component
	// Example: 2016-03-10T14:35:16-08:00
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this metrocluster diagnostics volume
func (m *MetroclusterDiagnosticsVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var metroclusterDiagnosticsVolumeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","warning","not_run","not_applicable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterDiagnosticsVolumeTypeStatePropEnum = append(metroclusterDiagnosticsVolumeTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsVolume
	// MetroclusterDiagnosticsVolume
	// state
	// State
	// ok
	// END DEBUGGING
	// MetroclusterDiagnosticsVolumeStateOk captures enum value "ok"
	MetroclusterDiagnosticsVolumeStateOk string = "ok"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsVolume
	// MetroclusterDiagnosticsVolume
	// state
	// State
	// warning
	// END DEBUGGING
	// MetroclusterDiagnosticsVolumeStateWarning captures enum value "warning"
	MetroclusterDiagnosticsVolumeStateWarning string = "warning"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsVolume
	// MetroclusterDiagnosticsVolume
	// state
	// State
	// not_run
	// END DEBUGGING
	// MetroclusterDiagnosticsVolumeStateNotRun captures enum value "not_run"
	MetroclusterDiagnosticsVolumeStateNotRun string = "not_run"

	// BEGIN DEBUGGING
	// MetroclusterDiagnosticsVolume
	// MetroclusterDiagnosticsVolume
	// state
	// State
	// not_applicable
	// END DEBUGGING
	// MetroclusterDiagnosticsVolumeStateNotApplicable captures enum value "not_applicable"
	MetroclusterDiagnosticsVolumeStateNotApplicable string = "not_applicable"
)

// prop value enum
func (m *MetroclusterDiagnosticsVolume) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterDiagnosticsVolumeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterDiagnosticsVolume) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("volume"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsVolume) validateSummary(formats strfmt.Registry) error {
	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	if m.Summary != nil {
		if err := m.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsVolume) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("volume"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster diagnostics volume based on the context it is used
func (m *MetroclusterDiagnosticsVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSummary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsVolume) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "volume"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsVolume) contextValidateSummary(ctx context.Context, formats strfmt.Registry) error {

	if m.Summary != nil {
		if err := m.Summary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume" + "." + "summary")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterDiagnosticsVolume) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "volume"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsVolume) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterDiagnosticsVolumeSummary Additional information or recovery steps to take.
//
// swagger:model MetroclusterDiagnosticsVolumeSummary
type MetroclusterDiagnosticsVolumeSummary struct {

	// Argument code
	// Read Only: true
	Code string `json:"code,omitempty"`

	// Message argument
	// Read Only: true
	Message string `json:"message,omitempty"`
}

// Validate validates this metrocluster diagnostics volume summary
func (m *MetroclusterDiagnosticsVolumeSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster diagnostics volume summary based on the context it is used
func (m *MetroclusterDiagnosticsVolumeSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterDiagnosticsVolumeSummary) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "volume"+"."+"summary"+"."+"code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterDiagnosticsVolumeSummary) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "volume"+"."+"summary"+"."+"message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterDiagnosticsVolumeSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterDiagnosticsVolumeSummary) UnmarshalBinary(b []byte) error {
	var res MetroclusterDiagnosticsVolumeSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

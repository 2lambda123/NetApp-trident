// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Lun A LUN is the logical representation of storage in a storage area network (SAN).<br/>
// In ONTAP, a LUN is located within a volume. Optionally, it can be located within a qtree in a volume.<br/>
// A LUN can be created to a specified size using thin or thick provisioning. A LUN can then be renamed, resized, cloned, and moved to a different volume. LUNs support the assignment of a quality of service (QoS) policy for performance management or a QoS policy can be assigned to the volume containing the LUN. See the LUN object model to learn more about each of the properties supported by the LUN REST API.<br/>
// A LUN must be mapped to an initiator group to grant access to the initiator group's initiators (client hosts). Initiators can then access the LUN and perform I/O over a Fibre Channel (FC) fabric using the Fibre Channel Protocol or a TCP/IP network using iSCSI.
//
//
// swagger:model lun
type Lun struct {

	// links
	Links *LunLinks `json:"_links,omitempty"`

	// An array of name/value pairs optionally stored with the LUN. Attributes are available to callers to persist small amounts of application-specific metadata. They are in no way interpreted by ONTAP.<br/>
	// Attribute names and values must be at least one byte and no more than 4091 bytes in length. The sum of the name and value lengths must be no more than 4092 bytes.<br/>
	// Valid in POST except when creating a LUN clone. A cloned can already have attributes from its source. You can add, modify, and delete the attributes of a LUN clone in separate requests after creation of the LUN.<br/>
	// Attributes may be added/modified/removed for an existing LUN using the /api/storage/luns/{lun.uuid}/attributes endpoint. For further information, see [`DOC /storage/luns/{lun.uuid}/attributes`](#docs-SAN-storage_luns_{lun.uuid}_attributes).<br/>
	// There is an added cost to retrieving property values for `attributes`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	Attributes []*LunAttributesItems0 `json:"attributes,omitempty"`

	// This property marks the LUN for auto deletion when the volume containing the LUN runs out of space. This is most commonly set on LUN clones.<br/>
	// When set to _true_, the LUN becomes eligible for automatic deletion when the volume runs out of space. Auto deletion only occurs when the volume containing the LUN is also configured for auto deletion and free space in the volume decreases below a particular threshold.<br/>
	// This property is optional in POST and PATCH. The default value for a new LUN is _false_.<br/>
	// There is an added cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	AutoDelete *bool `json:"auto_delete,omitempty"`

	// The class of LUN.<br/>
	// Optional in POST.
	//
	// Enum: [regular protocol_endpoint vvol]
	Class *string `json:"class,omitempty"`

	// clone
	Clone *LunClone `json:"clone,omitempty"`

	// A configurable comment available for use by the administrator. Valid in POST and PATCH.
	//
	// Max Length: 254
	// Min Length: 0
	Comment *string `json:"comment,omitempty"`

	// consistency group
	ConsistencyGroup *LunConsistencyGroup `json:"consistency_group,omitempty"`

	// copy
	Copy *LunCopy `json:"copy,omitempty"`

	// The time the LUN was created.
	// Example: 2018-06-04T19:00:00Z
	// Read Only: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"create_time,omitempty"`

	// The enabled state of the LUN. LUNs can be disabled to prevent access to the LUN. Certain error conditions also cause the LUN to become disabled. If the LUN is disabled, you can consult the `state` property to determine if the LUN is administratively disabled (_offline_) or has become disabled as a result of an error. A LUN in an error condition can be brought online by setting the `enabled` property to _true_ or brought administratively offline by setting the `enabled` property to _false_. Upon creation, a LUN is enabled by default. Valid in PATCH.
	//
	Enabled bool `json:"enabled,omitempty"`

	// location
	Location *LunLocation `json:"location,omitempty"`

	// The LUN maps with which the LUN is associated.<br/>
	// There is an added cost to retrieving property values for `lun_maps`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	// Read Only: true
	LunMaps []*LunLunMapsItems0 `json:"lun_maps,omitempty"`

	// metric
	Metric *LunMetric `json:"metric,omitempty"`

	// movement
	Movement *LunMovement `json:"movement,omitempty"`

	// The fully qualified path name of the LUN composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN. Valid in POST and PATCH.<br/>
	// A PATCH that modifies the qtree and/or base name portion of the LUN path is considered a rename operation.<br/>
	// A PATCH that modifies the volume portion of the LUN path begins an asynchronous LUN movement operation.
	//
	// Example: /vol/volume1/qtree1/lun1
	Name string `json:"name,omitempty"`

	// The operating system type of the LUN.<br/>
	// Required in POST when creating a LUN that is not a clone of another. Disallowed in POST when creating a LUN clone.
	//
	// Enum: [aix hpux hyper_v linux netware openvms solaris solaris_efi vmware windows windows_2008 windows_gpt xen]
	OsType string `json:"os_type,omitempty"`

	// qos policy
	QosPolicy *LunQosPolicy `json:"qos_policy,omitempty"`

	// The LUN serial number. The serial number is generated by ONTAP when the LUN is created.
	//
	// Read Only: true
	// Max Length: 12
	// Min Length: 12
	SerialNumber string `json:"serial_number,omitempty"`

	// space
	Space *LunSpace `json:"space,omitempty"`

	// statistics
	Statistics *LunStatistics `json:"statistics,omitempty"`

	// status
	Status *LunStatus `json:"status,omitempty"`

	// svm
	Svm *LunSvm `json:"svm,omitempty"`

	// The unique identifier of the LUN.  The UUID is generated by ONTAP when the LUN is created.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// vvol
	Vvol *LunVvol `json:"vvol,omitempty"`
}

// Validate validates this lun
func (m *Lun) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsistencyGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCopy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLunMaps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMovement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQosPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVvol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Lun) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.Attributes) { // not required
		return nil
	}

	for i := 0; i < len(m.Attributes); i++ {
		if swag.IsZero(m.Attributes[i]) { // not required
			continue
		}

		if m.Attributes[i] != nil {
			if err := m.Attributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var lunTypeClassPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["regular","protocol_endpoint","vvol"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunTypeClassPropEnum = append(lunTypeClassPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun
	// Lun
	// class
	// Class
	// regular
	// END DEBUGGING
	// LunClassRegular captures enum value "regular"
	LunClassRegular string = "regular"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// class
	// Class
	// protocol_endpoint
	// END DEBUGGING
	// LunClassProtocolEndpoint captures enum value "protocol_endpoint"
	LunClassProtocolEndpoint string = "protocol_endpoint"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// class
	// Class
	// vvol
	// END DEBUGGING
	// LunClassVvol captures enum value "vvol"
	LunClassVvol string = "vvol"
)

// prop value enum
func (m *Lun) validateClassEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunTypeClassPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Lun) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(m.Class) { // not required
		return nil
	}

	// value enum
	if err := m.validateClassEnum("class", "body", *m.Class); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateClone(formats strfmt.Registry) error {
	if swag.IsZero(m.Clone) { // not required
		return nil
	}

	if m.Clone != nil {
		if err := m.Clone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if err := validate.MinLength("comment", "body", *m.Comment, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 254); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateConsistencyGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ConsistencyGroup) { // not required
		return nil
	}

	if m.ConsistencyGroup != nil {
		if err := m.ConsistencyGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateCopy(formats strfmt.Registry) error {
	if swag.IsZero(m.Copy) { // not required
		return nil
	}

	if m.Copy != nil {
		if err := m.Copy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateCreateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("create_time", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.Location) { // not required
		return nil
	}

	if m.Location != nil {
		if err := m.Location.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateLunMaps(formats strfmt.Registry) error {
	if swag.IsZero(m.LunMaps) { // not required
		return nil
	}

	for i := 0; i < len(m.LunMaps); i++ {
		if swag.IsZero(m.LunMaps[i]) { // not required
			continue
		}

		if m.LunMaps[i] != nil {
			if err := m.LunMaps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Lun) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateMovement(formats strfmt.Registry) error {
	if swag.IsZero(m.Movement) { // not required
		return nil
	}

	if m.Movement != nil {
		if err := m.Movement.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

var lunTypeOsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["aix","hpux","hyper_v","linux","netware","openvms","solaris","solaris_efi","vmware","windows","windows_2008","windows_gpt","xen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunTypeOsTypePropEnum = append(lunTypeOsTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// aix
	// END DEBUGGING
	// LunOsTypeAix captures enum value "aix"
	LunOsTypeAix string = "aix"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// hpux
	// END DEBUGGING
	// LunOsTypeHpux captures enum value "hpux"
	LunOsTypeHpux string = "hpux"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// hyper_v
	// END DEBUGGING
	// LunOsTypeHyperv captures enum value "hyper_v"
	LunOsTypeHyperv string = "hyper_v"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// linux
	// END DEBUGGING
	// LunOsTypeLinux captures enum value "linux"
	LunOsTypeLinux string = "linux"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// netware
	// END DEBUGGING
	// LunOsTypeNetware captures enum value "netware"
	LunOsTypeNetware string = "netware"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// openvms
	// END DEBUGGING
	// LunOsTypeOpenvms captures enum value "openvms"
	LunOsTypeOpenvms string = "openvms"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// solaris
	// END DEBUGGING
	// LunOsTypeSolaris captures enum value "solaris"
	LunOsTypeSolaris string = "solaris"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// solaris_efi
	// END DEBUGGING
	// LunOsTypeSolarisEfi captures enum value "solaris_efi"
	LunOsTypeSolarisEfi string = "solaris_efi"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// vmware
	// END DEBUGGING
	// LunOsTypeVmware captures enum value "vmware"
	LunOsTypeVmware string = "vmware"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// windows
	// END DEBUGGING
	// LunOsTypeWindows captures enum value "windows"
	LunOsTypeWindows string = "windows"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// windows_2008
	// END DEBUGGING
	// LunOsTypeWindows2008 captures enum value "windows_2008"
	LunOsTypeWindows2008 string = "windows_2008"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// windows_gpt
	// END DEBUGGING
	// LunOsTypeWindowsGpt captures enum value "windows_gpt"
	LunOsTypeWindowsGpt string = "windows_gpt"

	// BEGIN DEBUGGING
	// lun
	// Lun
	// os_type
	// OsType
	// xen
	// END DEBUGGING
	// LunOsTypeXen captures enum value "xen"
	LunOsTypeXen string = "xen"
)

// prop value enum
func (m *Lun) validateOsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunTypeOsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Lun) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOsTypeEnum("os_type", "body", m.OsType); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateQosPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.QosPolicy) { // not required
		return nil
	}

	if m.QosPolicy != nil {
		if err := m.QosPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateSerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.SerialNumber) { // not required
		return nil
	}

	if err := validate.MinLength("serial_number", "body", m.SerialNumber, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("serial_number", "body", m.SerialNumber, 12); err != nil {
		return err
	}

	return nil
}

func (m *Lun) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) validateVvol(formats strfmt.Registry) error {
	if swag.IsZero(m.Vvol) { // not required
		return nil
	}

	if m.Vvol != nil {
		if err := m.Vvol.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vvol")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun based on the context it is used
func (m *Lun) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConsistencyGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCopy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLunMaps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMovement(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQosPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerialNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVvol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Lun) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Attributes); i++ {

		if m.Attributes[i] != nil {
			if err := m.Attributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Lun) contextValidateClone(ctx context.Context, formats strfmt.Registry) error {

	if m.Clone != nil {
		if err := m.Clone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateConsistencyGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ConsistencyGroup != nil {
		if err := m.ConsistencyGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateCopy(ctx context.Context, formats strfmt.Registry) error {

	if m.Copy != nil {
		if err := m.Copy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", m.CreateTime); err != nil {
		return err
	}

	return nil
}

func (m *Lun) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.Location != nil {
		if err := m.Location.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateLunMaps(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lun_maps", "body", []*LunLunMapsItems0(m.LunMaps)); err != nil {
		return err
	}

	for i := 0; i < len(m.LunMaps); i++ {

		if m.LunMaps[i] != nil {
			if err := m.LunMaps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lun_maps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Lun) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateMovement(ctx context.Context, formats strfmt.Registry) error {

	if m.Movement != nil {
		if err := m.Movement.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateQosPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.QosPolicy != nil {
		if err := m.QosPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateSerialNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "serial_number", "body", string(m.SerialNumber)); err != nil {
		return err
	}

	return nil
}

func (m *Lun) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *Lun) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

func (m *Lun) contextValidateVvol(ctx context.Context, formats strfmt.Registry) error {

	if m.Vvol != nil {
		if err := m.Vvol.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vvol")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Lun) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Lun) UnmarshalBinary(b []byte) error {
	var res Lun
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunAttributesItems0 A name/value pair optionally stored with the LUN. Attributes are available to callers to persist small amounts of application-specific metadata. They are in no way interpreted by ONTAP.<br/>
// Attribute names and values must be at least one byte and no more than 4091 bytes in length. The sum of the name and value lengths must be no more than 4092 bytes.<br/>
// Optional in POST.
//
//
// swagger:model LunAttributesItems0
type LunAttributesItems0 struct {

	// links
	Links *LunAttributesItems0Links `json:"_links,omitempty"`

	// The attribute name.
	//
	// Example: name1
	// Max Length: 4091
	// Min Length: 1
	Name string `json:"name,omitempty"`

	// The attribute value.
	//
	// Example: value1
	// Max Length: 4091
	// Min Length: 1
	Value string `json:"value,omitempty"`
}

// Validate validates this lun attributes items0
func (m *LunAttributesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunAttributesItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunAttributesItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 4091); err != nil {
		return err
	}

	return nil
}

func (m *LunAttributesItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(m.Value) { // not required
		return nil
	}

	if err := validate.MinLength("value", "body", m.Value, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("value", "body", m.Value, 4091); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun attributes items0 based on the context it is used
func (m *LunAttributesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunAttributesItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunAttributesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunAttributesItems0) UnmarshalBinary(b []byte) error {
	var res LunAttributesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunAttributesItems0Links lun attributes items0 links
//
// swagger:model LunAttributesItems0Links
type LunAttributesItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun attributes items0 links
func (m *LunAttributesItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunAttributesItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun attributes items0 links based on the context it is used
func (m *LunAttributesItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunAttributesItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunAttributesItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunAttributesItems0Links) UnmarshalBinary(b []byte) error {
	var res LunAttributesItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunClone This sub-object is used in POST to create a new LUN as a clone of an existing LUN, or PATCH to overwrite an existing LUN as a clone of another. Setting a property in this sub-object indicates that a LUN clone is desired. Consider the following other properties when cloning a LUN: `auto_delete`, `qos_policy`, `space.guarantee.requested` and `space.scsi_thin_provisioning_support_enabled`.<br/>
// When used in a PATCH, the patched LUN's data is over-written as a clone of the source and the following properties are preserved from the patched LUN unless otherwise specified as part of the PATCH: `class`, `auto_delete`, `lun_maps`, `serial_number`, `status.state`, and `uuid`.<br/>
// Persistent reservations for the patched LUN are also preserved.
//
//
// swagger:model LunClone
type LunClone struct {

	// source
	Source *LunCloneSource `json:"source,omitempty"`
}

// Validate validates this lun clone
func (m *LunClone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunClone) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun clone based on the context it is used
func (m *LunClone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunClone) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clone" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunClone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunClone) UnmarshalBinary(b []byte) error {
	var res LunClone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCloneSource The source LUN for a LUN clone operation. This can be specified using property `clone.source.uuid` or `clone.source.name`. If both properties are supplied, they must refer to the same LUN.<br/>
// Valid in POST to create a new LUN as a clone of the source.<br/>
// Valid in PATCH to overwrite an existing LUN's data as a clone of another.
//
//
// swagger:model LunCloneSource
type LunCloneSource struct {

	// The fully qualified path name of the clone source LUN composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN. Valid in POST and PATCH.
	//
	// Example: /vol/volume1/lun1
	Name string `json:"name,omitempty"`

	// The unique identifier of the clone source LUN. Valid in POST and PATCH.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun clone source
func (m *LunCloneSource) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this lun clone source based on context it is used
func (m *LunCloneSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LunCloneSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCloneSource) UnmarshalBinary(b []byte) error {
	var res LunCloneSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunConsistencyGroup The LUN's consistency group. This property is populated for LUNs whose volume is a member of a consistency group. If the volume is a member of a child consistency group, the parent consistency group is reported.
//
//
// swagger:model LunConsistencyGroup
type LunConsistencyGroup struct {

	// links
	Links *LunConsistencyGroupLinks `json:"_links,omitempty"`

	// The name of the consistency group.
	//
	// Example: cg1
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The unique identifier of the consistency group.
	//
	// Example: 4abc2317-4332-9d37-93a0-20bd29c22df0
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun consistency group
func (m *LunConsistencyGroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunConsistencyGroup) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun consistency group based on the context it is used
func (m *LunConsistencyGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunConsistencyGroup) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunConsistencyGroup) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "consistency_group"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *LunConsistencyGroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "consistency_group"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunConsistencyGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunConsistencyGroup) UnmarshalBinary(b []byte) error {
	var res LunConsistencyGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunConsistencyGroupLinks lun consistency group links
//
// swagger:model LunConsistencyGroupLinks
type LunConsistencyGroupLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun consistency group links
func (m *LunConsistencyGroupLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunConsistencyGroupLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun consistency group links based on the context it is used
func (m *LunConsistencyGroupLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunConsistencyGroupLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("consistency_group" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunConsistencyGroupLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunConsistencyGroupLinks) UnmarshalBinary(b []byte) error {
	var res LunConsistencyGroupLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopy This sub-object applies to LUN copy operations. A LUN can be copied with a POST request that supplies `copy.source` properties.<br/>
// Copying a LUN is an asynchronous activity begun by a POST request that specifies the source of the copy in the `copy.source` properties. The data for the LUN is then asynchronously copied from the source to the destination. The time required to complete the copy depends on the size of the LUN and the load on the cluster. The `copy` sub-object is populated while a LUN copy is in progress and for two (2) minutes following completion of a copy.<br/>
// While LUNs are being copied, the status of the LUN copy operations can be obtained using a GET of the source or destination LUN that requests the `copy` properties. If the LUN is the source LUN for one or more copy operations, the `copy.destinations` array is populated in GET. If the containing LUN is the destination LUN for a copy operation, the `copy.source` sub-object is populated in GET. The LUN copy operation can be further modified using a PATCH on the properties on the `copy.source` sub-object of the copy destination LUN.<br/>
// There is an added cost to retrieving property values for `copy`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
//
//
// swagger:model LunCopy
type LunCopy struct {

	// An array of destination LUNs of LUN copy operations in which the containing LUN is the source of the copy.
	//
	// Read Only: true
	Destinations []*LunCopyDestinationsItems0 `json:"destinations,omitempty"`

	// source
	Source *LunCopySource `json:"source,omitempty"`
}

// Validate validates this lun copy
func (m *LunCopy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDestinations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopy) validateDestinations(formats strfmt.Registry) error {
	if swag.IsZero(m.Destinations) { // not required
		return nil
	}

	for i := 0; i < len(m.Destinations); i++ {
		if swag.IsZero(m.Destinations[i]) { // not required
			continue
		}

		if m.Destinations[i] != nil {
			if err := m.Destinations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copy" + "." + "destinations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LunCopy) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun copy based on the context it is used
func (m *LunCopy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestinations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopy) contextValidateDestinations(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"destinations", "body", []*LunCopyDestinationsItems0(m.Destinations)); err != nil {
		return err
	}

	for i := 0; i < len(m.Destinations); i++ {

		if m.Destinations[i] != nil {
			if err := m.Destinations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copy" + "." + "destinations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LunCopy) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopy) UnmarshalBinary(b []byte) error {
	var res LunCopy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopyDestinationsItems0 A LUN copy operation in which the containing LUN is the source of the copy.
//
//
// swagger:model LunCopyDestinationsItems0
type LunCopyDestinationsItems0 struct {

	// links
	Links *LunCopyDestinationsItems0Links `json:"_links,omitempty"`

	// The maximum data throughput, in bytes per second, that should be utilized in support of the LUN copy. See property `copy.source.max_throughput` for further details.
	//
	// Read Only: true
	MaxThroughput int64 `json:"max_throughput,omitempty"`

	// The fully qualified path of the LUN copy destination composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.
	//
	// Example: /vol/vol1/lun1
	// Read Only: true
	Name string `json:"name,omitempty"`

	// progress
	Progress *LunCopyDestinationsItems0Progress `json:"progress,omitempty"`

	// The unique identifier of the LUN copy destination.
	//
	// Example: 1bc327d5-4654-5284-a116-f182282240b4
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun copy destinations items0
func (m *LunCopyDestinationsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun copy destinations items0 based on the context it is used
func (m *LunCopyDestinationsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateMaxThroughput(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "max_throughput", "body", int64(m.MaxThroughput)); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {
		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopyDestinationsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopyDestinationsItems0) UnmarshalBinary(b []byte) error {
	var res LunCopyDestinationsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopyDestinationsItems0Links lun copy destinations items0 links
//
// swagger:model LunCopyDestinationsItems0Links
type LunCopyDestinationsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun copy destinations items0 links
func (m *LunCopyDestinationsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun copy destinations items0 links based on the context it is used
func (m *LunCopyDestinationsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Links) UnmarshalBinary(b []byte) error {
	var res LunCopyDestinationsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopyDestinationsItems0Progress Properties related to the progress of an active or recently completed LUN copy.
//
//
// swagger:model LunCopyDestinationsItems0Progress
type LunCopyDestinationsItems0Progress struct {

	// The amount of time that has elapsed since the start of the LUN copy, in seconds.
	//
	// Read Only: true
	Elapsed int64 `json:"elapsed,omitempty"`

	// Error information provided if the asynchronous LUN copy operation fails.
	//
	// Read Only: true
	Failure *Error `json:"failure,omitempty"`

	// The percentage completed of the LUN copy.
	//
	// Read Only: true
	// Maximum: 100
	// Minimum: 0
	PercentComplete int64 `json:"percent_complete,omitempty"`

	// The state of the LUN copy.
	//
	// Read Only: true
	// Enum: [preparing replicating paused paused_error complete reverting failed]
	State string `json:"state,omitempty"`

	// This property reports if volume Snapshot copies are blocked by the LUN copy. This property can be polled to identify when volume Snapshot copies can be resumed after beginning a LUN copy.
	//
	// Read Only: true
	VolumeSnapshotBlocked *bool `json:"volume_snapshot_blocked,omitempty"`
}

// Validate validates this lun copy destinations items0 progress
func (m *LunCopyDestinationsItems0Progress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePercentComplete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Progress) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) validatePercentComplete(formats strfmt.Registry) error {
	if swag.IsZero(m.PercentComplete) { // not required
		return nil
	}

	if err := validate.MinimumInt("progress"+"."+"percent_complete", "body", m.PercentComplete, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("progress"+"."+"percent_complete", "body", m.PercentComplete, 100, false); err != nil {
		return err
	}

	return nil
}

var lunCopyDestinationsItems0ProgressTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["preparing","replicating","paused","paused_error","complete","reverting","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunCopyDestinationsItems0ProgressTypeStatePropEnum = append(lunCopyDestinationsItems0ProgressTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// preparing
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStatePreparing captures enum value "preparing"
	LunCopyDestinationsItems0ProgressStatePreparing string = "preparing"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// replicating
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateReplicating captures enum value "replicating"
	LunCopyDestinationsItems0ProgressStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// paused
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStatePaused captures enum value "paused"
	LunCopyDestinationsItems0ProgressStatePaused string = "paused"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// paused_error
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStatePausedError captures enum value "paused_error"
	LunCopyDestinationsItems0ProgressStatePausedError string = "paused_error"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// complete
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateComplete captures enum value "complete"
	LunCopyDestinationsItems0ProgressStateComplete string = "complete"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// reverting
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateReverting captures enum value "reverting"
	LunCopyDestinationsItems0ProgressStateReverting string = "reverting"

	// BEGIN DEBUGGING
	// LunCopyDestinationsItems0Progress
	// LunCopyDestinationsItems0Progress
	// state
	// State
	// failed
	// END DEBUGGING
	// LunCopyDestinationsItems0ProgressStateFailed captures enum value "failed"
	LunCopyDestinationsItems0ProgressStateFailed string = "failed"
)

// prop value enum
func (m *LunCopyDestinationsItems0Progress) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunCopyDestinationsItems0ProgressTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunCopyDestinationsItems0Progress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("progress"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun copy destinations items0 progress based on the context it is used
func (m *LunCopyDestinationsItems0Progress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateElapsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeSnapshotBlocked(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateElapsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"elapsed", "body", int64(m.Elapsed)); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"percent_complete", "body", int64(m.PercentComplete)); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *LunCopyDestinationsItems0Progress) contextValidateVolumeSnapshotBlocked(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "progress"+"."+"volume_snapshot_blocked", "body", m.VolumeSnapshotBlocked); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Progress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopyDestinationsItems0Progress) UnmarshalBinary(b []byte) error {
	var res LunCopyDestinationsItems0Progress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopySource The source LUN of a LUN copy operation in which the containing LUN is the destination of the copy.<br/>
// Valid in POST except when creating a LUN clone. A LUN copy request cannot be combined with setting any other LUN properties except the destination location. All other properties of the destination LUN come from the source LUN.
//
//
// swagger:model LunCopySource
type LunCopySource struct {

	// links
	Links *LunCopySourceLinks `json:"_links,omitempty"`

	// The maximum data throughput, in bytes per second, that should be utilized in support of the LUN copy. This property can be used to throttle a transfer and limit its impact on the performance of the source and destination nodes. The specified value will be rounded up to the nearest megabyte.<br/>
	// If this property is not specified in a POST that begins a LUN copy, throttling is not applied to the data transfer.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.<br/>
	// Valid only in a POST that begins a LUN copy or a PATCH when a LUN copy is already in process.
	//
	MaxThroughput int64 `json:"max_throughput,omitempty"`

	// The fully qualified path of the LUN copy source composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.<br/>
	// Set this property in POST to specify the source for a LUN copy operation.
	//
	// Example: /vol/vol2/lun1
	Name string `json:"name,omitempty"`

	// progress
	Progress *LunCopySourceProgress `json:"progress,omitempty"`

	// The unique identifier of the LUN copy source.<br/>
	// Set this property in POST to specify the source for a LUN copy operation.
	//
	// Example: 03c05019-40d9-3945-c767-dca4c3be5e90
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun copy source
func (m *LunCopySource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopySource) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopySource) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun copy source based on the context it is used
func (m *LunCopySource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopySource) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopySource) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {
		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopySource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopySource) UnmarshalBinary(b []byte) error {
	var res LunCopySource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopySourceLinks lun copy source links
//
// swagger:model LunCopySourceLinks
type LunCopySourceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun copy source links
func (m *LunCopySourceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopySourceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun copy source links based on the context it is used
func (m *LunCopySourceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopySourceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopySourceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopySourceLinks) UnmarshalBinary(b []byte) error {
	var res LunCopySourceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunCopySourceProgress Properties related to the progress of an active or recently completed LUN copy.
//
//
// swagger:model LunCopySourceProgress
type LunCopySourceProgress struct {

	// The amount of time that has elapsed since the start of the LUN copy, in seconds.
	//
	// Read Only: true
	Elapsed int64 `json:"elapsed,omitempty"`

	// Error information provided if the asynchronous LUN copy operation fails.
	//
	// Read Only: true
	Failure *Error `json:"failure,omitempty"`

	// The percentage completed of the LUN copy.
	//
	// Read Only: true
	// Maximum: 100
	// Minimum: 0
	PercentComplete int64 `json:"percent_complete,omitempty"`

	// The state of the LUN copy.<br/>
	// Valid in PATCH when an LUN copy is active. Set to _paused_ to pause a LUN copy. Set to _replicating_ to resume a paused LUN copy.
	//
	// Enum: [preparing replicating paused paused_error complete reverting failed]
	State string `json:"state,omitempty"`

	// This property reports if volume Snapshot copies are blocked by the LUN copy. This property can be polled to identify when volume Snapshot copies can be resumed after beginning a LUN copy.
	//
	// Read Only: true
	VolumeSnapshotBlocked *bool `json:"volume_snapshot_blocked,omitempty"`
}

// Validate validates this lun copy source progress
func (m *LunCopySourceProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePercentComplete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopySourceProgress) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopySourceProgress) validatePercentComplete(formats strfmt.Registry) error {
	if swag.IsZero(m.PercentComplete) { // not required
		return nil
	}

	if err := validate.MinimumInt("copy"+"."+"source"+"."+"progress"+"."+"percent_complete", "body", m.PercentComplete, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("copy"+"."+"source"+"."+"progress"+"."+"percent_complete", "body", m.PercentComplete, 100, false); err != nil {
		return err
	}

	return nil
}

var lunCopySourceProgressTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["preparing","replicating","paused","paused_error","complete","reverting","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunCopySourceProgressTypeStatePropEnum = append(lunCopySourceProgressTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunCopySourceProgress
	// LunCopySourceProgress
	// state
	// State
	// preparing
	// END DEBUGGING
	// LunCopySourceProgressStatePreparing captures enum value "preparing"
	LunCopySourceProgressStatePreparing string = "preparing"

	// BEGIN DEBUGGING
	// LunCopySourceProgress
	// LunCopySourceProgress
	// state
	// State
	// replicating
	// END DEBUGGING
	// LunCopySourceProgressStateReplicating captures enum value "replicating"
	LunCopySourceProgressStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// LunCopySourceProgress
	// LunCopySourceProgress
	// state
	// State
	// paused
	// END DEBUGGING
	// LunCopySourceProgressStatePaused captures enum value "paused"
	LunCopySourceProgressStatePaused string = "paused"

	// BEGIN DEBUGGING
	// LunCopySourceProgress
	// LunCopySourceProgress
	// state
	// State
	// paused_error
	// END DEBUGGING
	// LunCopySourceProgressStatePausedError captures enum value "paused_error"
	LunCopySourceProgressStatePausedError string = "paused_error"

	// BEGIN DEBUGGING
	// LunCopySourceProgress
	// LunCopySourceProgress
	// state
	// State
	// complete
	// END DEBUGGING
	// LunCopySourceProgressStateComplete captures enum value "complete"
	LunCopySourceProgressStateComplete string = "complete"

	// BEGIN DEBUGGING
	// LunCopySourceProgress
	// LunCopySourceProgress
	// state
	// State
	// reverting
	// END DEBUGGING
	// LunCopySourceProgressStateReverting captures enum value "reverting"
	LunCopySourceProgressStateReverting string = "reverting"

	// BEGIN DEBUGGING
	// LunCopySourceProgress
	// LunCopySourceProgress
	// state
	// State
	// failed
	// END DEBUGGING
	// LunCopySourceProgressStateFailed captures enum value "failed"
	LunCopySourceProgressStateFailed string = "failed"
)

// prop value enum
func (m *LunCopySourceProgress) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunCopySourceProgressTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunCopySourceProgress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("copy"+"."+"source"+"."+"progress"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun copy source progress based on the context it is used
func (m *LunCopySourceProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateElapsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeSnapshotBlocked(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunCopySourceProgress) contextValidateElapsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"source"+"."+"progress"+"."+"elapsed", "body", int64(m.Elapsed)); err != nil {
		return err
	}

	return nil
}

func (m *LunCopySourceProgress) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("copy" + "." + "source" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunCopySourceProgress) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"source"+"."+"progress"+"."+"percent_complete", "body", int64(m.PercentComplete)); err != nil {
		return err
	}

	return nil
}

func (m *LunCopySourceProgress) contextValidateVolumeSnapshotBlocked(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "copy"+"."+"source"+"."+"progress"+"."+"volume_snapshot_blocked", "body", m.VolumeSnapshotBlocked); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunCopySourceProgress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunCopySourceProgress) UnmarshalBinary(b []byte) error {
	var res LunCopySourceProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLinks lun links
//
// swagger:model LunLinks
type LunLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun links
func (m *LunLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun links based on the context it is used
func (m *LunLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLinks) UnmarshalBinary(b []byte) error {
	var res LunLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLocation The location of the LUN within the ONTAP cluster. Valid in POST and PATCH.
//
//
// swagger:model LunLocation
type LunLocation struct {

	// The base name component of the LUN. Valid in POST and PATCH.<br/>
	// If properties `name` and `location.logical_unit` are specified in the same request, they must refer to the base name.<br/>
	// A PATCH that modifies the base name of the LUN is considered a rename operation.
	//
	// Example: lun1
	LogicalUnit string `json:"logical_unit,omitempty"`

	// node
	Node *LunLocationNode `json:"node,omitempty"`

	// qtree
	Qtree *LunLocationQtree `json:"qtree,omitempty"`

	// volume
	Volume *LunLocationVolume `json:"volume,omitempty"`
}

// Validate validates this lun location
func (m *LunLocation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQtree(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocation) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *LunLocation) validateQtree(formats strfmt.Registry) error {
	if swag.IsZero(m.Qtree) { // not required
		return nil
	}

	if m.Qtree != nil {
		if err := m.Qtree.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree")
			}
			return err
		}
	}

	return nil
}

func (m *LunLocation) validateVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.Volume) { // not required
		return nil
	}

	if m.Volume != nil {
		if err := m.Volume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun location based on the context it is used
func (m *LunLocation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQtree(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocation) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *LunLocation) contextValidateQtree(ctx context.Context, formats strfmt.Registry) error {

	if m.Qtree != nil {
		if err := m.Qtree.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree")
			}
			return err
		}
	}

	return nil
}

func (m *LunLocation) contextValidateVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.Volume != nil {
		if err := m.Volume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLocation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLocation) UnmarshalBinary(b []byte) error {
	var res LunLocation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLocationNode The cluster node that hosts the LUN.
//
//
// swagger:model LunLocationNode
type LunLocationNode struct {

	// links
	Links *LunLocationNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun location node
func (m *LunLocationNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun location node based on the context it is used
func (m *LunLocationNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLocationNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLocationNode) UnmarshalBinary(b []byte) error {
	var res LunLocationNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLocationNodeLinks lun location node links
//
// swagger:model LunLocationNodeLinks
type LunLocationNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun location node links
func (m *LunLocationNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun location node links based on the context it is used
func (m *LunLocationNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLocationNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLocationNodeLinks) UnmarshalBinary(b []byte) error {
	var res LunLocationNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLocationQtree The qtree in which the LUN is optionally located. Valid in POST and PATCH.<br/>
// If properties `name` and `location.qtree.name` and/or `location.qtree.uuid` are specified in the same request, they must refer to the same qtree.<br/>
// A PATCH that modifies the qtree of the LUN is considered a rename operation.
//
//
// swagger:model LunLocationQtree
type LunLocationQtree struct {

	// links
	Links *LunLocationQtreeLinks `json:"_links,omitempty"`

	// The identifier for the qtree, unique within the qtree's volume.
	//
	// Example: 1
	// Maximum: 4994
	// Minimum: 0
	ID *int64 `json:"id,omitempty"`

	// The name of the qtree.
	// Example: qt1
	Name string `json:"name,omitempty"`
}

// Validate validates this lun location qtree
func (m *LunLocationQtree) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationQtree) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunLocationQtree) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinimumInt("location"+"."+"qtree"+"."+"id", "body", *m.ID, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("location"+"."+"qtree"+"."+"id", "body", *m.ID, 4994, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun location qtree based on the context it is used
func (m *LunLocationQtree) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationQtree) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLocationQtree) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLocationQtree) UnmarshalBinary(b []byte) error {
	var res LunLocationQtree
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLocationQtreeLinks lun location qtree links
//
// swagger:model LunLocationQtreeLinks
type LunLocationQtreeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun location qtree links
func (m *LunLocationQtreeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationQtreeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun location qtree links based on the context it is used
func (m *LunLocationQtreeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationQtreeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "qtree" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLocationQtreeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLocationQtreeLinks) UnmarshalBinary(b []byte) error {
	var res LunLocationQtreeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLocationVolume The volume in which the LUN is located. Valid in POST and PATCH.<br/>
// If properties `name` and `location.volume.name` and/or `location.volume.uuid` are specified in the same request, they must refer to the same volume.<br/>
// A PATCH that modifies the volume of the LUN begins an asynchronous LUN movement operation.
//
//
// swagger:model LunLocationVolume
type LunLocationVolume struct {

	// links
	Links *LunLocationVolumeLinks `json:"_links,omitempty"`

	// The name of the volume.
	// Example: volume1
	Name string `json:"name,omitempty"`

	// Unique identifier for the volume. This corresponds to the instance-uuid that is exposed in the CLI and ONTAPI. It does not change due to a volume move.
	// Example: 028baa66-41bd-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun location volume
func (m *LunLocationVolume) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationVolume) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun location volume based on the context it is used
func (m *LunLocationVolume) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationVolume) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLocationVolume) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLocationVolume) UnmarshalBinary(b []byte) error {
	var res LunLocationVolume
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLocationVolumeLinks lun location volume links
//
// swagger:model LunLocationVolumeLinks
type LunLocationVolumeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun location volume links
func (m *LunLocationVolumeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationVolumeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun location volume links based on the context it is used
func (m *LunLocationVolumeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLocationVolumeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "volume" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLocationVolumeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLocationVolumeLinks) UnmarshalBinary(b []byte) error {
	var res LunLocationVolumeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLunMapsItems0 A LUN map with which the LUN is associated.
//
//
// swagger:model LunLunMapsItems0
type LunLunMapsItems0 struct {

	// links
	Links *LunLunMapsItems0Links `json:"_links,omitempty"`

	// igroup
	Igroup *LunLunMapsItems0Igroup `json:"igroup,omitempty"`

	// The logical unit number assigned to the LUN for initiators in the initiator group.
	//
	// Read Only: true
	LogicalUnitNumber int64 `json:"logical_unit_number,omitempty"`
}

// Validate validates this lun lun maps items0
func (m *LunLunMapsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunLunMapsItems0) validateIgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Igroup) { // not required
		return nil
	}

	if m.Igroup != nil {
		if err := m.Igroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun lun maps items0 based on the context it is used
func (m *LunLunMapsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalUnitNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunLunMapsItems0) contextValidateIgroup(ctx context.Context, formats strfmt.Registry) error {

	if m.Igroup != nil {
		if err := m.Igroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup")
			}
			return err
		}
	}

	return nil
}

func (m *LunLunMapsItems0) contextValidateLogicalUnitNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "logical_unit_number", "body", int64(m.LogicalUnitNumber)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLunMapsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLunMapsItems0) UnmarshalBinary(b []byte) error {
	var res LunLunMapsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLunMapsItems0Igroup The initiator group to which the LUN is mapped.
//
//
// swagger:model LunLunMapsItems0Igroup
type LunLunMapsItems0Igroup struct {

	// links
	Links *LunLunMapsItems0IgroupLinks `json:"_links,omitempty"`

	// The name of the initiator group.
	//
	// Example: igroup1
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The unique identifier of the initiator group.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun lun maps items0 igroup
func (m *LunLunMapsItems0Igroup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0Igroup) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun lun maps items0 igroup based on the context it is used
func (m *LunLunMapsItems0Igroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0Igroup) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunLunMapsItems0Igroup) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "igroup"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *LunLunMapsItems0Igroup) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "igroup"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLunMapsItems0Igroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLunMapsItems0Igroup) UnmarshalBinary(b []byte) error {
	var res LunLunMapsItems0Igroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLunMapsItems0IgroupLinks lun lun maps items0 igroup links
//
// swagger:model LunLunMapsItems0IgroupLinks
type LunLunMapsItems0IgroupLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun lun maps items0 igroup links
func (m *LunLunMapsItems0IgroupLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0IgroupLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun lun maps items0 igroup links based on the context it is used
func (m *LunLunMapsItems0IgroupLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0IgroupLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("igroup" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLunMapsItems0IgroupLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLunMapsItems0IgroupLinks) UnmarshalBinary(b []byte) error {
	var res LunLunMapsItems0IgroupLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunLunMapsItems0Links lun lun maps items0 links
//
// swagger:model LunLunMapsItems0Links
type LunLunMapsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun lun maps items0 links
func (m *LunLunMapsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun lun maps items0 links based on the context it is used
func (m *LunLunMapsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunLunMapsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunLunMapsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunLunMapsItems0Links) UnmarshalBinary(b []byte) error {
	var res LunLunMapsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMetric Performance numbers, such as IOPS latency and throughput.
//
// swagger:model LunMetric
type LunMetric struct {

	// links
	Links *LunMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *LunMetricIops `json:"iops,omitempty"`

	// latency
	Latency *LunMetricLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *LunMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this lun metric
func (m *LunMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var lunMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunMetricTypeDurationPropEnum = append(lunMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// LunMetricDurationPT15S captures enum value "PT15S"
	LunMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// LunMetricDurationPT4M captures enum value "PT4M"
	LunMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// LunMetricDurationPT30M captures enum value "PT30M"
	LunMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// LunMetricDurationPT2H captures enum value "PT2H"
	LunMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// LunMetricDurationP1D captures enum value "P1D"
	LunMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// LunMetricDurationPT5M captures enum value "PT5M"
	LunMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *LunMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *LunMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *LunMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var lunMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunMetricTypeStatusPropEnum = append(lunMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// LunMetricStatusOk captures enum value "ok"
	LunMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// LunMetricStatusError captures enum value "error"
	LunMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// LunMetricStatusPartialNoData captures enum value "partial_no_data"
	LunMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// LunMetricStatusPartialNoResponse captures enum value "partial_no_response"
	LunMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// LunMetricStatusPartialOtherError captures enum value "partial_other_error"
	LunMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// LunMetricStatusNegativeDelta captures enum value "negative_delta"
	LunMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// not_found
	// END DEBUGGING
	// LunMetricStatusNotFound captures enum value "not_found"
	LunMetricStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// LunMetricStatusBackfilledData captures enum value "backfilled_data"
	LunMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// LunMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	LunMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// LunMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	LunMetricStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// LunMetric
	// LunMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// LunMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	LunMetricStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *LunMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *LunMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *LunMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun metric based on the context it is used
func (m *LunMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *LunMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *LunMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *LunMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *LunMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *LunMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMetric) UnmarshalBinary(b []byte) error {
	var res LunMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model LunMetricIops
type LunMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this lun metric iops
func (m *LunMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun metric iops based on the context it is used
func (m *LunMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMetricIops) UnmarshalBinary(b []byte) error {
	var res LunMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model LunMetricLatency
type LunMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this lun metric latency
func (m *LunMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun metric latency based on the context it is used
func (m *LunMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMetricLatency) UnmarshalBinary(b []byte) error {
	var res LunMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMetricLinks lun metric links
//
// swagger:model LunMetricLinks
type LunMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun metric links
func (m *LunMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun metric links based on the context it is used
func (m *LunMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMetricLinks) UnmarshalBinary(b []byte) error {
	var res LunMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model LunMetricThroughput
type LunMetricThroughput struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this lun metric throughput
func (m *LunMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun metric throughput based on the context it is used
func (m *LunMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMetricThroughput) UnmarshalBinary(b []byte) error {
	var res LunMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMovement This sub-object applies to LUN movement between volumes. A LUN can be moved to a new volume with a PATCH request that changes either the volume portion of property `name`, `location.volume.uuid`, or `location.volume.name`. If the volume is changed using more than one of these properties, the supplied properties used must refer to the same volume.<br/>
// Moving a LUN between volumes is an asynchronous activity begun by a PATCH request. The data for the LUN is then asynchronously copied from the source volume to the destination volume. The time required to complete the move depends on the size of the LUN and the load on the cluster. The `movement` sub-object is populated while a LUN movement is in progress and for two (2) minutes following completion of a movement.<br/>
// While the LUN is being moved, the status of the LUN movement operation can be obtained using a GET for the LUN that requests the `movement` properties. The LUN movement operation can be further modified using a PATCH on the properties on the `movement` sub-object.<br/>
// There is an added cost to retrieving property values for `movement`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
//
//
// swagger:model LunMovement
type LunMovement struct {

	// The maximum data throughput, in bytes per second, that should be utilized in support of the LUN movement. This property can be used to throttle a transfer and limit its impact on the performance of the source and destination nodes. The specified value will be rounded up to the nearest megabyte.<br/>
	// If this property is not specified in a POST that begins a LUN movement, throttling is not applied to the data transfer.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.<br/>
	// This property is valid only in a POST that begins a LUN movement or a PATCH when a LUN movement is already in process.
	//
	MaxThroughput int64 `json:"max_throughput,omitempty"`

	// paths
	Paths *LunMovementPaths `json:"paths,omitempty"`

	// progress
	Progress *LunMovementProgress `json:"progress,omitempty"`
}

// Validate validates this lun movement
func (m *LunMovement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePaths(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMovement) validatePaths(formats strfmt.Registry) error {
	if swag.IsZero(m.Paths) { // not required
		return nil
	}

	if m.Paths != nil {
		if err := m.Paths.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "paths")
			}
			return err
		}
	}

	return nil
}

func (m *LunMovement) validateProgress(formats strfmt.Registry) error {
	if swag.IsZero(m.Progress) { // not required
		return nil
	}

	if m.Progress != nil {
		if err := m.Progress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun movement based on the context it is used
func (m *LunMovement) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePaths(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProgress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMovement) contextValidatePaths(ctx context.Context, formats strfmt.Registry) error {

	if m.Paths != nil {
		if err := m.Paths.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "paths")
			}
			return err
		}
	}

	return nil
}

func (m *LunMovement) contextValidateProgress(ctx context.Context, formats strfmt.Registry) error {

	if m.Progress != nil {
		if err := m.Progress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunMovement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMovement) UnmarshalBinary(b []byte) error {
	var res LunMovement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMovementPaths The fully qualified LUN path names involved in the LUN movement.
//
//
// swagger:model LunMovementPaths
type LunMovementPaths struct {

	// The fully qualified path of the LUN movement destination composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.
	//
	// Example: /vol/vol1/lun1
	// Read Only: true
	Destination string `json:"destination,omitempty"`

	// The fully qualified path of the LUN movement source composed of a "/vol" prefix, the volume name, the (optional) qtree name, and base name of the LUN.
	//
	// Example: /vol/vol2/lun2
	// Read Only: true
	Source string `json:"source,omitempty"`
}

// Validate validates this lun movement paths
func (m *LunMovementPaths) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun movement paths based on the context it is used
func (m *LunMovementPaths) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMovementPaths) contextValidateDestination(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"paths"+"."+"destination", "body", string(m.Destination)); err != nil {
		return err
	}

	return nil
}

func (m *LunMovementPaths) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"paths"+"."+"source", "body", string(m.Source)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunMovementPaths) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMovementPaths) UnmarshalBinary(b []byte) error {
	var res LunMovementPaths
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunMovementProgress Properties related to the progress of an active or recently completed LUN movement.
//
//
// swagger:model LunMovementProgress
type LunMovementProgress struct {

	// The amount of time that has elapsed since the start of the LUN movement, in seconds.
	//
	// Read Only: true
	Elapsed int64 `json:"elapsed,omitempty"`

	// Error information provided if the asynchronous LUN movement operation fails.
	//
	// Read Only: true
	Failure *Error `json:"failure,omitempty"`

	// The percentage completed of the LUN movement.
	//
	// Read Only: true
	// Maximum: 100
	// Minimum: 0
	PercentComplete int64 `json:"percent_complete,omitempty"`

	// The state of the LUN movement.<br/>
	// Valid in PATCH when an LUN movement is active. Set to _paused_ to pause a LUN movement. Set to _replicating_ to resume a paused LUN movement.
	//
	// Enum: [preparing replicating paused paused_error complete reverting failed]
	State string `json:"state,omitempty"`

	// This property reports if volume Snapshot copies are blocked by the LUN movement. This property can be polled to identify when volume Snapshot copies can be resumed after beginning a LUN movement.
	//
	// Read Only: true
	VolumeSnapshotBlocked *bool `json:"volume_snapshot_blocked,omitempty"`
}

// Validate validates this lun movement progress
func (m *LunMovementProgress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailure(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePercentComplete(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMovementProgress) validateFailure(formats strfmt.Registry) error {
	if swag.IsZero(m.Failure) { // not required
		return nil
	}

	if m.Failure != nil {
		if err := m.Failure.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunMovementProgress) validatePercentComplete(formats strfmt.Registry) error {
	if swag.IsZero(m.PercentComplete) { // not required
		return nil
	}

	if err := validate.MinimumInt("movement"+"."+"progress"+"."+"percent_complete", "body", m.PercentComplete, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("movement"+"."+"progress"+"."+"percent_complete", "body", m.PercentComplete, 100, false); err != nil {
		return err
	}

	return nil
}

var lunMovementProgressTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["preparing","replicating","paused","paused_error","complete","reverting","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunMovementProgressTypeStatePropEnum = append(lunMovementProgressTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunMovementProgress
	// LunMovementProgress
	// state
	// State
	// preparing
	// END DEBUGGING
	// LunMovementProgressStatePreparing captures enum value "preparing"
	LunMovementProgressStatePreparing string = "preparing"

	// BEGIN DEBUGGING
	// LunMovementProgress
	// LunMovementProgress
	// state
	// State
	// replicating
	// END DEBUGGING
	// LunMovementProgressStateReplicating captures enum value "replicating"
	LunMovementProgressStateReplicating string = "replicating"

	// BEGIN DEBUGGING
	// LunMovementProgress
	// LunMovementProgress
	// state
	// State
	// paused
	// END DEBUGGING
	// LunMovementProgressStatePaused captures enum value "paused"
	LunMovementProgressStatePaused string = "paused"

	// BEGIN DEBUGGING
	// LunMovementProgress
	// LunMovementProgress
	// state
	// State
	// paused_error
	// END DEBUGGING
	// LunMovementProgressStatePausedError captures enum value "paused_error"
	LunMovementProgressStatePausedError string = "paused_error"

	// BEGIN DEBUGGING
	// LunMovementProgress
	// LunMovementProgress
	// state
	// State
	// complete
	// END DEBUGGING
	// LunMovementProgressStateComplete captures enum value "complete"
	LunMovementProgressStateComplete string = "complete"

	// BEGIN DEBUGGING
	// LunMovementProgress
	// LunMovementProgress
	// state
	// State
	// reverting
	// END DEBUGGING
	// LunMovementProgressStateReverting captures enum value "reverting"
	LunMovementProgressStateReverting string = "reverting"

	// BEGIN DEBUGGING
	// LunMovementProgress
	// LunMovementProgress
	// state
	// State
	// failed
	// END DEBUGGING
	// LunMovementProgressStateFailed captures enum value "failed"
	LunMovementProgressStateFailed string = "failed"
)

// prop value enum
func (m *LunMovementProgress) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunMovementProgressTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunMovementProgress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("movement"+"."+"progress"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun movement progress based on the context it is used
func (m *LunMovementProgress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateElapsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailure(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePercentComplete(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeSnapshotBlocked(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunMovementProgress) contextValidateElapsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"progress"+"."+"elapsed", "body", int64(m.Elapsed)); err != nil {
		return err
	}

	return nil
}

func (m *LunMovementProgress) contextValidateFailure(ctx context.Context, formats strfmt.Registry) error {

	if m.Failure != nil {
		if err := m.Failure.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("movement" + "." + "progress" + "." + "failure")
			}
			return err
		}
	}

	return nil
}

func (m *LunMovementProgress) contextValidatePercentComplete(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"progress"+"."+"percent_complete", "body", int64(m.PercentComplete)); err != nil {
		return err
	}

	return nil
}

func (m *LunMovementProgress) contextValidateVolumeSnapshotBlocked(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "movement"+"."+"progress"+"."+"volume_snapshot_blocked", "body", m.VolumeSnapshotBlocked); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunMovementProgress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunMovementProgress) UnmarshalBinary(b []byte) error {
	var res LunMovementProgress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunQosPolicy The QoS policy for the LUN. Both traditional and adaptive QoS policies are supported. If both property `qos_policy.uuid` and `qos_policy.name` are specified in the same request, they must refer to the same QoS policy. To remove the QoS policy from a LUN, leaving it with no QoS policy, set property `qos_policy.name` to an empty string ("") in a PATCH request. Valid in POST and PATCH.<br/>
// Note that a QoS policy can be set on a LUN, or a LUN's volume, but not both.
//
//
// swagger:model LunQosPolicy
type LunQosPolicy struct {

	// links
	Links *LunQosPolicyLinks `json:"_links,omitempty"`

	// The name of the QoS policy. To remove the QoS policy from a LUN, leaving it with no QoS policy, set this property to an empty string ("") in a PATCH request. Valid in POST and PATCH.
	//
	// Example: qos1
	Name string `json:"name,omitempty"`

	// The unique identifier of the QoS policy. Valid in POST and PATCH.
	//
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun qos policy
func (m *LunQosPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunQosPolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun qos policy based on the context it is used
func (m *LunQosPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunQosPolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunQosPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunQosPolicy) UnmarshalBinary(b []byte) error {
	var res LunQosPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunQosPolicyLinks lun qos policy links
//
// swagger:model LunQosPolicyLinks
type LunQosPolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun qos policy links
func (m *LunQosPolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunQosPolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun qos policy links based on the context it is used
func (m *LunQosPolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunQosPolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunQosPolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunQosPolicyLinks) UnmarshalBinary(b []byte) error {
	var res LunQosPolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunSpace The storage space related properties of the LUN.
//
//
// swagger:model LunSpace
type LunSpace struct {

	// guarantee
	Guarantee *LunSpaceGuarantee `json:"guarantee,omitempty"`

	// To leverage the benefits of SCSI thin provisioning, it must be supported by your host. SCSI thin provisioning uses the Logical Block Provisioning feature as defined in the SCSI SBC-3 standard. Only hosts that support this standard can use SCSI thin provisioning in ONTAP.<br/>
	// When you enable SCSI thin provisioning support in ONTAP, you turn on the following SCSI thin provisioning features:
	// - Unmapping and reporting space usage for space reclamation
	// - Reporting resource exhaustion errors
	// <p/>
	// The value of this property is not propagated to the destination when a LUN is cloned as a new LUN or copied; it is reset to false. The value of this property is maintained from the destination LUN when a LUN is overwritten as a clone.<br/>
	// Valid in POST and PATCH.
	//
	ScsiThinProvisioningSupportEnabled *bool `json:"scsi_thin_provisioning_support_enabled,omitempty"`

	// The total provisioned size of the LUN. The LUN size can be increased but not be made smaller using the REST interface.<br/>
	// The maximum and minimum sizes listed here are the absolute maximum and absolute minimum sizes in bytes. The actual minimum and maxiumum sizes vary depending on the ONTAP version, ONTAP platform and the available space in the containing volume and aggregate.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	// Example: 1073741824
	// Maximum: 1.40737488355328e+14
	// Minimum: 4096
	Size int64 `json:"size,omitempty"`

	// The amount of space consumed by the main data stream of the LUN.<br/>
	// This value is the total space consumed in the volume by the LUN, including filesystem overhead, but excluding prefix and suffix streams. Due to internal filesystem overhead and the many ways SAN filesystems and applications utilize blocks within a LUN, this value does not necessarily reflect actual consumption/availability from the perspective of the filesystem or application. Without specific knowledge of how the LUN blocks are utilized outside of ONTAP, this property should not be used as an indicator for an out-of-space condition.<br/>
	// For more information, see _Size properties_ in the _docs_ section of the ONTAP REST API documentation.
	//
	// Read Only: true
	Used int64 `json:"used,omitempty"`
}

// Validate validates this lun space
func (m *LunSpace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGuarantee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunSpace) validateGuarantee(formats strfmt.Registry) error {
	if swag.IsZero(m.Guarantee) { // not required
		return nil
	}

	if m.Guarantee != nil {
		if err := m.Guarantee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *LunSpace) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := validate.MinimumInt("space"+"."+"size", "body", m.Size, 4096, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("space"+"."+"size", "body", m.Size, 1.40737488355328e+14, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun space based on the context it is used
func (m *LunSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGuarantee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunSpace) contextValidateGuarantee(ctx context.Context, formats strfmt.Registry) error {

	if m.Guarantee != nil {
		if err := m.Guarantee.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "guarantee")
			}
			return err
		}
	}

	return nil
}

func (m *LunSpace) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunSpace) UnmarshalBinary(b []byte) error {
	var res LunSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunSpaceGuarantee Properties that request and report the space guarantee for the LUN.
//
//
// swagger:model LunSpaceGuarantee
type LunSpaceGuarantee struct {

	// The requested space reservation policy for the LUN. If _true_, a space reservation is requested for the LUN; if _false_, the LUN is thin provisioned. Guaranteeing a space reservation request for a LUN requires that the volume in which the LUN resides is also space reserved and that the fractional reserve for the volume is 100%. Valid in POST and PATCH.
	//
	Requested *bool `json:"requested,omitempty"`

	// Reports if the LUN is space guaranteed.<br/>
	// If _true_, a space guarantee is requested and the containing volume and aggregate support the request. If _false_, a space guarantee is not requested or a space guarantee is requested and either the containing volume or aggregate do not support the request.
	//
	// Read Only: true
	Reserved *bool `json:"reserved,omitempty"`
}

// Validate validates this lun space guarantee
func (m *LunSpaceGuarantee) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun space guarantee based on the context it is used
func (m *LunSpaceGuarantee) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReserved(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunSpaceGuarantee) contextValidateReserved(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"guarantee"+"."+"reserved", "body", m.Reserved); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunSpaceGuarantee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunSpaceGuarantee) UnmarshalBinary(b []byte) error {
	var res LunSpaceGuarantee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunStatistics These are raw performance numbers, such as IOPS latency and throughput. These numbers are aggregated across all nodes in the cluster and increase with the uptime of the cluster.
//
// swagger:model LunStatistics
type LunStatistics struct {

	// iops raw
	IopsRaw *LunStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *LunStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *LunStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this lun statistics
func (m *LunStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var lunStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunStatisticsTypeStatusPropEnum = append(lunStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// LunStatisticsStatusOk captures enum value "ok"
	LunStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// LunStatisticsStatusError captures enum value "error"
	LunStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// LunStatisticsStatusPartialNoData captures enum value "partial_no_data"
	LunStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// LunStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	LunStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// LunStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	LunStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// LunStatisticsStatusNegativeDelta captures enum value "negative_delta"
	LunStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// not_found
	// END DEBUGGING
	// LunStatisticsStatusNotFound captures enum value "not_found"
	LunStatisticsStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// LunStatisticsStatusBackfilledData captures enum value "backfilled_data"
	LunStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// LunStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	LunStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// LunStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	LunStatisticsStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// LunStatistics
	// LunStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// LunStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	LunStatisticsStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *LunStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *LunStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun statistics based on the context it is used
func (m *LunStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *LunStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *LunStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunStatistics) UnmarshalBinary(b []byte) error {
	var res LunStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunStatisticsIopsRaw The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model LunStatisticsIopsRaw
type LunStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this lun statistics iops raw
func (m *LunStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun statistics iops raw based on the context it is used
func (m *LunStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res LunStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model LunStatisticsLatencyRaw
type LunStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this lun statistics latency raw
func (m *LunStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun statistics latency raw based on the context it is used
func (m *LunStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res LunStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunStatisticsThroughputRaw Throughput bytes observed at the storage object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model LunStatisticsThroughputRaw
type LunStatisticsThroughputRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this lun statistics throughput raw
func (m *LunStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lun statistics throughput raw based on the context it is used
func (m *LunStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *LunStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res LunStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunStatus Status information about the LUN.
//
//
// swagger:model LunStatus
type LunStatus struct {

	// The state of the volume and aggregate that contain the LUN. LUNs are only available when their containers are available.
	//
	// Read Only: true
	// Enum: [online aggregate_offline volume_offline]
	ContainerState string `json:"container_state,omitempty"`

	// Reports if the LUN is mapped to one or more initiator groups.<br/>
	// There is an added cost to retrieving this property's value. It is not populated for either a collection GET or an instance GET unless it is explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	// Read Only: true
	Mapped *bool `json:"mapped,omitempty"`

	// Reports if the LUN allows only read access.
	//
	// Read Only: true
	ReadOnly *bool `json:"read_only,omitempty"`

	// The state of the LUN. Normal states for a LUN are _online_ and _offline_. Other states indicate errors.
	//
	// Example: online
	// Read Only: true
	// Enum: [foreign_lun_error nvfail offline online space_error]
	State string `json:"state,omitempty"`
}

// Validate validates this lun status
func (m *LunStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContainerState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var lunStatusTypeContainerStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","aggregate_offline","volume_offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunStatusTypeContainerStatePropEnum = append(lunStatusTypeContainerStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// container_state
	// ContainerState
	// online
	// END DEBUGGING
	// LunStatusContainerStateOnline captures enum value "online"
	LunStatusContainerStateOnline string = "online"

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// container_state
	// ContainerState
	// aggregate_offline
	// END DEBUGGING
	// LunStatusContainerStateAggregateOffline captures enum value "aggregate_offline"
	LunStatusContainerStateAggregateOffline string = "aggregate_offline"

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// container_state
	// ContainerState
	// volume_offline
	// END DEBUGGING
	// LunStatusContainerStateVolumeOffline captures enum value "volume_offline"
	LunStatusContainerStateVolumeOffline string = "volume_offline"
)

// prop value enum
func (m *LunStatus) validateContainerStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunStatusTypeContainerStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunStatus) validateContainerState(formats strfmt.Registry) error {
	if swag.IsZero(m.ContainerState) { // not required
		return nil
	}

	// value enum
	if err := m.validateContainerStateEnum("status"+"."+"container_state", "body", m.ContainerState); err != nil {
		return err
	}

	return nil
}

var lunStatusTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["foreign_lun_error","nvfail","offline","online","space_error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		lunStatusTypeStatePropEnum = append(lunStatusTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// state
	// State
	// foreign_lun_error
	// END DEBUGGING
	// LunStatusStateForeignLunError captures enum value "foreign_lun_error"
	LunStatusStateForeignLunError string = "foreign_lun_error"

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// state
	// State
	// nvfail
	// END DEBUGGING
	// LunStatusStateNvfail captures enum value "nvfail"
	LunStatusStateNvfail string = "nvfail"

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// state
	// State
	// offline
	// END DEBUGGING
	// LunStatusStateOffline captures enum value "offline"
	LunStatusStateOffline string = "offline"

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// state
	// State
	// online
	// END DEBUGGING
	// LunStatusStateOnline captures enum value "online"
	LunStatusStateOnline string = "online"

	// BEGIN DEBUGGING
	// LunStatus
	// LunStatus
	// state
	// State
	// space_error
	// END DEBUGGING
	// LunStatusStateSpaceError captures enum value "space_error"
	LunStatusStateSpaceError string = "space_error"
)

// prop value enum
func (m *LunStatus) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, lunStatusTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LunStatus) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("status"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this lun status based on the context it is used
func (m *LunStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContainerState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMapped(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReadOnly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunStatus) contextValidateContainerState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"container_state", "body", string(m.ContainerState)); err != nil {
		return err
	}

	return nil
}

func (m *LunStatus) contextValidateMapped(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"mapped", "body", m.Mapped); err != nil {
		return err
	}

	return nil
}

func (m *LunStatus) contextValidateReadOnly(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"read_only", "body", m.ReadOnly); err != nil {
		return err
	}

	return nil
}

func (m *LunStatus) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunStatus) UnmarshalBinary(b []byte) error {
	var res LunStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunSvm The SVM in which the LUN is located.
//
//
// swagger:model LunSvm
type LunSvm struct {

	// links
	Links *LunSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun svm
func (m *LunSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun svm based on the context it is used
func (m *LunSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunSvm) UnmarshalBinary(b []byte) error {
	var res LunSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunSvmLinks lun svm links
//
// swagger:model LunSvmLinks
type LunSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun svm links
func (m *LunSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun svm links based on the context it is used
func (m *LunSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunSvmLinks) UnmarshalBinary(b []byte) error {
	var res LunSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvol A VMware virtual volume (vVol) binding is an association between a LUN of class `protocol_endpoint` and a LUN of class `vvol`. Class `protocol_endpoint` LUNs are mapped to igroups and granted access using the same configuration as class `regular` LUNs. When a class `vvol` LUN is bound to a mapped class `protocol_endpoint` LUN, VMware can access the class `vvol` LUN through the class `protocol_endpoint` LUN mapping.</br>
// See [`POST /protocols/san/vvol-bindings`](#/SAN/vvol_binding_create) to learn more about creating vVol bindings and [`DELETE /protocols/san/vvol-bindings`](#/SAN/vvol_binding_delete) to learn more about deleting vVol bindings.</br>
// There is an added cost to retrieving property values for `vvol`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
//
//
// swagger:model LunVvol
type LunVvol struct {

	// Bindings between the LUN, which must be of class `protocol_endpoint` or `vvol`, and LUNs of the opposite class.<br/>
	// A class `vvol` LUN must be bound to a class `protocol_endpoint` LUN in order to be accessed. Class `protocol_endpoint` and `vvol` LUNs allow many-to-many bindings. A LUN of one class is allowed to be bound to zero or more LUNs of the opposite class. The binding between any two specific LUNs is reference counted. When a binding is created that already exists, the binding count is incremented. When a binding is deleted, the binding count is decremented, but the LUNs remain bound if the resultant reference count is greater than zero. When the binding count reaches zero, the binding is destroyed.<br/>
	// The bindings array contains LUNs of the opposite class of the containing LUN object.<br/>
	// There is an added cost to retrieving property values for `vvol.bindings`. They are not populated for either a collection GET or an instance GET unless explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.
	//
	// Read Only: true
	Bindings []*LunVvolBindingsItems0 `json:"bindings,omitempty"`

	// Reports if the LUN is part of a VMware virtual volume (vVol) bind relationship. This is `true` if the LUN is of class `protocol_endpoint` or `vvol` and has one or more bindings to a LUN of the opposite class. This is false if the LUN is of class `regular` or unbound.
	//
	// Read Only: true
	IsBound *bool `json:"is_bound,omitempty"`
}

// Validate validates this lun vvol
func (m *LunVvol) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBindings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvol) validateBindings(formats strfmt.Registry) error {
	if swag.IsZero(m.Bindings) { // not required
		return nil
	}

	for i := 0; i < len(m.Bindings); i++ {
		if swag.IsZero(m.Bindings[i]) { // not required
			continue
		}

		if m.Bindings[i] != nil {
			if err := m.Bindings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vvol" + "." + "bindings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this lun vvol based on the context it is used
func (m *LunVvol) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBindings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsBound(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvol) contextValidateBindings(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vvol"+"."+"bindings", "body", []*LunVvolBindingsItems0(m.Bindings)); err != nil {
		return err
	}

	for i := 0; i < len(m.Bindings); i++ {

		if m.Bindings[i] != nil {
			if err := m.Bindings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vvol" + "." + "bindings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LunVvol) contextValidateIsBound(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "vvol"+"."+"is_bound", "body", m.IsBound); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvol) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvol) UnmarshalBinary(b []byte) error {
	var res LunVvol
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0 A vVol binding with which the LUN is associated.
//
//
// swagger:model LunVvolBindingsItems0
type LunVvolBindingsItems0 struct {

	// links
	Links *LunVvolBindingsItems0Links `json:"_links,omitempty"`

	// The identifier assigned to the binding. The bind identifier is unique amongst all class `vvol` LUNs bound to the same class `protocol_endpoint` LUN.
	//
	// Example: 1
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// partner
	Partner *LunVvolBindingsItems0Partner `json:"partner,omitempty"`
}

// Validate validates this lun vvol bindings items0
func (m *LunVvolBindingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunVvolBindingsItems0) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(m.Partner) { // not required
		return nil
	}

	if m.Partner != nil {
		if err := m.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 based on the context it is used
func (m *LunVvolBindingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunVvolBindingsItems0) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *LunVvolBindingsItems0) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if m.Partner != nil {
		if err := m.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0Links lun vvol bindings items0 links
//
// swagger:model LunVvolBindingsItems0Links
type LunVvolBindingsItems0Links struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun vvol bindings items0 links
func (m *LunVvolBindingsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 links based on the context it is used
func (m *LunVvolBindingsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0Links) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0Partner The LUN partner that this LUN is bound to. If this LUN is a `vvol` class LUN, the partner is a `protocol_endpoint` class LUN.
//
//
// swagger:model LunVvolBindingsItems0Partner
type LunVvolBindingsItems0Partner struct {

	// links
	Links *LunVvolBindingsItems0PartnerLinks `json:"_links,omitempty"`

	// The name of the partner LUN.
	//
	// Example: /vol/vol1/lun1
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The unique identifier of the partner LUN.
	//
	// Example: 4ea7a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this lun vvol bindings items0 partner
func (m *LunVvolBindingsItems0Partner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Partner) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 partner based on the context it is used
func (m *LunVvolBindingsItems0Partner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0Partner) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *LunVvolBindingsItems0Partner) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "partner"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *LunVvolBindingsItems0Partner) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "partner"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0Partner) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0Partner) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0Partner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LunVvolBindingsItems0PartnerLinks lun vvol bindings items0 partner links
//
// swagger:model LunVvolBindingsItems0PartnerLinks
type LunVvolBindingsItems0PartnerLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this lun vvol bindings items0 partner links
func (m *LunVvolBindingsItems0PartnerLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0PartnerLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this lun vvol bindings items0 partner links based on the context it is used
func (m *LunVvolBindingsItems0PartnerLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LunVvolBindingsItems0PartnerLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LunVvolBindingsItems0PartnerLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LunVvolBindingsItems0PartnerLinks) UnmarshalBinary(b []byte) error {
	var res LunVvolBindingsItems0PartnerLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

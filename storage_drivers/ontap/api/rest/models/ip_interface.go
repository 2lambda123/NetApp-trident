// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IPInterface ip interface
//
// swagger:model ip_interface
type IPInterface struct {

	// links
	Links *IPInterfaceLinks `json:"_links,omitempty"`

	// Indicates whether or not dynamic DNS updates are enabled. Defaults to true if the interface supports "data_nfs" or "data_cifs" services, otherwise false.
	DdnsEnabled bool `json:"ddns_enabled,omitempty"`

	// Fully qualified DNS zone name
	// Example: storage.company.com
	DNSZone string `json:"dns_zone,omitempty"`

	// The administrative state of the interface.
	Enabled *bool `json:"enabled,omitempty"`

	// ip
	IP *IPInfo `json:"ip,omitempty"`

	// ipspace
	Ipspace *IPInterfaceIpspace `json:"ipspace,omitempty"`

	// location
	Location *IPInterfaceLocation `json:"location,omitempty"`

	// metric
	Metric *IPInterfaceMetric `json:"metric,omitempty"`

	// Interface name
	// Example: dataLif1
	Name string `json:"name,omitempty"`

	// Set to "svm" for interfaces owned by an SVM. Otherwise, set to "cluster".
	// Enum: [svm cluster]
	Scope string `json:"scope,omitempty"`

	// service policy
	ServicePolicy *IPInterfaceServicePolicy `json:"service_policy,omitempty"`

	// The services associated with the interface.
	// Read Only: true
	Services []IPService `json:"services,omitempty"`

	// The operational state of the interface.
	// Read Only: true
	// Enum: [up down]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *IPInterfaceStatistics `json:"statistics,omitempty"`

	// svm
	Svm *IPInterfaceSvmType `json:"svm,omitempty"`

	// The UUID that uniquely identifies the interface.
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Read Only: true
	UUID string `json:"uuid,omitempty"`

	// True for a VIP interface, whose location is announced via BGP.
	Vip *bool `json:"vip,omitempty"`
}

// Validate validates this ip interface
func (m *IPInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpspace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServicePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServices(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterface) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if m.IP != nil {
		if err := m.IP.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) validateIpspace(formats strfmt.Registry) error {
	if swag.IsZero(m.Ipspace) { // not required
		return nil
	}

	if m.Ipspace != nil {
		if err := m.Ipspace.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.Location) { // not required
		return nil
	}

	if m.Location != nil {
		if err := m.Location.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

var ipInterfaceTypeScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["svm","cluster"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ipInterfaceTypeScopePropEnum = append(ipInterfaceTypeScopePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ip_interface
	// IPInterface
	// scope
	// Scope
	// svm
	// END DEBUGGING
	// IPInterfaceScopeSvm captures enum value "svm"
	IPInterfaceScopeSvm string = "svm"

	// BEGIN DEBUGGING
	// ip_interface
	// IPInterface
	// scope
	// Scope
	// cluster
	// END DEBUGGING
	// IPInterfaceScopeCluster captures enum value "cluster"
	IPInterfaceScopeCluster string = "cluster"
)

// prop value enum
func (m *IPInterface) validateScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ipInterfaceTypeScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IPInterface) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	// value enum
	if err := m.validateScopeEnum("scope", "body", m.Scope); err != nil {
		return err
	}

	return nil
}

func (m *IPInterface) validateServicePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ServicePolicy) { // not required
		return nil
	}

	if m.ServicePolicy != nil {
		if err := m.ServicePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_policy")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) validateServices(formats strfmt.Registry) error {
	if swag.IsZero(m.Services) { // not required
		return nil
	}

	for i := 0; i < len(m.Services); i++ {

		if err := m.Services[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("services" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

var ipInterfaceTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["up","down"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ipInterfaceTypeStatePropEnum = append(ipInterfaceTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// ip_interface
	// IPInterface
	// state
	// State
	// up
	// END DEBUGGING
	// IPInterfaceStateUp captures enum value "up"
	IPInterfaceStateUp string = "up"

	// BEGIN DEBUGGING
	// ip_interface
	// IPInterface
	// state
	// State
	// down
	// END DEBUGGING
	// IPInterfaceStateDown captures enum value "down"
	IPInterfaceStateDown string = "down"
)

// prop value enum
func (m *IPInterface) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ipInterfaceTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IPInterface) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *IPInterface) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ip interface based on the context it is used
func (m *IPInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIpspace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServicePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServices(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterface) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateIP(ctx context.Context, formats strfmt.Registry) error {

	if m.IP != nil {
		if err := m.IP.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ip")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateIpspace(ctx context.Context, formats strfmt.Registry) error {

	if m.Ipspace != nil {
		if err := m.Ipspace.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.Location != nil {
		if err := m.Location.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateServicePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.ServicePolicy != nil {
		if err := m.ServicePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_policy")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateServices(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "services", "body", []IPService(m.Services)); err != nil {
		return err
	}

	for i := 0; i < len(m.Services); i++ {

		if err := m.Services[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("services" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *IPInterface) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *IPInterface) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterface) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterface) UnmarshalBinary(b []byte) error {
	var res IPInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceIpspace Either the UUID or name must be supplied on POST for cluster-scoped objects.
//
// swagger:model IPInterfaceIpspace
type IPInterfaceIpspace struct {

	// links
	Links *IPInterfaceIpspaceLinks `json:"_links,omitempty"`

	// IPspace name
	// Example: exchange
	Name string `json:"name,omitempty"`

	// IPspace UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface ipspace
func (m *IPInterfaceIpspace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceIpspace) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface ipspace based on the context it is used
func (m *IPInterfaceIpspace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceIpspace) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceIpspace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceIpspace) UnmarshalBinary(b []byte) error {
	var res IPInterfaceIpspace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceIpspaceLinks IP interface ipspace links
//
// swagger:model IPInterfaceIpspaceLinks
type IPInterfaceIpspaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface ipspace links
func (m *IPInterfaceIpspaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceIpspaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface ipspace links based on the context it is used
func (m *IPInterfaceIpspaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceIpspaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipspace" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceIpspaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceIpspaceLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceIpspaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLinks IP interface links
//
// swagger:model IPInterfaceLinks
type IPInterfaceLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface links
func (m *IPInterfaceLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface links based on the context it is used
func (m *IPInterfaceLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocation Current or home location can be modified. Specifying a port implies a node. Specifying a node allows an appropriate port to be automatically selected. Ports are not valid and not shown for VIP interfaces. For POST, broadcast_domain can be specified alone or with home_node.  For PATCH, set is_home to true to revert a LIF back to its home port.
//
// swagger:model IPInterfaceLocation
type IPInterfaceLocation struct {

	// auto revert
	AutoRevert bool `json:"auto_revert,omitempty"`

	// broadcast domain
	BroadcastDomain *IPInterfaceLocationBroadcastDomain `json:"broadcast_domain,omitempty"`

	// failover
	Failover FailoverScope `json:"failover,omitempty"`

	// home node
	HomeNode *IPInterfaceLocationHomeNode `json:"home_node,omitempty"`

	// home port
	HomePort *IPInterfaceLocationHomePort `json:"home_port,omitempty"`

	// is home
	IsHome bool `json:"is_home,omitempty"`

	// node
	Node *IPInterfaceLocationNode `json:"node,omitempty"`

	// port
	Port *IPInterfaceLocationPort `json:"port,omitempty"`
}

// Validate validates this IP interface location
func (m *IPInterfaceLocation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBroadcastDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailover(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomePort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocation) validateBroadcastDomain(formats strfmt.Registry) error {
	if swag.IsZero(m.BroadcastDomain) { // not required
		return nil
	}

	if m.BroadcastDomain != nil {
		if err := m.BroadcastDomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "broadcast_domain")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) validateFailover(formats strfmt.Registry) error {
	if swag.IsZero(m.Failover) { // not required
		return nil
	}

	if err := m.Failover.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("location" + "." + "failover")
		}
		return err
	}

	return nil
}

func (m *IPInterfaceLocation) validateHomeNode(formats strfmt.Registry) error {
	if swag.IsZero(m.HomeNode) { // not required
		return nil
	}

	if m.HomeNode != nil {
		if err := m.HomeNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) validateHomePort(formats strfmt.Registry) error {
	if swag.IsZero(m.HomePort) { // not required
		return nil
	}

	if m.HomePort != nil {
		if err := m.HomePort.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) validatePort(formats strfmt.Registry) error {
	if swag.IsZero(m.Port) { // not required
		return nil
	}

	if m.Port != nil {
		if err := m.Port.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location based on the context it is used
func (m *IPInterfaceLocation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBroadcastDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailover(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHomeNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHomePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocation) contextValidateBroadcastDomain(ctx context.Context, formats strfmt.Registry) error {

	if m.BroadcastDomain != nil {
		if err := m.BroadcastDomain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "broadcast_domain")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) contextValidateFailover(ctx context.Context, formats strfmt.Registry) error {

	if err := m.Failover.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("location" + "." + "failover")
		}
		return err
	}

	return nil
}

func (m *IPInterfaceLocation) contextValidateHomeNode(ctx context.Context, formats strfmt.Registry) error {

	if m.HomeNode != nil {
		if err := m.HomeNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) contextValidateHomePort(ctx context.Context, formats strfmt.Registry) error {

	if m.HomePort != nil {
		if err := m.HomePort.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocation) contextValidatePort(ctx context.Context, formats strfmt.Registry) error {

	if m.Port != nil {
		if err := m.Port.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocation) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationBroadcastDomain Broadcast domain UUID along with a readable name.
//
// swagger:model IPInterfaceLocationBroadcastDomain
type IPInterfaceLocationBroadcastDomain struct {

	// links
	Links *IPInterfaceLocationBroadcastDomainLinks `json:"_links,omitempty"`

	// Name of the broadcast domain, scoped to its IPspace
	// Example: bd1
	Name string `json:"name,omitempty"`

	// Broadcast domain UUID
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface location broadcast domain
func (m *IPInterfaceLocationBroadcastDomain) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationBroadcastDomain) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "broadcast_domain" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location broadcast domain based on the context it is used
func (m *IPInterfaceLocationBroadcastDomain) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationBroadcastDomain) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "broadcast_domain" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationBroadcastDomain) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationBroadcastDomain) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationBroadcastDomain
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationBroadcastDomainLinks IP interface location broadcast domain links
//
// swagger:model IPInterfaceLocationBroadcastDomainLinks
type IPInterfaceLocationBroadcastDomainLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface location broadcast domain links
func (m *IPInterfaceLocationBroadcastDomainLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationBroadcastDomainLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "broadcast_domain" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location broadcast domain links based on the context it is used
func (m *IPInterfaceLocationBroadcastDomainLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationBroadcastDomainLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "broadcast_domain" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationBroadcastDomainLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationBroadcastDomainLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationBroadcastDomainLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationHomeNode IP interface location home node
//
// swagger:model IPInterfaceLocationHomeNode
type IPInterfaceLocationHomeNode struct {

	// links
	Links *IPInterfaceLocationHomeNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface location home node
func (m *IPInterfaceLocationHomeNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomeNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location home node based on the context it is used
func (m *IPInterfaceLocationHomeNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomeNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationHomeNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationHomeNode) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationHomeNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationHomeNodeLinks IP interface location home node links
//
// swagger:model IPInterfaceLocationHomeNodeLinks
type IPInterfaceLocationHomeNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface location home node links
func (m *IPInterfaceLocationHomeNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomeNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location home node links based on the context it is used
func (m *IPInterfaceLocationHomeNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomeNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationHomeNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationHomeNodeLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationHomeNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationHomePort Port UUID along with readable names. Either the UUID or both names may be supplied on input.
//
// swagger:model IPInterfaceLocationHomePort
type IPInterfaceLocationHomePort struct {

	// links
	Links *IPInterfaceLocationHomePortLinks `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *IPInterfaceLocationHomePortNode `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface location home port
func (m *IPInterfaceLocationHomePort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomePort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocationHomePort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location home port based on the context it is used
func (m *IPInterfaceLocationHomePort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomePort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocationHomePort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationHomePort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationHomePort) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationHomePort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationHomePortLinks IP interface location home port links
//
// swagger:model IPInterfaceLocationHomePortLinks
type IPInterfaceLocationHomePortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface location home port links
func (m *IPInterfaceLocationHomePortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomePortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location home port links based on the context it is used
func (m *IPInterfaceLocationHomePortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationHomePortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "home_port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationHomePortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationHomePortLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationHomePortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationHomePortNode IP interface location home port node
//
// swagger:model IPInterfaceLocationHomePortNode
type IPInterfaceLocationHomePortNode struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this IP interface location home port node
func (m *IPInterfaceLocationHomePortNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this IP interface location home port node based on context it is used
func (m *IPInterfaceLocationHomePortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationHomePortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationHomePortNode) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationHomePortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationNode IP interface location node
//
// swagger:model IPInterfaceLocationNode
type IPInterfaceLocationNode struct {

	// links
	Links *IPInterfaceLocationNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface location node
func (m *IPInterfaceLocationNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location node based on the context it is used
func (m *IPInterfaceLocationNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationNode) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationNodeLinks IP interface location node links
//
// swagger:model IPInterfaceLocationNodeLinks
type IPInterfaceLocationNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface location node links
func (m *IPInterfaceLocationNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location node links based on the context it is used
func (m *IPInterfaceLocationNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationNodeLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationPort Port UUID along with readable names. Either the UUID or both names may be supplied on input.
//
// swagger:model IPInterfaceLocationPort
type IPInterfaceLocationPort struct {

	// links
	Links *IPInterfaceLocationPortLinks `json:"_links,omitempty"`

	// name
	// Example: e1b
	Name string `json:"name,omitempty"`

	// node
	Node *IPInterfaceLocationPortNode `json:"node,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface location port
func (m *IPInterfaceLocationPort) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationPort) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocationPort) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location port based on the context it is used
func (m *IPInterfaceLocationPort) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationPort) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceLocationPort) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationPort) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationPort) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationPort
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationPortLinks IP interface location port links
//
// swagger:model IPInterfaceLocationPortLinks
type IPInterfaceLocationPortLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface location port links
func (m *IPInterfaceLocationPortLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationPortLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface location port links based on the context it is used
func (m *IPInterfaceLocationPortLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceLocationPortLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location" + "." + "port" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationPortLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationPortLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationPortLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceLocationPortNode IP interface location port node
//
// swagger:model IPInterfaceLocationPortNode
type IPInterfaceLocationPortNode struct {

	// Name of node on which the port is located.
	// Example: node1
	Name string `json:"name,omitempty"`
}

// Validate validates this IP interface location port node
func (m *IPInterfaceLocationPortNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this IP interface location port node based on context it is used
func (m *IPInterfaceLocationPortNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceLocationPortNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceLocationPortNode) UnmarshalBinary(b []byte) error {
	var res IPInterfaceLocationPortNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceMetric The most recent sample of I/O metrics for the interface.
//
// swagger:model IPInterfaceMetric
type IPInterfaceMetric struct {

	// links
	Links *IPInterfaceMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *IPInterfaceMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this IP interface metric
func (m *IPInterfaceMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var ipInterfaceMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ipInterfaceMetricTypeDurationPropEnum = append(ipInterfaceMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// IPInterfaceMetricDurationPT15S captures enum value "PT15S"
	IPInterfaceMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// IPInterfaceMetricDurationPT4M captures enum value "PT4M"
	IPInterfaceMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// IPInterfaceMetricDurationPT30M captures enum value "PT30M"
	IPInterfaceMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// IPInterfaceMetricDurationPT2H captures enum value "PT2H"
	IPInterfaceMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// IPInterfaceMetricDurationP1D captures enum value "P1D"
	IPInterfaceMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// IPInterfaceMetricDurationPT5M captures enum value "PT5M"
	IPInterfaceMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *IPInterfaceMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ipInterfaceMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IPInterfaceMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

var ipInterfaceMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ipInterfaceMetricTypeStatusPropEnum = append(ipInterfaceMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// IPInterfaceMetricStatusOk captures enum value "ok"
	IPInterfaceMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// IPInterfaceMetricStatusError captures enum value "error"
	IPInterfaceMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// IPInterfaceMetricStatusPartialNoData captures enum value "partial_no_data"
	IPInterfaceMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// IPInterfaceMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	IPInterfaceMetricStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// IPInterfaceMetricStatusPartialNoResponse captures enum value "partial_no_response"
	IPInterfaceMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// IPInterfaceMetricStatusPartialOtherError captures enum value "partial_other_error"
	IPInterfaceMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// IPInterfaceMetricStatusNegativeDelta captures enum value "negative_delta"
	IPInterfaceMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// IPInterfaceMetricStatusBackfilledData captures enum value "backfilled_data"
	IPInterfaceMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// IPInterfaceMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	IPInterfaceMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// IPInterfaceMetric
	// IPInterfaceMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// IPInterfaceMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	IPInterfaceMetricStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *IPInterfaceMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ipInterfaceMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IPInterfaceMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *IPInterfaceMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this IP interface metric based on the context it is used
func (m *IPInterfaceMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceMetric) UnmarshalBinary(b []byte) error {
	var res IPInterfaceMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceMetricLinks IP interface metric links
//
// swagger:model IPInterfaceMetricLinks
type IPInterfaceMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface metric links
func (m *IPInterfaceMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface metric links based on the context it is used
func (m *IPInterfaceMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceMetricLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceMetricThroughput The rate of throughput bytes per second observed at the interface.
//
// swagger:model IPInterfaceMetricThroughput
type IPInterfaceMetricThroughput struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this IP interface metric throughput
func (m *IPInterfaceMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this IP interface metric throughput based on context it is used
func (m *IPInterfaceMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceMetricThroughput) UnmarshalBinary(b []byte) error {
	var res IPInterfaceMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceServicePolicy IP interface service policy
//
// swagger:model IPInterfaceServicePolicy
type IPInterfaceServicePolicy struct {

	// links
	Links *IPInterfaceServicePolicyLinks `json:"_links,omitempty"`

	// name
	// Example: default-intercluster
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface service policy
func (m *IPInterfaceServicePolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceServicePolicy) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface service policy based on the context it is used
func (m *IPInterfaceServicePolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceServicePolicy) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_policy" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceServicePolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceServicePolicy) UnmarshalBinary(b []byte) error {
	var res IPInterfaceServicePolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceServicePolicyLinks IP interface service policy links
//
// swagger:model IPInterfaceServicePolicyLinks
type IPInterfaceServicePolicyLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface service policy links
func (m *IPInterfaceServicePolicyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceServicePolicyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface service policy links based on the context it is used
func (m *IPInterfaceServicePolicyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceServicePolicyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("service_policy" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceServicePolicyLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceServicePolicyLinks) UnmarshalBinary(b []byte) error {
	var res IPInterfaceServicePolicyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceStatistics The real time I/O statistics for the interface.
//
// swagger:model IPInterfaceStatistics
type IPInterfaceStatistics struct {

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "inconsistent_delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Enum: [ok error partial_no_data partial_no_uuid partial_no_response partial_other_error negative_delta backfilled_data inconsistent_delta_time inconsistent_old_data]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *IPInterfaceStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this IP interface statistics
func (m *IPInterfaceStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var ipInterfaceStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_uuid","partial_no_response","partial_other_error","negative_delta","backfilled_data","inconsistent_delta_time","inconsistent_old_data"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ipInterfaceStatisticsTypeStatusPropEnum = append(ipInterfaceStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// IPInterfaceStatisticsStatusOk captures enum value "ok"
	IPInterfaceStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// IPInterfaceStatisticsStatusError captures enum value "error"
	IPInterfaceStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// IPInterfaceStatisticsStatusPartialNoData captures enum value "partial_no_data"
	IPInterfaceStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// IPInterfaceStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	IPInterfaceStatisticsStatusPartialNoUUID string = "partial_no_uuid"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// IPInterfaceStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	IPInterfaceStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// IPInterfaceStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	IPInterfaceStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// IPInterfaceStatisticsStatusNegativeDelta captures enum value "negative_delta"
	IPInterfaceStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// IPInterfaceStatisticsStatusBackfilledData captures enum value "backfilled_data"
	IPInterfaceStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// IPInterfaceStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	IPInterfaceStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// IPInterfaceStatistics
	// IPInterfaceStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// IPInterfaceStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	IPInterfaceStatisticsStatusInconsistentOldData string = "inconsistent_old_data"
)

// prop value enum
func (m *IPInterfaceStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ipInterfaceStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IPInterfaceStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *IPInterfaceStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *IPInterfaceStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this IP interface statistics based on the context it is used
func (m *IPInterfaceStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceStatistics) UnmarshalBinary(b []byte) error {
	var res IPInterfaceStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceStatisticsThroughputRaw Throughput bytes observed at the interface. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model IPInterfaceStatisticsThroughputRaw
type IPInterfaceStatisticsThroughputRaw struct {

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this IP interface statistics throughput raw
func (m *IPInterfaceStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this IP interface statistics throughput raw based on context it is used
func (m *IPInterfaceStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res IPInterfaceStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceSvmType Applies only to SVM-scoped objects. Either the UUID or name must be supplied on POST.
//
// swagger:model IPInterfaceSvmType
type IPInterfaceSvmType struct {

	// links
	Links *IPInterfaceSvmLinksType `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this IP interface svm type
func (m *IPInterfaceSvmType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceSvmType) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface svm type based on the context it is used
func (m *IPInterfaceSvmType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceSvmType) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceSvmType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceSvmType) UnmarshalBinary(b []byte) error {
	var res IPInterfaceSvmType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IPInterfaceSvmLinksType IP interface svm links type
//
// swagger:model IPInterfaceSvmLinksType
type IPInterfaceSvmLinksType struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this IP interface svm links type
func (m *IPInterfaceSvmLinksType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceSvmLinksType) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this IP interface svm links type based on the context it is used
func (m *IPInterfaceSvmLinksType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IPInterfaceSvmLinksType) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPInterfaceSvmLinksType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPInterfaceSvmLinksType) UnmarshalBinary(b []byte) error {
	var res IPInterfaceSvmLinksType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

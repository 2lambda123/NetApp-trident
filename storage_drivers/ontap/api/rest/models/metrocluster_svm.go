// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MetroclusterSvm Retrieves configuration information for all pairs of SVMs in MetroCluster. REST /api/cluster/metrocluster/svms/?
//
// swagger:model metrocluster_svm
type MetroclusterSvm struct {

	// links
	Links *SelfLink `json:"_links,omitempty"`

	// cluster
	Cluster *MetroclusterSvmCluster `json:"cluster,omitempty"`

	// Configuration state.
	// Read Only: true
	// Enum: [degraded healthy pending_setup pending_switchback replication_paused syncing unhealthy]
	ConfigurationState string `json:"configuration_state,omitempty"`

	// Reason for SVM object replication failure.
	// Example: Apply failed for Object: volume Method: volume_method. Reason: invalid operation
	// Read Only: true
	FailedReason *Error `json:"failed_reason,omitempty"`

	// partner svm
	PartnerSvm *MetroclusterSvmPartnerSvm `json:"partner_svm,omitempty"`

	// svm
	Svm *MetroclusterSvmSvm `json:"svm,omitempty"`
}

// Validate validates this metrocluster svm
func (m *MetroclusterSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurationState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailedReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartnerSvm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvm) validateCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Cluster) { // not required
		return nil
	}

	if m.Cluster != nil {
		if err := m.Cluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

var metroclusterSvmTypeConfigurationStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["degraded","healthy","pending_setup","pending_switchback","replication_paused","syncing","unhealthy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		metroclusterSvmTypeConfigurationStatePropEnum = append(metroclusterSvmTypeConfigurationStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// metrocluster_svm
	// MetroclusterSvm
	// configuration_state
	// ConfigurationState
	// degraded
	// END DEBUGGING
	// MetroclusterSvmConfigurationStateDegraded captures enum value "degraded"
	MetroclusterSvmConfigurationStateDegraded string = "degraded"

	// BEGIN DEBUGGING
	// metrocluster_svm
	// MetroclusterSvm
	// configuration_state
	// ConfigurationState
	// healthy
	// END DEBUGGING
	// MetroclusterSvmConfigurationStateHealthy captures enum value "healthy"
	MetroclusterSvmConfigurationStateHealthy string = "healthy"

	// BEGIN DEBUGGING
	// metrocluster_svm
	// MetroclusterSvm
	// configuration_state
	// ConfigurationState
	// pending_setup
	// END DEBUGGING
	// MetroclusterSvmConfigurationStatePendingSetup captures enum value "pending_setup"
	MetroclusterSvmConfigurationStatePendingSetup string = "pending_setup"

	// BEGIN DEBUGGING
	// metrocluster_svm
	// MetroclusterSvm
	// configuration_state
	// ConfigurationState
	// pending_switchback
	// END DEBUGGING
	// MetroclusterSvmConfigurationStatePendingSwitchback captures enum value "pending_switchback"
	MetroclusterSvmConfigurationStatePendingSwitchback string = "pending_switchback"

	// BEGIN DEBUGGING
	// metrocluster_svm
	// MetroclusterSvm
	// configuration_state
	// ConfigurationState
	// replication_paused
	// END DEBUGGING
	// MetroclusterSvmConfigurationStateReplicationPaused captures enum value "replication_paused"
	MetroclusterSvmConfigurationStateReplicationPaused string = "replication_paused"

	// BEGIN DEBUGGING
	// metrocluster_svm
	// MetroclusterSvm
	// configuration_state
	// ConfigurationState
	// syncing
	// END DEBUGGING
	// MetroclusterSvmConfigurationStateSyncing captures enum value "syncing"
	MetroclusterSvmConfigurationStateSyncing string = "syncing"

	// BEGIN DEBUGGING
	// metrocluster_svm
	// MetroclusterSvm
	// configuration_state
	// ConfigurationState
	// unhealthy
	// END DEBUGGING
	// MetroclusterSvmConfigurationStateUnhealthy captures enum value "unhealthy"
	MetroclusterSvmConfigurationStateUnhealthy string = "unhealthy"
)

// prop value enum
func (m *MetroclusterSvm) validateConfigurationStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, metroclusterSvmTypeConfigurationStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MetroclusterSvm) validateConfigurationState(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigurationState) { // not required
		return nil
	}

	// value enum
	if err := m.validateConfigurationStateEnum("configuration_state", "body", m.ConfigurationState); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterSvm) validateFailedReason(formats strfmt.Registry) error {
	if swag.IsZero(m.FailedReason) { // not required
		return nil
	}

	if m.FailedReason != nil {
		if err := m.FailedReason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("failed_reason")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvm) validatePartnerSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.PartnerSvm) { // not required
		return nil
	}

	if m.PartnerSvm != nil {
		if err := m.PartnerSvm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_svm")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvm) validateSvm(formats strfmt.Registry) error {
	if swag.IsZero(m.Svm) { // not required
		return nil
	}

	if m.Svm != nil {
		if err := m.Svm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster svm based on the context it is used
func (m *MetroclusterSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurationState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailedReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePartnerSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSvm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvm) contextValidateCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Cluster != nil {
		if err := m.Cluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvm) contextValidateConfigurationState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "configuration_state", "body", string(m.ConfigurationState)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterSvm) contextValidateFailedReason(ctx context.Context, formats strfmt.Registry) error {

	if m.FailedReason != nil {
		if err := m.FailedReason.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("failed_reason")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvm) contextValidatePartnerSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.PartnerSvm != nil {
		if err := m.PartnerSvm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("partner_svm")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvm) contextValidateSvm(ctx context.Context, formats strfmt.Registry) error {

	if m.Svm != nil {
		if err := m.Svm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterSvm) UnmarshalBinary(b []byte) error {
	var res MetroclusterSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterSvmCluster metrocluster svm cluster
//
// swagger:model MetroclusterSvmCluster
type MetroclusterSvmCluster struct {

	// links
	Links *MetroclusterSvmClusterLinks `json:"_links,omitempty"`

	// name
	// Example: cluster1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	// Required: true
	// Format: uuid
	UUID *strfmt.UUID `json:"uuid"`
}

// Validate validates this metrocluster svm cluster
func (m *MetroclusterSvmCluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmCluster) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvmCluster) validateUUID(formats strfmt.Registry) error {

	if err := validate.Required("cluster"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	if err := validate.FormatOf("cluster"+"."+"uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster svm cluster based on the context it is used
func (m *MetroclusterSvmCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmCluster) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterSvmCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterSvmCluster) UnmarshalBinary(b []byte) error {
	var res MetroclusterSvmCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterSvmClusterLinks metrocluster svm cluster links
//
// swagger:model MetroclusterSvmClusterLinks
type MetroclusterSvmClusterLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster svm cluster links
func (m *MetroclusterSvmClusterLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmClusterLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster svm cluster links based on the context it is used
func (m *MetroclusterSvmClusterLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmClusterLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterSvmClusterLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterSvmClusterLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterSvmClusterLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterSvmPartnerSvm metrocluster svm partner svm
//
// swagger:model MetroclusterSvmPartnerSvm
type MetroclusterSvmPartnerSvm struct {

	// MetroCluster partner SVM name.
	// Read Only: true
	Name string `json:"name,omitempty"`

	// MetroCluster partner SVM UUID.
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this metrocluster svm partner svm
func (m *MetroclusterSvmPartnerSvm) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this metrocluster svm partner svm based on the context it is used
func (m *MetroclusterSvmPartnerSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmPartnerSvm) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "partner_svm"+"."+"name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *MetroclusterSvmPartnerSvm) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "partner_svm"+"."+"uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterSvmPartnerSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterSvmPartnerSvm) UnmarshalBinary(b []byte) error {
	var res MetroclusterSvmPartnerSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterSvmSvm metrocluster svm svm
//
// swagger:model MetroclusterSvmSvm
type MetroclusterSvmSvm struct {

	// links
	Links *MetroclusterSvmSvmLinks `json:"_links,omitempty"`

	// The name of the SVM.
	//
	// Example: svm1
	Name string `json:"name,omitempty"`

	// The unique identifier of the SVM.
	//
	// Example: 02c9e252-41be-11e9-81d5-00a0986138f7
	// Required: true
	UUID *string `json:"uuid"`
}

// Validate validates this metrocluster svm svm
func (m *MetroclusterSvmSvm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmSvm) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *MetroclusterSvmSvm) validateUUID(formats strfmt.Registry) error {

	if err := validate.Required("svm"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this metrocluster svm svm based on the context it is used
func (m *MetroclusterSvmSvm) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmSvm) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterSvmSvm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterSvmSvm) UnmarshalBinary(b []byte) error {
	var res MetroclusterSvmSvm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MetroclusterSvmSvmLinks metrocluster svm svm links
//
// swagger:model MetroclusterSvmSvmLinks
type MetroclusterSvmSvmLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this metrocluster svm svm links
func (m *MetroclusterSvmSvmLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmSvmLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this metrocluster svm svm links based on the context it is used
func (m *MetroclusterSvmSvmLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MetroclusterSvmSvmLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("svm" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MetroclusterSvmSvmLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MetroclusterSvmSvmLinks) UnmarshalBinary(b []byte) error {
	var res MetroclusterSvmSvmLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

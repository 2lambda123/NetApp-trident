// Code generated by go-swagger; DO NOT EDIT.

package storage

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new storage API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for storage API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	AggregateCollectionGet(params *AggregateCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateCollectionGetOK, error)

	AggregateCreate(params *AggregateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateCreateAccepted, error)

	AggregateDelete(params *AggregateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateDeleteAccepted, error)

	AggregateGet(params *AggregateGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateGetOK, error)

	AggregateModify(params *AggregateModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateModifyAccepted, error)

	AggregatePerformanceMetricsCollectionGet(params *AggregatePerformanceMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregatePerformanceMetricsCollectionGetOK, error)

	CloudStoreCollectionGet(params *CloudStoreCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreCollectionGetOK, error)

	CloudStoreCreate(params *CloudStoreCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreCreateAccepted, error)

	CloudStoreDelete(params *CloudStoreDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreDeleteAccepted, error)

	CloudStoreGet(params *CloudStoreGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreGetOK, error)

	CloudStoreModify(params *CloudStoreModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreModifyAccepted, error)

	DiskCollectionGet(params *DiskCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskCollectionGetOK, error)

	DiskGet(params *DiskGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskGetOK, error)

	DiskModify(params *DiskModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskModifyOK, error)

	FileCloneCreate(params *FileCloneCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileCloneCreateAccepted, error)

	FileInfoCollectionGet(params *FileInfoCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileInfoCollectionGetOK, error)

	FlexcacheCollectionGet(params *FlexcacheCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheCollectionGetOK, error)

	FlexcacheCreate(params *FlexcacheCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheCreateAccepted, error)

	FlexcacheDelete(params *FlexcacheDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheDeleteAccepted, error)

	FlexcacheGet(params *FlexcacheGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheGetOK, error)

	FlexcacheOriginCollectionGet(params *FlexcacheOriginCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheOriginCollectionGetOK, error)

	FlexcacheOriginGet(params *FlexcacheOriginGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheOriginGetOK, error)

	PlexCollectionGet(params *PlexCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PlexCollectionGetOK, error)

	PlexGet(params *PlexGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PlexGetOK, error)

	PortCollectionGet(params *PortCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PortCollectionGetOK, error)

	PortGet(params *PortGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PortGetOK, error)

	QosPolicyCollectionGet(params *QosPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyCollectionGetOK, error)

	QosPolicyCreate(params *QosPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyCreateAccepted, error)

	QosPolicyDelete(params *QosPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyDeleteAccepted, error)

	QosPolicyGet(params *QosPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyGetOK, error)

	QosPolicyModify(params *QosPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyModifyAccepted, error)

	QtreeCollectionGet(params *QtreeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeCollectionGetOK, error)

	QtreeCreate(params *QtreeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeCreateAccepted, error)

	QtreeDelete(params *QtreeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeDeleteAccepted, error)

	QtreeGet(params *QtreeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeGetOK, error)

	QtreeModify(params *QtreeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeModifyAccepted, error)

	QuotaReportCollectionGet(params *QuotaReportCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaReportCollectionGetOK, error)

	QuotaReportGet(params *QuotaReportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaReportGetOK, error)

	QuotaRuleCollectionGet(params *QuotaRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleCollectionGetOK, error)

	QuotaRuleCreate(params *QuotaRuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleCreateAccepted, error)

	QuotaRuleDelete(params *QuotaRuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleDeleteAccepted, error)

	QuotaRuleGet(params *QuotaRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleGetOK, error)

	QuotaRuleModify(params *QuotaRuleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleModifyAccepted, error)

	ShelfCollectionGet(params *ShelfCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShelfCollectionGetOK, error)

	ShelfGet(params *ShelfGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShelfGetOK, error)

	SnapshotCollectionGet(params *SnapshotCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotCollectionGetOK, error)

	SnapshotCreate(params *SnapshotCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotCreateAccepted, error)

	SnapshotDelete(params *SnapshotDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotDeleteAccepted, error)

	SnapshotGet(params *SnapshotGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotGetOK, error)

	SnapshotModify(params *SnapshotModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotModifyAccepted, error)

	SnapshotPolicyCollectionGet(params *SnapshotPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyCollectionGetOK, error)

	SnapshotPolicyCreate(params *SnapshotPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyCreateCreated, error)

	SnapshotPolicyDelete(params *SnapshotPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyDeleteOK, error)

	SnapshotPolicyGet(params *SnapshotPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyGetOK, error)

	SnapshotPolicyModify(params *SnapshotPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyModifyOK, error)

	SnapshotPolicyScheduleCollectionGet(params *SnapshotPolicyScheduleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleCollectionGetOK, error)

	SnapshotPolicyScheduleCreate(params *SnapshotPolicyScheduleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleCreateCreated, error)

	SnapshotPolicyScheduleDelete(params *SnapshotPolicyScheduleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleDeleteOK, error)

	SnapshotPolicyScheduleGet(params *SnapshotPolicyScheduleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleGetOK, error)

	SnapshotPolicyScheduleModify(params *SnapshotPolicyScheduleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleModifyOK, error)

	StorageClusterGet(params *StorageClusterGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StorageClusterGetOK, error)

	VolumeCollectionGet(params *VolumeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeCollectionGetOK, error)

	VolumeCreate(params *VolumeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeCreateAccepted, error)

	VolumeDelete(params *VolumeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeDeleteAccepted, error)

	VolumeGet(params *VolumeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeGetOK, error)

	VolumeMetricsCollectionGet(params *VolumeMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeMetricsCollectionGetOK, error)

	VolumeModify(params *VolumeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeModifyAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AggregateCollectionGet Retrieves the collection of aggregates for the entire cluster.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `metrics.*`
* `space.block_storage.inactive_user_data`
* `space.footprint`
* `statistics.*`
### Related ONTAP commands
* `storage aggregate show`

### Learn more
* [`DOC /storage/aggregates`](#docs-storage-storage_aggregates)
*/
func (a *Client) AggregateCollectionGet(params *AggregateCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAggregateCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "aggregate_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/aggregates",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AggregateCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AggregateCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AggregateCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AggregateCreate Automatically creates aggregates based on an optimal layout recommended by the system. Alternatively, properties can be provided to create an aggregate according to the requested specification. This request starts a job and returns a link to that job.
### Required properties
Properties are not required for this API. The following properties are only required if you want to specify properties for aggregate creation:
* `name` - Name of the aggregate.
* `node.name` or `node.uuid` - Node on which the aggregate will be created.
* `block_storage.primary.disk_count` - Number of disks to be used to create the aggregate.
### Default values
If not specified in POST, the following default values are assigned. The remaining unspecified properties will receive system dependent default values.
* `block_storage.mirror.enabled` - _false_
* `snaplock_type` - _non_snaplock_
### Related ONTAP commands
* `storage aggregate auto-provision`
* `storage aggregate create`
### Example:
```
POST /api/storage/aggregates {"node": {"name": "node1"}, "name": "test", "block_storage": {"primary": {"disk_count": "10"}}}
```

### Learn more
* [`DOC /storage/aggregates`](#docs-storage-storage_aggregates)
*/
func (a *Client) AggregateCreate(params *AggregateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAggregateCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "aggregate_create",
		Method:             "POST",
		PathPattern:        "/storage/aggregates",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AggregateCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AggregateCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AggregateCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AggregateDelete Deletes the aggregate specified by the UUID. This request starts a job and returns a link to that job.
### Related ONTAP commands
* `storage aggregate delete`

### Learn more
* [`DOC /storage/aggregates`](#docs-storage-storage_aggregates)
*/
func (a *Client) AggregateDelete(params *AggregateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAggregateDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "aggregate_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/aggregates/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AggregateDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AggregateDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AggregateDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AggregateGet Retrieves the aggregate specified by the UUID. The recommend query cannot be used for this operation.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `metrics.*`
* `space.block_storage.inactive_user_data`
* `space.footprint`
* `statistics.*`
### Related ONTAP commands
* `storage aggregate show`

### Learn more
* [`DOC /storage/aggregates`](#docs-storage-storage_aggregates)
*/
func (a *Client) AggregateGet(params *AggregateGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAggregateGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "aggregate_get",
		Method:             "GET",
		PathPattern:        "/storage/aggregates/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AggregateGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AggregateGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AggregateGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AggregateModify Updates the aggregate specified by the UUID with the properties in the body. This request starts a job and returns a link to that job.
### Related ONTAP commands
* `storage aggregate add-disks`
* `storage aggregate mirror`
* `storage aggregate modify`
* `storage aggregate relocation start`
* `storage aggregate rename`

### Learn more
* [`DOC /storage/aggregates`](#docs-storage-storage_aggregates)
*/
func (a *Client) AggregateModify(params *AggregateModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregateModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAggregateModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "aggregate_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/aggregates/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AggregateModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AggregateModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AggregateModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AggregatePerformanceMetricsCollectionGet Retrieves historical performance metrics for an aggregate.
### Learn more
* [`DOC /storage/aggregates/{uuid}/metrics`](#docs-storage-storage_aggregates_{uuid}_metrics)
*/
func (a *Client) AggregatePerformanceMetricsCollectionGet(params *AggregatePerformanceMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AggregatePerformanceMetricsCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAggregatePerformanceMetricsCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "aggregate_performance_metrics_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/aggregates/{uuid}/metrics",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AggregatePerformanceMetricsCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AggregatePerformanceMetricsCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AggregatePerformanceMetricsCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CloudStoreCollectionGet Retrieves the collection of cloud stores used by an aggregate.
### Related ONTAP commands
* `storage aggregate object-store show`

*/
func (a *Client) CloudStoreCollectionGet(params *CloudStoreCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudStoreCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloud_store_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/aggregates/{aggregate.uuid}/cloud-stores",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloudStoreCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloudStoreCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CloudStoreCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CloudStoreCreate Attaches an object store to an aggregate, or adds a second object store as a mirror.
### Required properties
* `target.uuid` or `target.name` - UUID or name of the cloud target.
### Recommended optional properties
* `primary` - _true_ if the object store is primary or _false_ if it is a mirror.
* `allow_flexgroups` - Allow attaching object store to an aggregate containing FlexGroup constituents.
* `check_only` - Validate only and do not add the cloud store.
### Default property values
* `primary` - _true_
* `allow_flexgroups` - _false_
* `check_only` - _false_
### Related ONTAP commands
* `storage aggregate object-store attach`
* `storage aggregate object-store mirror`

*/
func (a *Client) CloudStoreCreate(params *CloudStoreCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudStoreCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloud_store_create",
		Method:             "POST",
		PathPattern:        "/storage/aggregates/{aggregate.uuid}/cloud-stores",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloudStoreCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloudStoreCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CloudStoreCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CloudStoreDelete Removes the specified cloud target from the aggregate. Only removal of a mirror is allowed. The primary cannot be removed. This request starts a job and returns a link to that job.
### Related ONTAP commands
* `storage aggregate object-store unmirror`

*/
func (a *Client) CloudStoreDelete(params *CloudStoreDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudStoreDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloud_store_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/aggregates/{aggregate.uuid}/cloud-stores/{target.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloudStoreDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloudStoreDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CloudStoreDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CloudStoreGet Retrieves the cloud store for the aggregate using the specified cloud target UUID.
### Related ONTAP commands
* `storage aggregate object-store show`

*/
func (a *Client) CloudStoreGet(params *CloudStoreGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudStoreGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloud_store_get",
		Method:             "GET",
		PathPattern:        "/storage/aggregates/{aggregate.uuid}/cloud-stores/{target.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloudStoreGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloudStoreGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CloudStoreGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CloudStoreModify Updates the cloud store specified by the UUID with the fields in the body. This request starts a job and returns a link to that job.
### Related ONTAP commands
* `storage aggregate object-store modify`

*/
func (a *Client) CloudStoreModify(params *CloudStoreModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CloudStoreModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudStoreModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloud_store_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/aggregates/{aggregate.uuid}/cloud-stores/{target.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloudStoreModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloudStoreModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CloudStoreModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DiskCollectionGet Retrieves a collection of disks.
### Related ONTAP commands
* `storage disk show`
### Learn more
* [`DOC /storage/disks`](#docs-storage-storage_disks)

*/
func (a *Client) DiskCollectionGet(params *DiskCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiskCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "disk_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/disks",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiskCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiskCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiskCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DiskGet Retrieves a specific disk.
### Related ONTAP commands
* `storage disk show`
### Learn more
* [`DOC /storage/disks`](#docs-storage-storage_disks)

*/
func (a *Client) DiskGet(params *DiskGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiskGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "disk_get",
		Method:             "GET",
		PathPattern:        "/storage/disks/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiskGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiskGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiskGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DiskModify Updates the encryption controls of self-encrypting disks.
### Related ONTAP commands
* `storage encryption disk modify -data-key-id`
* `security key-manager key query -key-type NSE-AK`
### Learn more
* [`DOC /storage/disks`](#docs-storage-storage_disks)

*/
func (a *Client) DiskModify(params *DiskModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiskModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "disk_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/disks",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiskModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiskModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiskModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FileCloneCreate Creates a clone of the file.
*/
func (a *Client) FileCloneCreate(params *FileCloneCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileCloneCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileCloneCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_clone_create",
		Method:             "POST",
		PathPattern:        "/storage/file/clone",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileCloneCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileCloneCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileCloneCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FileInfoCollectionGet Retrieves a list of files and directories for a given directory of a volume.
### Learn more
* [`DOC /storage/volumes/{volume.uuid}/files/{path}`](#docs-storage-storage_volumes_{volume.uuid}_files_{path})
*/
func (a *Client) FileInfoCollectionGet(params *FileInfoCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FileInfoCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileInfoCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "file_info_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/volumes/{volume.uuid}/files/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FileInfoCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileInfoCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FileInfoCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FlexcacheCollectionGet Retrieves FlexCache in the cluster.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `origins.ip_address` - IP address of origin.
* `origins.size` - Physical size of origin.
* `origins.state` - State of origin.
* `size` - Physical size of FlexCache.
* `guarantee.type` - Space guarantee style of FlexCache.
* `aggregates.name` or `aggregates.uuid` - Name or UUID of aggregrate of FlexCache volume.
* `path` - Fully-qualified path of the owning SVM's namespace where the FlexCache is mounted.
### Related ONTAP commands
* `volume flexcache show`
### Learn more
* [`DOC /storage/flexcache/flexcaches`](#docs-storage-storage_flexcache_flexcaches)

*/
func (a *Client) FlexcacheCollectionGet(params *FlexcacheCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFlexcacheCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "flexcache_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/flexcache/flexcaches",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FlexcacheCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FlexcacheCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FlexcacheCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FlexcacheCreate Creates a FlexCache in the cluster.
### Required properties
* `name` - Name of FlexCache volume.
* `origins.volume.name` or `origins.volume.uuid` - Name or UUID of origin volume.
* `origins.svm.name` - Name of origin Vserver.
* `svm.name` or `svm.uuid` - Name or UUID of Vserver where FlexCache will be created.
### Recommended optional properties
* `path` - Path to mount the FlexCache volume
### Default property values
If not specified in POST, the following default property values are assigned:
* `size` - 10% of origin volume size or 1GB per constituent, whichever is greater.
* `guarantee.type` - Same as for a non-FlexCache FlexGroup volume.
* `constituents_per_aggregate` - 4 if aggregates.name or aggregates.uuid is used.
### Related ONTAP commands
* `volume flexcache create`
### Learn more
* [`DOC /storage/flexcache/flexcaches`](#docs-storage-storage_flexcache_flexcaches)

*/
func (a *Client) FlexcacheCreate(params *FlexcacheCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFlexcacheCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "flexcache_create",
		Method:             "POST",
		PathPattern:        "/storage/flexcache/flexcaches",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FlexcacheCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FlexcacheCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FlexcacheCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FlexcacheDelete Deletes a FlexCache. If a FlexCache volume is online, it is offlined before deletion.
### Related ONTAP commands
* `volume flexcache delete`
### Learn more
* [`DOC /storage/flexcache/flexcaches`](#docs-storage-storage_flexcache_flexcaches)

*/
func (a *Client) FlexcacheDelete(params *FlexcacheDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFlexcacheDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "flexcache_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/flexcache/flexcaches/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FlexcacheDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FlexcacheDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FlexcacheDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FlexcacheGet Retrieves attributes of the FlexCache in the cluster.
### Expensive properties
There is an added cost to retrieving values for these properties. They are included by default in GET. The recommended method to use this API is to filter and retrieve only the required fields. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `origins.ip_address` - IP address of origin.
* `origins.size` - Physical size of origin.
* `origins.state` - State of origin.
* `size` - Physical size of FlexCache.
* `guarantee.type` - Space guarantee style of FlexCache.
* `aggregates.name` or `aggregates.uuid` - Name or UUID of aggregrate of FlexCache volume.
* `path` - Fully-qualified path of the owning SVM's namespace where the FlexCache is mounted.
### Related ONTAP commands
* `volume flexcache show`
### Learn more
* [`DOC /storage/flexcache/flexcaches`](#docs-storage-storage_flexcache_flexcaches)

*/
func (a *Client) FlexcacheGet(params *FlexcacheGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFlexcacheGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "flexcache_get",
		Method:             "GET",
		PathPattern:        "/storage/flexcache/flexcaches/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FlexcacheGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FlexcacheGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FlexcacheGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FlexcacheOriginCollectionGet Retrieves origin of FlexCache in the cluster.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `flexcaches.ip_address` - IP address of FlexCache.
* `flexcaches.size` - Physical size of FlexCache.
* `flexcaches.guarantee.type` - Space guarantee style of FlexCache.
* `flexcaches.state` - State of FlexCache.
### Related ONTAP commands
* `volume flexcache origin show-caches`
### Learn more
* [`DOC /storage/flexcache/origins`](#docs-storage-storage_flexcache_origins)

*/
func (a *Client) FlexcacheOriginCollectionGet(params *FlexcacheOriginCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheOriginCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFlexcacheOriginCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "flexcache_origin_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/flexcache/origins",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FlexcacheOriginCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FlexcacheOriginCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FlexcacheOriginCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  FlexcacheOriginGet Retrieves attributes of the origin of a FlexCache in the cluster.
### Expensive properties
There is an added cost to retrieving values for these properties. They are included by default in GET results. The recommended method to use this API is to filter and retrieve only the required fields. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `flexcaches.ip_address` - IP address of FlexCache.
* `flexcaches.size` - Physical size of FlexCache.
* `flexcaches.guarantee.type` - Space guarantee style of FlexCache.
* `flexcaches.state` - State of FlexCache.
### Related ONTAP commands
* `volume flexcache origin show-caches`
### Learn more
* [`DOC /storage/flexcache/origins`](#docs-storage-storage_flexcache_origins)

*/
func (a *Client) FlexcacheOriginGet(params *FlexcacheOriginGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FlexcacheOriginGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFlexcacheOriginGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "flexcache_origin_get",
		Method:             "GET",
		PathPattern:        "/storage/flexcache/origins/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FlexcacheOriginGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FlexcacheOriginGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FlexcacheOriginGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PlexCollectionGet Retrieves the collection of plexes for the specified aggregate.
### Related ONTAP commands
* `storage aggregate plex show`

### Learn more
* [`DOC /storage/aggregates/{aggregate.uuid}/plexes`](#docs-storage-storage_aggregates_{aggregate.uuid}_plexes)
*/
func (a *Client) PlexCollectionGet(params *PlexCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PlexCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPlexCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "plex_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/aggregates/{aggregate.uuid}/plexes",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PlexCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PlexCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PlexCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PlexGet Retrieves the plex specified by the aggregate UUID and plex name.
### Related ONTAP commands
* `storage aggregate plex show`

### Learn more
* [`DOC /storage/aggregates/{aggregate.uuid}/plexes`](#docs-storage-storage_aggregates_{aggregate.uuid}_plexes)
*/
func (a *Client) PlexGet(params *PlexGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PlexGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPlexGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "plex_get",
		Method:             "GET",
		PathPattern:        "/storage/aggregates/{aggregate.uuid}/plexes/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PlexGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PlexGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PlexGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PortCollectionGet Retrieves a collection of storage ports.
### Related ONTAP commands
* `storage port show`
### Learn more
* [`DOC /storage/ports`](#docs-storage-storage_ports)

*/
func (a *Client) PortCollectionGet(params *PortCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PortCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPortCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "port_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/ports",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PortCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PortCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PortCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PortGet Retrieves a specific storage port.
### Related ONTAP commands
* `storage port show`
### Learn more
* [`DOC /storage/ports`](#docs-storage-storage_ports)

*/
func (a *Client) PortGet(params *PortGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PortGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPortGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "port_get",
		Method:             "GET",
		PathPattern:        "/storage/ports/{node.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PortGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PortGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PortGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QosPolicyCollectionGet Retrieves a collection of QoS policies.
### Learn more
* [`DOC /storage/qos/policies`](#docs-storage-storage_qos_policies)
*/
func (a *Client) QosPolicyCollectionGet(params *QosPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQosPolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qos_policy_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/qos/policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QosPolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QosPolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QosPolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QosPolicyCreate Creates a QoS policy.
### Required properties
* `svm.uuid` or `svm.name` - The existing SVM owning the QoS policy.
* `name` - The name of the QoS policy.
* `fixed.*` or `adaptive.*` - Either of the fixed or adaptive parameters.
### Default property values
* If `fixed.*` parameters are specified, then capacity.shared is set to false by default.
### Related ONTAP commands
* `qos policy-group create`
* `qos adaptive-policy-group create`

### Learn more
* [`DOC /storage/qos/policies`](#docs-storage-storage_qos_policies)
*/
func (a *Client) QosPolicyCreate(params *QosPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQosPolicyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qos_policy_create",
		Method:             "POST",
		PathPattern:        "/storage/qos/policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QosPolicyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QosPolicyCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QosPolicyCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QosPolicyDelete Deletes a QoS policy. All QoS workloads associated with the policy are removed.
### Related ONTAP commands
* `qos policy-group delete`
* `qos adaptive-policy-group delete`

### Learn more
* [`DOC /storage/qos/policies`](#docs-storage-storage_qos_policies)
*/
func (a *Client) QosPolicyDelete(params *QosPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQosPolicyDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qos_policy_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/qos/policies/{policy.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QosPolicyDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QosPolicyDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QosPolicyDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QosPolicyGet Retrieves a specific QoS policy.
### Related ONTAP commands
* `qos policy-group show`
* `qos adaptive-policy-group show`

### Learn more
* [`DOC /storage/qos/policies`](#docs-storage-storage_qos_policies)
*/
func (a *Client) QosPolicyGet(params *QosPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQosPolicyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qos_policy_get",
		Method:             "GET",
		PathPattern:        "/storage/qos/policies/{policy.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QosPolicyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QosPolicyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QosPolicyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QosPolicyModify Update a specific QoS policy.
### Related ONTAP commands
* `qos policy-group modify`
* `qos adaptive-policy-group modify`

### Learn more
* [`DOC /storage/qos/policies`](#docs-storage-storage_qos_policies)
*/
func (a *Client) QosPolicyModify(params *QosPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QosPolicyModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQosPolicyModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qos_policy_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/qos/policies/{policy.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QosPolicyModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QosPolicyModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QosPolicyModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QtreeCollectionGet Retrieves qtrees configured for all FlexVol volumes or FlexGroup volumes. <br/>
Use the `fields` query parameter to retrieve all properties of the qtree. If the `fields` query parameter is not used, then GET returns the qtree `name` and qtree `id` only.
### Related ONTAP commands
* `qtree show`

### Learn more
* [`DOC /storage/qtrees`](#docs-storage-storage_qtrees)
*/
func (a *Client) QtreeCollectionGet(params *QtreeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQtreeCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qtree_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/qtrees",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QtreeCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QtreeCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QtreeCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QtreeCreate Creates a qtree in a FlexVol or a FlexGroup volume. <br/>
After a qtree is created, the new qtree is assigned an identifier. This identifier is obtained using a qtree GET request. This identifier is used in the API path for the qtree PATCH and DELETE operations.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the qtree.
* `volume.uuid` or `volume.name` - Existing volume in which to create the qtree.
* `name` - Name for the qtree.
### Recommended optional properties
If not specified in POST, the values are inherited from the volume.
* `security_style` - Security style for the qtree.
* `unix_permissions` - UNIX permissions for the qtree.
* `export_policy.name or export_policy.id` - Export policy of the SVM for the qtree.
### Related ONTAP commands
* `qtree create`

### Learn more
* [`DOC /storage/qtrees`](#docs-storage-storage_qtrees)
*/
func (a *Client) QtreeCreate(params *QtreeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQtreeCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qtree_create",
		Method:             "POST",
		PathPattern:        "/storage/qtrees",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QtreeCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QtreeCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QtreeCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QtreeDelete Deletes a qtree.
### Related ONTAP commands
* `qtree delete`

### Learn more
* [`DOC /storage/qtrees`](#docs-storage-storage_qtrees)
*/
func (a *Client) QtreeDelete(params *QtreeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQtreeDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qtree_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/qtrees/{volume.uuid}/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QtreeDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QtreeDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QtreeDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QtreeGet Retrieves properties for a specific qtree identified by the `volume.uuid` and the `id` in the api path.
### Related ONTAP commands
* `qtree show`

### Learn more
* [`DOC /storage/qtrees`](#docs-storage-storage_qtrees)
*/
func (a *Client) QtreeGet(params *QtreeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQtreeGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qtree_get",
		Method:             "GET",
		PathPattern:        "/storage/qtrees/{volume.uuid}/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QtreeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QtreeGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QtreeGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QtreeModify Updates properties for a specific qtree.
### Related ONTAP commands
* `qtree modify`
* `qtree rename`

### Learn more
* [`DOC /storage/qtrees`](#docs-storage-storage_qtrees)
*/
func (a *Client) QtreeModify(params *QtreeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QtreeModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQtreeModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "qtree_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/qtrees/{volume.uuid}/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QtreeModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QtreeModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QtreeModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QuotaReportCollectionGet Retrieves the quota report records for all FlexVol volumes and FlexGroup volumes.
### Related ONTAP commands
* `quota report`

### Learn more
* [`DOC /storage/quota/reports`](#docs-storage-storage_quota_reports)
*/
func (a *Client) QuotaReportCollectionGet(params *QuotaReportCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaReportCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaReportCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "quota_report_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/quota/reports",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QuotaReportCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaReportCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QuotaReportCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QuotaReportGet Retrieves a specific quota report record.
### Related ONTAP commands
* `quota report`

### Learn more
* [`DOC /storage/quota/reports`](#docs-storage-storage_quota_reports)
*/
func (a *Client) QuotaReportGet(params *QuotaReportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaReportGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaReportGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "quota_report_get",
		Method:             "GET",
		PathPattern:        "/storage/quota/reports/{volume.uuid}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QuotaReportGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaReportGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QuotaReportGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QuotaRuleCollectionGet Retrieves quota policy rules configured for all FlexVol volumes and FlexGroup volumes.
### Related ONTAP commands
* `quota policy rule show`

### Learn more
* [`DOC /storage/quota/rules`](#docs-storage-storage_quota_rules)
*/
func (a *Client) QuotaRuleCollectionGet(params *QuotaRuleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaRuleCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "quota_rule_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/quota/rules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QuotaRuleCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaRuleCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QuotaRuleCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QuotaRuleCreate Creates a quota policy rule for a FlexVol or a FlexGroup volume.<br/>
Important notes:
* Unlike CLI/ONTAPI, the `quota policy` input is not needed for POST.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the qtree.
* `volume.uuid` or `volume.name` - Existing volume in which to create the qtree.
* `type` - Quota type for the rule. This type can be `user`, `group`, or `tree`.
* `users.name` or `user.id` -  If the quota type is user, this property takes the user name or user ID. For default user quota rules, the user name must be specified as "".
* `group.name` or `group.id` - If the quota type is group, this property takes the group name or group ID. For default group quota rules, the group name must be specified as "".
* `qtree.name` - Qtree for which to create the rule. For default tree rules, the qtree name must be specified as "".
### Recommended optional properties
* `space.hard_limit` - Specifies the space hard limit, in bytes. If less than 1024 bytes, the value is rounded up to 1024 bytes.
* `space.soft_limit` - Specifies the space soft limit, in bytes. If less than 1024 bytes, the value is rounded up to 1024 bytes.
* `files.hard_limit` - Specifies the hard limit for files.
* `files.hard_limit` - Specifies the soft limit for files.
* `user_mapping` - Specifies the user_mapping. This property is valid only for quota policy rules of type `user`.
### Related ONTAP commands
* `quota policy rule create`

### Learn more
* [`DOC /storage/quota/rules`](#docs-storage-storage_quota_rules)
*/
func (a *Client) QuotaRuleCreate(params *QuotaRuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaRuleCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "quota_rule_create",
		Method:             "POST",
		PathPattern:        "/storage/quota/rules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QuotaRuleCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaRuleCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QuotaRuleCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QuotaRuleDelete Deletes a quota policy rule.
### Related ONTAP commands
* `quota policy rule delete`

### Learn more
* [`DOC /storage/quota/rules`](#docs-storage-storage_quota_rules)
*/
func (a *Client) QuotaRuleDelete(params *QuotaRuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaRuleDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "quota_rule_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/quota/rules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QuotaRuleDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaRuleDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QuotaRuleDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QuotaRuleGet Retrieves properties for a specific quota policy rule.
### Related ONTAP commands
* `quota policy rule show`

### Learn more
* [`DOC /storage/quota/rules`](#docs-storage-storage_quota_rules)
*/
func (a *Client) QuotaRuleGet(params *QuotaRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaRuleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "quota_rule_get",
		Method:             "GET",
		PathPattern:        "/storage/quota/rules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QuotaRuleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaRuleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QuotaRuleGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  QuotaRuleModify Updates properties of a specific quota policy rule. <br>
Important notes:
* The quota resize functionality is supported with the PATCH operation.
* Quota resize allows you to modify the quota limits, directly in the filesystem.
* The quota must be enabled on a FlexVol or a FlexGroup volume for `quota resize` to take effect.
* If the quota is disabled on the volume, the quota policy rule PATCH API modifies the rule, but this does not affect the limits in the filesystem.
### Related ONTAP commands
* `quota policy rule modify`
* `quota resize`

### Learn more
* [`DOC /storage/quota/rules`](#docs-storage-storage_quota_rules)
*/
func (a *Client) QuotaRuleModify(params *QuotaRuleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QuotaRuleModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaRuleModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "quota_rule_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/quota/rules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QuotaRuleModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaRuleModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*QuotaRuleModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ShelfCollectionGet Retrieves a collection of shelves.
### Related ONTAP commands
* `storage shelf show`
* `storage shelf port show`
* `storage shelf drawer show`
### Learn more
* [`DOC /storage/shelves`](#docs-storage-storage_shelves)

*/
func (a *Client) ShelfCollectionGet(params *ShelfCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShelfCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShelfCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shelf_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/shelves",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShelfCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShelfCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShelfCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ShelfGet Retrieves a specific shelf.
### Related ONTAP commands
* `storage shelf show`
* `storage shelf port show`
* `storage shelf drawer show`
### Learn more
* [`DOC /storage/shelves`](#docs-storage-storage_shelves)

*/
func (a *Client) ShelfGet(params *ShelfGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShelfGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShelfGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shelf_get",
		Method:             "GET",
		PathPattern:        "/storage/shelves/{uid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ShelfGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ShelfGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ShelfGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotCollectionGet Retrieves a collection of volume Snapshot copies.
### Related ONTAP commands
* `snapshot show`
### Learn more
* [`DOC /storage/volumes/{volume.uuid}/snapshots`](#docs-storage-storage_volumes_{volume.uuid}_snapshots)

*/
func (a *Client) SnapshotCollectionGet(params *SnapshotCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/volumes/{volume.uuid}/snapshots",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotCreate Creates a volume Snapshot copy.
### Required properties
* `name` - Name of the Snapshot copy to be created.
### Recommended optional properties
* `comment` - Comment associated with the Snapshot copy.
* `expiry_time` - Snapshot copies with an expiry time set are not allowed to be deleted until the retention time is reached.
### Related ONTAP commands
* `snapshot create`
### Learn more
* [`DOC /storage/volumes/{volume.uuid}/snapshots`](#docs-storage-storage_volumes_{volume.uuid}_snapshots)

*/
func (a *Client) SnapshotCreate(params *SnapshotCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_create",
		Method:             "POST",
		PathPattern:        "/storage/volumes/{volume.uuid}/snapshots",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotDelete Deletes a Volume Snapshot copy.
### Related ONTAP commands
* `snapshot delete`
### Learn more
* [`DOC /storage/volumes/{volume.uuid}/snapshots`](#docs-storage-storage_volumes_{volume.uuid}_snapshots)

*/
func (a *Client) SnapshotDelete(params *SnapshotDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/volumes/{volume.uuid}/snapshots/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotGet Retrieves details of a specific volume Snapshot copy.
### Related ONTAP commands
* `snapshot show`
### Learn more
* [`DOC /storage/volumes/{volume.uuid}/snapshots`](#docs-storage-storage_volumes_{volume.uuid}_snapshots)

*/
func (a *Client) SnapshotGet(params *SnapshotGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_get",
		Method:             "GET",
		PathPattern:        "/storage/volumes/{volume.uuid}/snapshots/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotModify Updates a Volume Snapshot copy.
### Related ONTAP commands
* `snapshot modify`
* `snapshot rename`
### Learn more
* [`DOC /storage/volumes/{volume.uuid}/snapshots`](#docs-storage-storage_volumes_{volume.uuid}_snapshots)

*/
func (a *Client) SnapshotModify(params *SnapshotModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/volumes/{volume.uuid}/snapshots/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyCollectionGet Retrieves a collection of Snapshot copy policies.
### Related ONTAP commands
* `snapshot policy show`
### Learn more
* [`DOC /storage/snapshot-policies`](#docs-storage-storage_snapshot-policies)

*/
func (a *Client) SnapshotPolicyCollectionGet(params *SnapshotPolicyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/snapshot-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyCreate Creates a Snapshot copy policy.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the Snapshot copy policy.
* `name` - Name for the Snapshot copy policy.
* `copies.schedule` - Schedule at which Snapshot copies are captured on the volume.
* `copies.count` - Number of Snapshot copies to maintain for this schedule.
### Recommended optional properties
* `copies.prefix` - Prefix to use when creating Snapshot copies at regular intervals.
### Default property values
If not specified in POST, the following default property values are assigned:
* `enabled` - _true_
* `copies.prefix` - Value of `schedule.name`
### Related ONTAP commands
* `snapshot policy create`
### Learn more
* [`DOC /storage/snapshot-policies`](#docs-storage-storage_snapshot-policies)

*/
func (a *Client) SnapshotPolicyCreate(params *SnapshotPolicyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_create",
		Method:             "POST",
		PathPattern:        "/storage/snapshot-policies",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyDelete Deletes a Snapshot copy policy
### Related ONTAP commands
* `snapshot policy delete`
### Learn more
* [`DOC /storage/snapshot-policies`](#docs-storage-storage_snapshot-policies)

*/
func (a *Client) SnapshotPolicyDelete(params *SnapshotPolicyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/snapshot-policies/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyGet Retrieves details of a specific Snapshot copy policy.
### Related ONTAP commands
* `snapshot policy show`
### Learn more
* [`DOC /storage/snapshot-policies`](#docs-storage-storage_snapshot-policies)

*/
func (a *Client) SnapshotPolicyGet(params *SnapshotPolicyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_get",
		Method:             "GET",
		PathPattern:        "/storage/snapshot-policies/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyModify Updates a Snapshot copy policy
### Related ONTAP commands
* `snapshot policy modify`
* `snapshot policy modify-schedule`
* `snapshot policy add-schedule`
### Learn more
* [`DOC /storage/snapshot-policies`](#docs-storage-storage_snapshot-policies)

*/
func (a *Client) SnapshotPolicyModify(params *SnapshotPolicyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/snapshot-policies/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyScheduleCollectionGet Retrieves a collection of Snapshot copy policy schedules.
### Related ONTAP commands
* `snapshot policy show`
### Learn more
* [`DOC /storage/snapshot-policies/{snapshot-policy.uuid}/schedules`](#docs-storage-storage_snapshot-policies_{snapshot-policy.uuid}_schedules)

*/
func (a *Client) SnapshotPolicyScheduleCollectionGet(params *SnapshotPolicyScheduleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyScheduleCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_schedule_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/snapshot-policies/{snapshot-policy.uuid}/schedules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyScheduleCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyScheduleCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyScheduleCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyScheduleCreate Adds a schedule to a Snapshot copy policy.
### Required properties
* `schedule.uuid` or `schedule.name` - Schedule at which Snapshot copies are captured on the volume.
* `count` - Number of Snapshot copies to maintain for this schedule.
### Recommended optional properties
* `prefix` - Prefix to use when creating Snapshot copies at regular intervals.
### Default property values
If not specified in POST, the following default property values are assigned:
* `prefix` - Value of `schedule.name`
### Related ONTAP commands
* `snapshot policy add-schedule`
### Learn more
* [`DOC /storage/snapshot-policies/{snapshot-policy.uuid}/schedules`](#docs-storage-storage_snapshot-policies_{snapshot-policy.uuid}_schedules)

*/
func (a *Client) SnapshotPolicyScheduleCreate(params *SnapshotPolicyScheduleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyScheduleCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_schedule_create",
		Method:             "POST",
		PathPattern:        "/storage/snapshot-policies/{snapshot-policy.uuid}/schedules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyScheduleCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyScheduleCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyScheduleCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyScheduleDelete Deletes a schedule from a Snapshot copy policy
### Related ONTAP commands
* `snapshot policy remove-schedule`
### Learn more
* [`DOC /storage/snapshot-policies/{snapshot-policy.uuid}/schedules`](#docs-storage-storage_snapshot-policies_{snapshot-policy.uuid}_schedules)

*/
func (a *Client) SnapshotPolicyScheduleDelete(params *SnapshotPolicyScheduleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyScheduleDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_schedule_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/snapshot-policies/{snapshot-policy.uuid}/schedules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyScheduleDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyScheduleDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyScheduleDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyScheduleGet Retrieves details of a specific Snapshot copy policy schedule.
### Related ONTAP commands
* `snapshot policy show`
### Learn more
* [`DOC /storage/snapshot-policies/{snapshot-policy.uuid}/schedules`](#docs-storage-storage_snapshot-policies_{snapshot-policy.uuid}_schedules)

*/
func (a *Client) SnapshotPolicyScheduleGet(params *SnapshotPolicyScheduleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyScheduleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_schedule_get",
		Method:             "GET",
		PathPattern:        "/storage/snapshot-policies/{snapshot-policy.uuid}/schedules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyScheduleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyScheduleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyScheduleGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SnapshotPolicyScheduleModify Updates a Snapshot copy policy schedule
### Related ONTAP commands
* `snapshot policy modify-schedule`
### Learn more
* [`DOC /storage/snapshot-policies/{snapshot-policy.uuid}/schedules`](#docs-storage-storage_snapshot-policies_{snapshot-policy.uuid}_schedules)

*/
func (a *Client) SnapshotPolicyScheduleModify(params *SnapshotPolicyScheduleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SnapshotPolicyScheduleModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotPolicyScheduleModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "snapshot_policy_schedule_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/snapshot-policies/{snapshot-policy.uuid}/schedules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SnapshotPolicyScheduleModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotPolicyScheduleModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SnapshotPolicyScheduleModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  StorageClusterGet Reports cluster wide storage details across different tiers. By default, this endpoint returns all fields.
Supports the following roles: admin, and readonly.

*/
func (a *Client) StorageClusterGet(params *StorageClusterGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StorageClusterGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStorageClusterGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "storage_cluster_get",
		Method:             "GET",
		PathPattern:        "/storage/cluster",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StorageClusterGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*StorageClusterGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StorageClusterGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  VolumeCollectionGet Retrieves volumes.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `is_svm_root`
* `application.*`
* `encryption.*`
* `clone.parent_snapshot.name`
* `clone.parent_snapshot.uuid`
* `clone.parent_svm.name`
* `clone.parent_svm.uuid`
* `clone.parent_volume.name`
* `clone.parent_volume.uuid`
* `clone.split_complete_percent`
* `clone.split_estimate`
* `clone.split_initiated`
* `efficiency.*`
* `error_state.*`
* `files.*`
* `nas.export_policy.id`
* `nas.gid`
* `nas.path`
* `nas.security_style`
* `nas.uid`
* `nas.unix_permissions`
* `snaplock.*`
* `restore_to.*`
* `snapshot_policy.uuid`
* `quota.*`
* `qos.*`
* `flexcache_endpoint_type`
* `space.block_storage_inactive_user_data`
* `space.capacity_tier_footprint`
* `space.footprint`
* `space.over_provisioned`
* `space.metadata`
* `space.logical_space.*`
* `space.snapshot.*`
* `guarantee.*`
* `autosize.*`
* `movement.*`
* `statistics.*`
### Related ONTAP commands
* `volume show`
* `volume clone show`
* `volume efficiency show`
* `volume encryption show`
* `volume flexcache show`
* `volume flexgroup show`
* `volume move show`
* `volume quota show`
* `volume show-space`
* `volume snaplock show`

### Learn more
* [`DOC /storage/volumes`](#docs-storage-storage_volumes)
*/
func (a *Client) VolumeCollectionGet(params *VolumeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVolumeCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "volume_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/volumes",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VolumeCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VolumeCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VolumeCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  VolumeCreate Creates a volume on a specified SVM and storage aggregates.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the volume.
* `name` - Name of the volume.
* `aggregates.name` or `aggregates.uuid` - Existing aggregates in which to create the volume.
### Default property values
* `state` -  _online_
* `size` - _20MB_
* `style` - _flexvol_
* `type` - _rw_
* `encryption.enabled` - _false_
* `snapshot_policy.name` - _default_
* `gaurantee.type` - _volume_
### Related ONTAP commands
* `volume create`
* `volume clone create`

### Learn more
* [`DOC /storage/volumes`](#docs-storage-storage_volumes)
*/
func (a *Client) VolumeCreate(params *VolumeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVolumeCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "volume_create",
		Method:             "POST",
		PathPattern:        "/storage/volumes",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VolumeCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VolumeCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VolumeCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  VolumeDelete Deletes a volume. If the UUID belongs to a volume, all of its blocks are freed and returned to its containing aggregate. If a volume is online, it is offlined before deletion. If a volume is mounted, unmount the volume by specifying the nas.path as empty before deleting it using the DELETE operation.
### Related ONTAP commands
* `volume delete`
* `volume clone delete`

### Learn more
* [`DOC /storage/volumes`](#docs-storage-storage_volumes)
*/
func (a *Client) VolumeDelete(params *VolumeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVolumeDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "volume_delete",
		Method:             "DELETE",
		PathPattern:        "/storage/volumes/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VolumeDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VolumeDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VolumeDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  VolumeGet Retrieves a volume. The GET API can be used to retrieve the quota state for a FlexVol or a FlexGroup volume.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `is_svm_root`
* `application.*`
* `encryption.*`
* `clone.parent_snapshot.name`
* `clone.parent_snapshot.uuid`
* `clone.parent_svm.name`
* `clone.parent_svm.uuid`
* `clone.parent_volume.name`
* `clone.parent_volume.uuid`
* `clone.split_complete_percent`
* `clone.split_estimate`
* `clone.split_initiated`
* `efficiency.*`
* `error_state.*`
* `files.*`
* `nas.export_policy.id`
* `nas.gid`
* `nas.path`
* `nas.security_style`
* `nas.uid`
* `nas.unix_permissions`
* `snaplock.*`
* `restore_to.*`
* `snapshot_policy.uuid`
* `quota.*`
* `qos.*`
* `flexcache_endpoint_type`
* `space.block_storage_inactive_user_data`
* `space.capacity_tier_footprint`
* `space.footprint`
* `space.over_provisioned`
* `space.metadata`
* `space.logical_space.*`
* `space.snapshot.*`
* `guarantee.*`
* `autosize.*`
* `movement.*`
* `statistics.*`
### Related ONTAP commands
* `volume show`
* `volume clone show`
* `volume efficiency show`
* `volume encryption show`
* `volume flexcache show`
* `volume flexgroup show`
* `volume move show`
* `volume quota show`
* `volume show-space`
* `volume snaplock show`

### Learn more
* [`DOC /storage/volumes`](#docs-storage-storage_volumes)
*/
func (a *Client) VolumeGet(params *VolumeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVolumeGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "volume_get",
		Method:             "GET",
		PathPattern:        "/storage/volumes/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VolumeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VolumeGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VolumeGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  VolumeMetricsCollectionGet Retrieves historical performance metrics for a volume.
*/
func (a *Client) VolumeMetricsCollectionGet(params *VolumeMetricsCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeMetricsCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVolumeMetricsCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "volume_metrics_collection_get",
		Method:             "GET",
		PathPattern:        "/storage/volumes/{volume.uuid}/metrics",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VolumeMetricsCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VolumeMetricsCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VolumeMetricsCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  VolumeModify Updates the attributes of a volume. For movement, use the "validate_only" field on the request to validate but not perform the operation. The PATCH API can be used to enable or disable quotas for a FlexVol or a FlexGroup volume.
### Related ONTAP commands
* `volume modify`
* `volume clone modify`
* `volume efficiency modify`
* `volume quota on`
* `volume quota off`
* `volume snaplock modify`

### Learn more
* [`DOC /storage/volumes`](#docs-storage-storage_volumes)
*/
func (a *Client) VolumeModify(params *VolumeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VolumeModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVolumeModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "volume_modify",
		Method:             "PATCH",
		PathPattern:        "/storage/volumes/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VolumeModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VolumeModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VolumeModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

// Code generated by go-swagger; DO NOT EDIT.

package cluster

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new cluster API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for cluster API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ChassisCollectionGet(params *ChassisCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChassisCollectionGetOK, error)

	ChassisGet(params *ChassisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChassisGetOK, error)

	ClusterCollectionPerformanceMetricsGet(params *ClusterCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterCollectionPerformanceMetricsGetOK, error)

	ClusterCreate(params *ClusterCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterCreateAccepted, error)

	ClusterGet(params *ClusterGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterGetOK, error)

	ClusterModify(params *ClusterModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterModifyAccepted, error)

	ClusterNtpKeysCollectionGet(params *ClusterNtpKeysCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysCollectionGetOK, error)

	ClusterNtpKeysCreate(params *ClusterNtpKeysCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysCreateCreated, error)

	ClusterNtpKeysDelete(params *ClusterNtpKeysDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysDeleteOK, error)

	ClusterNtpKeysGet(params *ClusterNtpKeysGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysGetOK, error)

	ClusterNtpKeysModify(params *ClusterNtpKeysModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysModifyOK, error)

	ClusterNtpServersCollectionGet(params *ClusterNtpServersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersCollectionGetOK, error)

	ClusterNtpServersCreate(params *ClusterNtpServersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersCreateAccepted, error)

	ClusterNtpServersDelete(params *ClusterNtpServersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersDeleteAccepted, error)

	ClusterNtpServersGet(params *ClusterNtpServersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersGetOK, error)

	ClusterNtpServersModify(params *ClusterNtpServersModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersModifyAccepted, error)

	ClusterPeerCollectionGet(params *ClusterPeerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerCollectionGetOK, error)

	ClusterPeerCreate(params *ClusterPeerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerCreateCreated, error)

	ClusterPeerDelete(params *ClusterPeerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerDeleteOK, error)

	ClusterPeerGet(params *ClusterPeerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerGetOK, error)

	ClusterPeerModify(params *ClusterPeerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerModifyOK, error)

	JobCollectionGet(params *JobCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobCollectionGetOK, error)

	JobGet(params *JobGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobGetOK, error)

	JobModify(params *JobModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobModifyOK, error)

	LicenseCreate(params *LicenseCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicenseCreateCreated, error)

	LicenseDelete(params *LicenseDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicenseDeleteOK, error)

	LicenseGet(params *LicenseGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicenseGetOK, error)

	LicensesGet(params *LicensesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicensesGetOK, error)

	NodeDelete(params *NodeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeDeleteAccepted, error)

	NodeGet(params *NodeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeGetOK, error)

	NodeModify(params *NodeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeModifyAccepted, error)

	NodesCreate(params *NodesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodesCreateAccepted, error)

	NodesGet(params *NodesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodesGetOK, error)

	ScheduleCollectionGet(params *ScheduleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleCollectionGetOK, error)

	ScheduleCreate(params *ScheduleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleCreateCreated, error)

	ScheduleDelete(params *ScheduleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleDeleteOK, error)

	ScheduleGet(params *ScheduleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleGetOK, error)

	ScheduleModify(params *ScheduleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleModifyOK, error)

	SoftwareDownloadGet(params *SoftwareDownloadGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareDownloadGetOK, error)

	SoftwareGet(params *SoftwareGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareGetOK, error)

	SoftwareHistoryCollectionGet(params *SoftwareHistoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareHistoryCollectionGetOK, error)

	SoftwareModify(params *SoftwareModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareModifyAccepted, error)

	SoftwarePackageCreate(params *SoftwarePackageCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackageCreateAccepted, error)

	SoftwarePackageDelete(params *SoftwarePackageDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackageDeleteAccepted, error)

	SoftwarePackageGet(params *SoftwarePackageGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackageGetOK, error)

	SoftwarePackagesCollectionGet(params *SoftwarePackagesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackagesCollectionGetOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  ChassisCollectionGet Retrieves a collection of chassis.
### Related ONTAP commands
* `system chassis show`
* `system chassis fru show`
### Learn more
* [`DOC /cluster/chassis`](#docs-cluster-cluster_chassis)

*/
func (a *Client) ChassisCollectionGet(params *ChassisCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChassisCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewChassisCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "chassis_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/chassis",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ChassisCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ChassisCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ChassisCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ChassisGet Retrieves a specific chassis.
### Related ONTAP commands
* `system chassis show`
* `system chassis fru show`
### Learn more
* [`DOC /cluster/chassis`](#docs-cluster-cluster_chassis)

*/
func (a *Client) ChassisGet(params *ChassisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChassisGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewChassisGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "chassis_get",
		Method:             "GET",
		PathPattern:        "/cluster/chassis/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ChassisGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ChassisGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ChassisGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterCollectionPerformanceMetricsGet Retrieves historical performance metrics for the cluster.
*/
func (a *Client) ClusterCollectionPerformanceMetricsGet(params *ClusterCollectionPerformanceMetricsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterCollectionPerformanceMetricsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterCollectionPerformanceMetricsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_collection_performance_metrics_get",
		Method:             "GET",
		PathPattern:        "/cluster/metrics",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterCollectionPerformanceMetricsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterCollectionPerformanceMetricsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterCollectionPerformanceMetricsGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterCreate Creates a cluster.
### Required properties
* `name`
* `password`
### Recommended optional properties
* `location`
* `contact`
* `dns_domains`
* `name_servers`
* `ntp_servers`
* `license`
* `configuration_backup`
* `management_interface`
* `nodes`
* `timezone`
### Learn more
* [`DOC /cluster`](#docs-cluster-cluster)

*/
func (a *Client) ClusterCreate(params *ClusterCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_create",
		Method:             "POST",
		PathPattern:        "/cluster",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterGet Retrieves the cluster configuration.
### Learn more
* [`DOC /cluster`](#docs-cluster-cluster)
*/
func (a *Client) ClusterGet(params *ClusterGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_get",
		Method:             "GET",
		PathPattern:        "/cluster",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterModify Updates the cluster configuration after the cluster is created.
### Related ONTAP commands * `cluster identity modify` * `system node modify` * `vserver services dns modify` * `vserver services name-service dns modify` * `timezone` * `security ssl modify`
### Learn more
* [`DOC /cluster`](#docs-cluster-cluster)
*/
func (a *Client) ClusterModify(params *ClusterModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpKeysCollectionGet Retrieves the collection of NTP symmetric authentication keys known by ONTAP that
are uniquely indexed by an identifier.
### Related ONTAP commands
* `cluster time-service ntp key show`
### Learn more
* [`DOC /cluster/ntp/keys`](#docs-cluster-cluster_ntp_keys)

*/
func (a *Client) ClusterNtpKeysCollectionGet(params *ClusterNtpKeysCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpKeysCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_keys_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/ntp/keys",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpKeysCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpKeysCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpKeysCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpKeysCreate Creates an NTP symmetric authentication key entry including the type of key
using an unused identifier or index number (ID).
### Required properties
* `id` - Shared symmetric key number (ID).
* `digest_type` - Shared private key cryptographic hash type.
* `value` - Value of shared private key.
### Related ONTAP commands
* `cluster time-service ntp key create`
### Learn more
* [`DOC /cluster/ntp/keys`](#docs-cluster-cluster_ntp_keys)

*/
func (a *Client) ClusterNtpKeysCreate(params *ClusterNtpKeysCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpKeysCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_keys_create",
		Method:             "POST",
		PathPattern:        "/cluster/ntp/keys",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpKeysCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpKeysCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpKeysCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpKeysDelete Deletes an NTP key.
### Related ONTAP commands
* `cluster time-service ntp key delete`
### Learn more
* [`DOC /cluster/ntp/keys`](#docs-cluster-cluster_ntp_keys)

*/
func (a *Client) ClusterNtpKeysDelete(params *ClusterNtpKeysDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpKeysDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_keys_delete",
		Method:             "DELETE",
		PathPattern:        "/cluster/ntp/keys/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpKeysDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpKeysDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpKeysDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpKeysGet Retrieves the details of a specific NTP symmetric authentication key by numeric identifier or index (ID).
### Related ONTAP commands
* `cluster time-service ntp key show`
### Learn more
* [`DOC /cluster/ntp/keys`](#docs-cluster-cluster_ntp_keys)

*/
func (a *Client) ClusterNtpKeysGet(params *ClusterNtpKeysGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpKeysGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_keys_get",
		Method:             "GET",
		PathPattern:        "/cluster/ntp/keys/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpKeysGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpKeysGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpKeysGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpKeysModify Updates the details of a specific NTP symmetric authentication key by numeric
identifier or index (ID).
### Required properties
* `digest_type` - Shared private key cryptographic hash type.
* `value` - Value of shared private key.
### Related ONTAP commands
* `cluster time-service ntp key modify`
### Learn more
* [`DOC /cluster/ntp/keys`](#docs-cluster-cluster_ntp_keys)

*/
func (a *Client) ClusterNtpKeysModify(params *ClusterNtpKeysModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpKeysModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpKeysModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_keys_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster/ntp/keys/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpKeysModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpKeysModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpKeysModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpServersCollectionGet Retrieves the collection of external NTP time servers ONTAP uses for time adjustment and correction.
### Related ONTAP commands
* `cluster time-service ntp server show`
### Learn more
* [`DOC /cluster/ntp/servers`](#docs-cluster-cluster_ntp_servers)

*/
func (a *Client) ClusterNtpServersCollectionGet(params *ClusterNtpServersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpServersCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_servers_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/ntp/servers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpServersCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpServersCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpServersCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpServersCreate Validates the provided external NTP time server for usage and configures ONTAP so that all nodes in the cluster use it.
The required fields are:
* `server`
### Default property values
If not specified in POST, the following default property values are assigned:
* `version` - auto
* `key` - not set
###
If the key is provided in POST, `authentication_enabled` is set to `true` by default.
### Related ONTAP commands
* `cluster time-service ntp server create`
### Learn more
* [`DOC /cluster/ntp/servers`](#docs-cluster-cluster_ntp_servers)

*/
func (a *Client) ClusterNtpServersCreate(params *ClusterNtpServersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpServersCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_servers_create",
		Method:             "POST",
		PathPattern:        "/cluster/ntp/servers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpServersCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpServersCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpServersCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpServersDelete Deletes an external NTP server used by ONTAP.
### Related ONTAP commands
* `cluster time-service ntp server delete`
### Learn more
* [`DOC /cluster/ntp/servers`](#docs-cluster-cluster_ntp_servers)

*/
func (a *Client) ClusterNtpServersDelete(params *ClusterNtpServersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpServersDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_servers_delete",
		Method:             "DELETE",
		PathPattern:        "/cluster/ntp/servers/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpServersDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpServersDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpServersDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpServersGet Retrieves the configuration of an external NTP server used by ONTAP.
### Related ONTAP commands
* `cluster time-service ntp server show`
### Learn more
* [`DOC /cluster/ntp/servers`](#docs-cluster-cluster_ntp_servers)

*/
func (a *Client) ClusterNtpServersGet(params *ClusterNtpServersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpServersGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_servers_get",
		Method:             "GET",
		PathPattern:        "/cluster/ntp/servers/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpServersGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpServersGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpServersGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNtpServersModify Updates the configuration of an NTP server used by the ONTAP cluster after validation.
Patchable fields are:
* `version`
* `key.id`
* `authentication_enabled`
</br>
If `authentication_enabled` is modified to `false`, the associated NTP key is removed from the server instance.
If `authentication_enabled` is modified to `true`, you must provide an NTP key ID in the PATCH body.
### Related ONTAP commands
* `cluster time-service ntp server modify`
### Learn more
* [`DOC /cluster/ntp/servers`](#docs-cluster-cluster_ntp_servers)

*/
func (a *Client) ClusterNtpServersModify(params *ClusterNtpServersModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNtpServersModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNtpServersModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ntp_servers_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster/ntp/servers/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNtpServersModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNtpServersModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNtpServersModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterPeerCollectionGet Retrieves the collection of cluster peers.
### Learn more
* [`DOC /cluster/peers`](#docs-cluster-cluster_peers)
*/
func (a *Client) ClusterPeerCollectionGet(params *ClusterPeerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterPeerCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_peer_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/peers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterPeerCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterPeerCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterPeerCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterPeerCreate Creates a peering relationship and, optionally, the IP interfaces it will use. There are two methods used to create a peering relationship:
* Provide a remote IP address - Used when creating a new cluster peer relationship with a specific remote cluster. This requires at least one remote intercluster IP address from the remote cluster.
* Do not provide a remote IP address - Used when the remote IP address is not provided and when the storage system is ready to accept peering requests from foreign clusters.
### Required properties
* `remote.ip_addresses` - Addresses of the remote peers. The local peer must be able to reach and connect to these addresses for the request to succeed in creating a peer. Only required when creating a peering relationship by providing a remote IP address.
* Either set `generate_passphrase` to "true" or provide a passphrase in the body of the request. Only one of these options is required.
### Recommended optional properties
* `name` - Name of the peering relationship or name of the remote peer.
* `passphrase` - User generated passphrase for use in authentication.
* `generate_passphrase` (true/false) - When "true", ONTAP automatically generates a passphrase to authenticate cluster peers.
* `ipspace` - IPspace of the local intercluster LIFs. Assumes Default IPspace if not provided.
* `initial_allowed_svms` - Local SVMs allowed to peer with the peer cluster's SVMs. Can be modified until the remote cluster accepts this cluster peering relationship.
* `local_network` - Fields to create a local intercluster LIF.
* `expiry_time` - Duration in ISO 8601 format for which the user-supplied or auto-generated passphrase is valid. Expiration time must not be greater than seven days into the future. ISO 8601 duration format is "PnDTnHnMnS" or "PnW" where n is a positive integer. The "nD", "nH", "nM" and "nS" fields can be dropped if zero. "P" must always be present and "T" must be present if there are any hours, minutes, or seconds fields.
* `encryption_proposed` (none/tls-psk) - Encryption mechanism of the communication channel between the two peers.
* `peer_applications` - SVM peering applications (SnapMirror, FlexCache or both) for which the SVM peering relationship is set up.
### Additional information
As with creating a cluster peer through the CLI, the combinations of options must be valid in order for the create operation to succeed. The following list shows the combinations that will succeed and those that will fail:
* A passphrase only (fail)
* A peer IP address (fail)
* A passphrase with an expiration time > 7 days into the future (fail)
* A peer IP address and a passphrase (OK)
* generate_passphrase=true (OK)
* Any proposed encryption protocol (OK)
* An IPspace name or UUID (OK)
* A passphrase, peer IP address, and any proposed encryption protocol (OK)
* A non empty list of initial allowed SVM peer names or UUIDs. (OK)

### Learn more
* [`DOC /cluster/peers`](#docs-cluster-cluster_peers)
*/
func (a *Client) ClusterPeerCreate(params *ClusterPeerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterPeerCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_peer_create",
		Method:             "POST",
		PathPattern:        "/cluster/peers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterPeerCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterPeerCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterPeerCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterPeerDelete Deletes a cluster peer.
### Learn more
* [`DOC /cluster/peers`](#docs-cluster-cluster_peers)
*/
func (a *Client) ClusterPeerDelete(params *ClusterPeerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterPeerDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_peer_delete",
		Method:             "DELETE",
		PathPattern:        "/cluster/peers/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterPeerDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterPeerDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterPeerDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterPeerGet Retrieves a specific cluster peer instance.
### Learn more
* [`DOC /cluster/peers`](#docs-cluster-cluster_peers)
*/
func (a *Client) ClusterPeerGet(params *ClusterPeerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterPeerGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_peer_get",
		Method:             "GET",
		PathPattern:        "/cluster/peers/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterPeerGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterPeerGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterPeerGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterPeerModify Updates a cluster peer instance.
### Learn more
* [`DOC /cluster/peers`](#docs-cluster-cluster_peers)
*/
func (a *Client) ClusterPeerModify(params *ClusterPeerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterPeerModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterPeerModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_peer_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster/peers/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterPeerModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterPeerModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterPeerModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  JobCollectionGet Retrieves a list of recently running asynchronous jobs. After a job transitions to a failure or success state, it is deleted after a default time of 300 seconds.
### Learn more
* [`DOC /cluster/jobs`](#docs-cluster-cluster_jobs)
*/
func (a *Client) JobCollectionGet(params *JobCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJobCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "job_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/jobs",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &JobCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*JobCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*JobCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  JobGet Retrieves the details of a specific asynchronous job. After a job transitions to a failure or success state, it is deleted after a default time of 300 seconds.
### Learn more
* [`DOC /cluster/jobs`](#docs-cluster-cluster_jobs)
*/
func (a *Client) JobGet(params *JobGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJobGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "job_get",
		Method:             "GET",
		PathPattern:        "/cluster/jobs/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &JobGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*JobGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*JobGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  JobModify Updates the state of a specific asynchronous job.
### Learn more
* [`DOC /cluster/jobs`](#docs-cluster-cluster_jobs)
*/
func (a *Client) JobModify(params *JobModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJobModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "job_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster/jobs/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &JobModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*JobModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*JobModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LicenseCreate Installs one or more feature licenses.
### Required properties
* `keys` - Array containing a list of NLF or 26-character license keys.
### Related ONTAP commands
* `system license add`

### Learn more
* [`DOC /cluster/licensing/licenses`](#docs-cluster-cluster_licensing_licenses)
*/
func (a *Client) LicenseCreate(params *LicenseCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicenseCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLicenseCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "license_create",
		Method:             "POST",
		PathPattern:        "/cluster/licensing/licenses",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LicenseCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LicenseCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LicenseCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LicenseDelete Deletes a license.
### Related ONTAP commands
* `system license delete`

### Learn more
* [`DOC /cluster/licensing/licenses/{name}`](#docs-cluster-cluster_licensing_licenses_{name})
*/
func (a *Client) LicenseDelete(params *LicenseDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicenseDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLicenseDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "license_delete",
		Method:             "DELETE",
		PathPattern:        "/cluster/licensing/licenses/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LicenseDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LicenseDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LicenseDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LicenseGet Retrieves a specific license package.
### Related ONTAP commands
* `system license show`
* `system license show-status`

### Learn more
* [`DOC /cluster/licensing/licenses/{name}`](#docs-cluster-cluster_licensing_licenses_{name})
*/
func (a *Client) LicenseGet(params *LicenseGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicenseGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLicenseGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "license_get",
		Method:             "GET",
		PathPattern:        "/cluster/licensing/licenses/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LicenseGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LicenseGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LicenseGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LicensesGet Retrieves a collection of license packages.
### Related ONTAP commands
* `system license show-status`
* `system license show`

### Learn more
* [`DOC /cluster/licensing/licenses`](#docs-cluster-cluster_licensing_licenses)
*/
func (a *Client) LicensesGet(params *LicensesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LicensesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLicensesGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "licenses_get",
		Method:             "GET",
		PathPattern:        "/cluster/licensing/licenses",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LicensesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LicensesGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LicensesGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NodeDelete Deletes a node from the cluster.
Note that before deleting a node from the cluster, you must shut down all of the node's shared resources, such as virtual interfaces to clients. If any of the node's shared resources are still active, the command fails.
### Optional parameters:
* `force` - Forcibly removes a node that is down and cannot be brought online to remove its shared resources. This flag is set to "false" by default.
### Related ONTAP commands
* `cluster remove-node`
### Learn more
* [`DOC /cluster/nodes`](#docs-cluster-cluster_nodes)

*/
func (a *Client) NodeDelete(params *NodeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "node_delete",
		Method:             "DELETE",
		PathPattern:        "/cluster/nodes/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodeDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodeDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NodeGet Retrieves information for the node.
### Related ONTAP commands
* `cluster add-node-status`
* `cluster date show`
* `cluster ha show`
* `network interface show`
* `network port show`
* `storage failover show`
* `system controller show`
* `system node show`
* `system node show-discovered`
* `system service-processor network show`
* `system service-processor show`
* `version`

### Learn more
* [`DOC /cluster/nodes`](#docs-cluster-cluster_nodes)
*/
func (a *Client) NodeGet(params *NodeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "node_get",
		Method:             "GET",
		PathPattern:        "/cluster/nodes/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodeGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NodeModify Updates the node information or performs shutdown/reboot actions on a node.
### Related ONTAP commands
* `cluster ha modify`
* `storage failover modify`
* `system node modify`
* `system node reboot`
* `system service-processor network modify`

### Learn more
* [`DOC /cluster/nodes`](#docs-cluster-cluster_nodes)
*/
func (a *Client) NodeModify(params *NodeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "node_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster/nodes/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodeModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodeModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NodesCreate Adds a node or nodes to the cluster.
### Required properties
* `cluster_interface.ip.address`
### Related ONTAP commands
* `cluster add-node`
* `network interface create`
* `storage aggregate auto-provision`
* `system node modify`
* `system service-processor network modify`

### Learn more
* [`DOC /cluster/nodes`](#docs-cluster-cluster_nodes)
*/
func (a *Client) NodesCreate(params *NodesCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodesCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nodes_create",
		Method:             "POST",
		PathPattern:        "/cluster/nodes",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodesCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodesCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NodesGet Retrieves the nodes in the cluster.
### Related ONTAP commands
* `system node show`

### Learn more
* [`DOC /cluster/nodes`](#docs-cluster-cluster_nodes)
*/
func (a *Client) NodesGet(params *NodesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nodes_get",
		Method:             "GET",
		PathPattern:        "/cluster/nodes",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodesGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ScheduleCollectionGet Retrieves a schedule.
### Learn more
* [`DOC /cluster/schedules`](#docs-cluster-cluster_schedules)
*/
func (a *Client) ScheduleCollectionGet(params *ScheduleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScheduleCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "schedule_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/schedules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ScheduleCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ScheduleCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ScheduleCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ScheduleCreate Creates a schedule.
### Required Fields
* name - Name of the job schedule.
You must provide a minutes field for a cron schedule and an interval field for an interval schedule. Do not provide both a cron field and an interval field.

### Learn more
* [`DOC /cluster/schedules`](#docs-cluster-cluster_schedules)
*/
func (a *Client) ScheduleCreate(params *ScheduleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScheduleCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "schedule_create",
		Method:             "POST",
		PathPattern:        "/cluster/schedules",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ScheduleCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ScheduleCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ScheduleCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ScheduleDelete Deletes a schedule.
### Learn more
* [`DOC /cluster/schedules`](#docs-cluster-cluster_schedules)
*/
func (a *Client) ScheduleDelete(params *ScheduleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScheduleDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "schedule_delete",
		Method:             "DELETE",
		PathPattern:        "/cluster/schedules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ScheduleDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ScheduleDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ScheduleDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ScheduleGet Retrieves a schedule.
### Learn more
* [`DOC /cluster/schedules`](#docs-cluster-cluster_schedules)
*/
func (a *Client) ScheduleGet(params *ScheduleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScheduleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "schedule_get",
		Method:             "GET",
		PathPattern:        "/cluster/schedules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ScheduleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ScheduleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ScheduleGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ScheduleModify Updates a schedule. Note that you cannot modify a cron field of an interval schedule, or the interval field of a cron schedule.
### Learn more
* [`DOC /cluster/schedules`](#docs-cluster-cluster_schedules)
*/
func (a *Client) ScheduleModify(params *ScheduleModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ScheduleModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScheduleModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "schedule_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster/schedules/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ScheduleModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ScheduleModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ScheduleModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwareDownloadGet Retrieves the software download status.
### Related ONTAP commands
* `cluster image package check-download-progress`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwareDownloadGet(params *SoftwareDownloadGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareDownloadGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwareDownloadGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_download_get",
		Method:             "GET",
		PathPattern:        "/cluster/software/download",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwareDownloadGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwareDownloadGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwareDownloadGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwareGet Retrieves the software profile of a cluster.
### Related ONTAP commands
* `cluster image show`
* `cluster image show-update-progress`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwareGet(params *SoftwareGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwareGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_get",
		Method:             "GET",
		PathPattern:        "/cluster/software",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwareGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwareGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwareGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwareHistoryCollectionGet Retrieves the history details for software installation requests.
### Related ONTAP commands
* `cluster image show-update-history`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwareHistoryCollectionGet(params *SoftwareHistoryCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareHistoryCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwareHistoryCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_history_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/software/history",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwareHistoryCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwareHistoryCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwareHistoryCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwareModify Updates the cluster software version.
Important note:
  * Setting 'version' triggers the package installation.
  * To validate the package for installation but not perform the installation, use the `validate_only` field on the request.
### Required properties
* `version` - Software version to be installed on the cluster.
### Recommended optional parameters
* `validate_only` - Required to validate a software package before an upgrade.
* `skip_warnings` - Used to skip validation warnings when starting a software upgrade.
* `action` - Used to pause, resume, or cancel an ongoing software upgrade.
### Related ONTAP commands
* `cluster image validate`
* `cluster image update`
* `cluster image pause-update`
* `cluster image resume-update`
* `cluster image cancel-update`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwareModify(params *SoftwareModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwareModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwareModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_modify",
		Method:             "PATCH",
		PathPattern:        "/cluster/software",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwareModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwareModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwareModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwarePackageCreate Downloads a software package from the server.
### Required properties
* `url` - URL location of the software package
### Recommended optional parameters
* `username` - Username of HTTPS/FTP server
* `password` - Password of HTTPS/FTP server
### Related ONTAP commands
* `cluster image package get`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwarePackageCreate(params *SoftwarePackageCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackageCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwarePackageCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_package_create",
		Method:             "POST",
		PathPattern:        "/cluster/software/download",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwarePackageCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwarePackageCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwarePackageCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwarePackageDelete Deletes a software package from the cluster. The delete operation fails if the package is currently installed.
### Related ONTAP commands
* `cluster image package delete`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwarePackageDelete(params *SoftwarePackageDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackageDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwarePackageDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_package_delete",
		Method:             "DELETE",
		PathPattern:        "/cluster/software/packages/{version}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwarePackageDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwarePackageDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwarePackageDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwarePackageGet Retrieves the software package information.
### Related ONTAP commands
* `cluster image package show-repository`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwarePackageGet(params *SoftwarePackageGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackageGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwarePackageGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_package_get",
		Method:             "GET",
		PathPattern:        "/cluster/software/packages/{version}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwarePackageGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwarePackageGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwarePackageGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SoftwarePackagesCollectionGet Retrieves the software packages for a cluster.
### Related ONTAP commands
* `cluster image package show-repository`
### Learn more
* [`DOC /cluster/software`](#docs-cluster-cluster_software)

*/
func (a *Client) SoftwarePackagesCollectionGet(params *SoftwarePackagesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SoftwarePackagesCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSoftwarePackagesCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "software_packages_collection_get",
		Method:             "GET",
		PathPattern:        "/cluster/software/packages",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SoftwarePackagesCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SoftwarePackagesCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SoftwarePackagesCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

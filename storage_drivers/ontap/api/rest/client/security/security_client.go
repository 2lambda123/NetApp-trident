// Code generated by go-swagger; DO NOT EDIT.

package security

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new security API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for security API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	AccountCollectionGet(params *AccountCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountCollectionGetOK, error)

	AccountCreate(params *AccountCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountCreateCreated, error)

	AccountDelete(params *AccountDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountDeleteOK, error)

	AccountGet(params *AccountGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountGetOK, error)

	AccountModify(params *AccountModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountModifyOK, error)

	AccountPasswordCreate(params *AccountPasswordCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountPasswordCreateCreated, error)

	AccountPublickeyDelete(params *AccountPublickeyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountPublickeyDeleteOK, error)

	AuditLogForwardingGet(params *AuditLogForwardingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditLogForwardingGetOK, error)

	ClusterAccountAdProxyCreate(params *ClusterAccountAdProxyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyCreateCreated, error)

	ClusterAccountAdProxyDelete(params *ClusterAccountAdProxyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyDeleteOK, error)

	ClusterAccountAdProxyGet(params *ClusterAccountAdProxyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyGetOK, error)

	ClusterAccountAdProxyModify(params *ClusterAccountAdProxyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyModifyOK, error)

	ClusterLdapCreate(params *ClusterLdapCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapCreateCreated, error)

	ClusterLdapDelete(params *ClusterLdapDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapDeleteOK, error)

	ClusterLdapGet(params *ClusterLdapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapGetOK, error)

	ClusterLdapModify(params *ClusterLdapModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapModifyOK, error)

	ClusterNisCreate(params *ClusterNisCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisCreateCreated, error)

	ClusterNisDelete(params *ClusterNisDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisDeleteOK, error)

	ClusterNisGet(params *ClusterNisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisGetOK, error)

	ClusterNisModify(params *ClusterNisModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisModifyOK, error)

	LoginMessagesCollectionGet(params *LoginMessagesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LoginMessagesCollectionGetOK, error)

	LoginMessagesGet(params *LoginMessagesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LoginMessagesGetOK, error)

	LoginMessagesModify(params *LoginMessagesModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LoginMessagesModifyOK, error)

	PublickeyCollectionGet(params *PublickeyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyCollectionGetOK, error)

	PublickeyCreate(params *PublickeyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyCreateCreated, error)

	PublickeyGet(params *PublickeyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyGetOK, error)

	PublickeyModify(params *PublickeyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyModifyOK, error)

	RoleCollectionGet(params *RoleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleCollectionGetOK, error)

	RoleCreate(params *RoleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleCreateCreated, error)

	RoleDelete(params *RoleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleDeleteOK, error)

	RoleGet(params *RoleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleGetOK, error)

	RolePrivilegeCollectionGet(params *RolePrivilegeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeCollectionGetOK, error)

	RolePrivilegeCreate(params *RolePrivilegeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeCreateCreated, error)

	RolePrivilegeDelete(params *RolePrivilegeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeDeleteOK, error)

	RolePrivilegeGet(params *RolePrivilegeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeGetOK, error)

	RolePrivilegeModify(params *RolePrivilegeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeModifyOK, error)

	SecurityAuditGet(params *SecurityAuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityAuditGetOK, error)

	SecurityAuditLogCollectionGet(params *SecurityAuditLogCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityAuditLogCollectionGetOK, error)

	SecurityAuditModify(params *SecurityAuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityAuditModifyAccepted, error)

	SecurityCertificateCollectionGet(params *SecurityCertificateCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateCollectionGetOK, error)

	SecurityCertificateCreate(params *SecurityCertificateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateCreateCreated, error)

	SecurityCertificateDelete(params *SecurityCertificateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateDeleteOK, error)

	SecurityCertificateGet(params *SecurityCertificateGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateGetOK, error)

	SecurityCertificateSign(params *SecurityCertificateSignParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateSignOK, error)

	SecurityConfigGet(params *SecurityConfigGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityConfigGetOK, error)

	SecurityKeyManagerCollectionGet(params *SecurityKeyManagerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerCollectionGetOK, error)

	SecurityKeyManagerCreate(params *SecurityKeyManagerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerCreateCreated, error)

	SecurityKeyManagerDelete(params *SecurityKeyManagerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerDeleteOK, error)

	SecurityKeyManagerGet(params *SecurityKeyManagerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerGetOK, error)

	SecurityKeyManagerKeyServersCollectionGet(params *SecurityKeyManagerKeyServersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersCollectionGetOK, error)

	SecurityKeyManagerKeyServersCreate(params *SecurityKeyManagerKeyServersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersCreateCreated, error)

	SecurityKeyManagerKeyServersDelete(params *SecurityKeyManagerKeyServersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersDeleteOK, error)

	SecurityKeyManagerKeyServersGet(params *SecurityKeyManagerKeyServersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersGetOK, error)

	SecurityKeyManagerKeyServersModify(params *SecurityKeyManagerKeyServersModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersModifyOK, error)

	SecurityKeyManagerMigrate(params *SecurityKeyManagerMigrateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerMigrateAccepted, error)

	SecurityKeyManagerModify(params *SecurityKeyManagerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerModifyOK, error)

	SecurityLogForwardingCreate(params *SecurityLogForwardingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingCreateAccepted, error)

	SecurityLogForwardingDelete(params *SecurityLogForwardingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingDeleteOK, error)

	SecurityLogForwardingGet(params *SecurityLogForwardingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingGetOK, error)

	SecurityLogForwardingModify(params *SecurityLogForwardingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingModifyOK, error)

	SecuritySamlSpCreate(params *SecuritySamlSpCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpCreateAccepted, error)

	SecuritySamlSpDelete(params *SecuritySamlSpDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpDeleteOK, error)

	SecuritySamlSpGet(params *SecuritySamlSpGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpGetOK, error)

	SecuritySamlSpModify(params *SecuritySamlSpModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpModifyOK, error)

	SSHGet(params *SSHGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SSHGetOK, error)

	SSHModify(params *SSHModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SSHModifyOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AccountCollectionGet Retrieves a list of user accounts in the cluster.
### Related ONTAP commands
* `security login show`
### Learn more
* [`DOC /security/accounts`](#docs-security-security_accounts)

*/
func (a *Client) AccountCollectionGet(params *AccountCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccountCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "account_collection_get",
		Method:             "GET",
		PathPattern:        "/security/accounts",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccountCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccountCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AccountCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AccountCreate Creates a new user account.
### Required parameters
* `name` - Account name to be created.
* `applications` - Array of one or more application tuples (of application and authentication methods).
### Optional parameters
* `owner.name` or `owner.uuid`  - Name or UUID of the SVM for an SVM-scoped user account. If not supplied, a cluster-scoped user account is created.
* `role` - RBAC role for the user account. Defaulted to `admin` for cluster user account and to `vsadmin` for SVM-scoped account.
* `password` - Password for the user account (if the authentication method is opted as password for one or more of applications).
* `second_authentication_method` - Needed for MFA and only supported for ssh application. Defaults to `none` if not supplied.
* `comment` - Comment for the user account (e.g purpose of this account).
* `locked` - Locks the account after creation. Defaults to `false` if not supplied.
### Related ONTAP commands
* `security login create`
### Learn more
* [`DOC /security/accounts`](#docs-security-security_accounts)

*/
func (a *Client) AccountCreate(params *AccountCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccountCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "account_create",
		Method:             "POST",
		PathPattern:        "/security/accounts",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccountCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccountCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AccountCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AccountDelete Deletes a user account.
### Required parameters
* `name` - Account name to be deleted.
* `owner.uuid`  - UUID of the SVM housing the user account to be deleted.
### Related ONTAP commands
* `security login delete`
### Learn more
* [`DOC /security/accounts/{owner.uuid}/{name}`](#docs-security-security_accounts_{owner.uuid}_{name})
* [`DOC /security/accounts`](#docs-security-security_accounts)

*/
func (a *Client) AccountDelete(params *AccountDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccountDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "account_delete",
		Method:             "DELETE",
		PathPattern:        "/security/accounts/{owner.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccountDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccountDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AccountDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AccountGet Retrieves a specific user account.
### Related ONTAP commands
* `security login show`
### Learn more
* [`DOC /security/accounts/{owner.uuid}/{name}`](#docs-security-security_accounts_{owner.uuid}_{name})
* [`DOC /security/accounts`](#docs-security-security_accounts)

*/
func (a *Client) AccountGet(params *AccountGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccountGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "account_get",
		Method:             "GET",
		PathPattern:        "/security/accounts/{owner.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccountGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccountGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AccountGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AccountModify Updates a user account. Locks or unlocks a user account and/or updates the role, applications, and/or password for the user account.
### Required parameters
* `name` - Account name to be updated.
* `owner.uuid`  - UUID of the SVM housing the user account to be updated.
### Optional parameters
* `applications` - Array of one or more tuples (of application and authentication methods).
* `role` - RBAC role for the user account.
* `password` - Password for the user account (if the authentication method is opted as password for one or more of applications).
* `second_authentication_method` - Needed for MFA and only supported for ssh application. Defaults to `none` if not supplied.
* `comment` - Comment for the user account (e.g purpose of this account).
* `locked` - Set to true/false to lock/unlock the account.
### Related ONTAP commands
* `security login create`
* `security login modify`
* `security login password`
* `security login lock`
* `security login unlock`
### Learn more
* [`DOC /security/accounts/{owner.uuid}/{name}`](#docs-security-security_accounts_{owner.uuid}_{name})
* [`DOC /security/accounts`](#docs-security-security_accounts)

*/
func (a *Client) AccountModify(params *AccountModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccountModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "account_modify",
		Method:             "PATCH",
		PathPattern:        "/security/accounts/{owner.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccountModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccountModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AccountModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AccountPasswordCreate Updates the password for a user account.
### Required parameters
* `name` - User account name.
* `password` - New password for the user account.
### Optional parameters
* `owner.name` or `owner.uuid` - Name or UUID of the SVM for an SVM-scoped user account.
### Related ONTAP commands
* `security login password`
### Learn more
* [`DOC /security/authentication/password`](#docs-security-security_authentication_password)
* [`DOC /security/accounts`](#docs-security-security_accounts)

*/
func (a *Client) AccountPasswordCreate(params *AccountPasswordCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountPasswordCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccountPasswordCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "account_password_create",
		Method:             "POST",
		PathPattern:        "/security/authentication/password",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccountPasswordCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccountPasswordCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AccountPasswordCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AccountPublickeyDelete Deletes the public key for a user account.
### Learn more
* [`DOC /security/authentication/publickeys/{owner.uuid}/{account.name}/{index}`](#docs-security-security_authentication_publickeys_{owner.uuid}_{account.name}_{index})
*/
func (a *Client) AccountPublickeyDelete(params *AccountPublickeyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccountPublickeyDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccountPublickeyDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "account_publickey_delete",
		Method:             "DELETE",
		PathPattern:        "/security/authentication/publickeys/{owner.uuid}/{account.name}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccountPublickeyDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccountPublickeyDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AccountPublickeyDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  AuditLogForwardingGet Defines a remote syslog/splunk server for sending audit information to.
### Learn more
* [`DOC /security/audit/destinations`](#docs-security-security_audit_destinations)
*/
func (a *Client) AuditLogForwardingGet(params *AuditLogForwardingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AuditLogForwardingGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuditLogForwardingGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "audit_log_forwarding_get",
		Method:             "GET",
		PathPattern:        "/security/audit/destinations",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AuditLogForwardingGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuditLogForwardingGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AuditLogForwardingGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterAccountAdProxyCreate Configures a data SVM as a proxy for Active Directory-based authentication for cluster user accounts.
### Learn more
* [`DOC /security/authentication/cluster/ad-proxy`](#docs-security-security_authentication_cluster_ad-proxy)
*/
func (a *Client) ClusterAccountAdProxyCreate(params *ClusterAccountAdProxyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterAccountAdProxyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_account_ad_proxy_create",
		Method:             "POST",
		PathPattern:        "/security/authentication/cluster/ad-proxy",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterAccountAdProxyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterAccountAdProxyCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterAccountAdProxyCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterAccountAdProxyDelete Deletes the data SVM configured as a tunnel for Active Directory-based authentication for cluster user accounts.
### Learn more
* [`DOC /security/authentication/cluster/ad-proxy`](#docs-security-security_authentication_cluster_ad-proxy)
*/
func (a *Client) ClusterAccountAdProxyDelete(params *ClusterAccountAdProxyDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterAccountAdProxyDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_account_ad_proxy_delete",
		Method:             "DELETE",
		PathPattern:        "/security/authentication/cluster/ad-proxy",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterAccountAdProxyDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterAccountAdProxyDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterAccountAdProxyDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterAccountAdProxyGet Retrieves SVM information configured as an Active Directory domain-tunnel.
### Learn more
* [`DOC /security/authentication/cluster/ad-proxy`](#docs-security-security_authentication_cluster_ad-proxy)
*/
func (a *Client) ClusterAccountAdProxyGet(params *ClusterAccountAdProxyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterAccountAdProxyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_account_ad_proxy_get",
		Method:             "GET",
		PathPattern:        "/security/authentication/cluster/ad-proxy",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterAccountAdProxyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterAccountAdProxyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterAccountAdProxyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterAccountAdProxyModify Updates the data SVM configured as a tunnel for Active Directory-based authentication for cluster user accounts.
### Learn more
* [`DOC /security/authentication/cluster/ad-proxy`](#docs-security-security_authentication_cluster_ad-proxy)
*/
func (a *Client) ClusterAccountAdProxyModify(params *ClusterAccountAdProxyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterAccountAdProxyModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterAccountAdProxyModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_account_ad_proxy_modify",
		Method:             "PATCH",
		PathPattern:        "/security/authentication/cluster/ad-proxy",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterAccountAdProxyModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterAccountAdProxyModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterAccountAdProxyModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterLdapCreate A cluster can have only one LDAP configuration. IPv6 must be enabled if IPv6 family addresses are specified.
### Required properties
* `servers` - List of LDAP servers used for this client configuration.
* `bind_dn` - Specifies the user that binds to the LDAP servers.
* `base_dn` - Specifies the default base DN for all searches.
### Recommended optional properties
* `schema` - Schema template name.
* `port` - Port used to connect to the LDAP Servers.
* `min_bind_level` - Minimum bind authentication level.
* `bind_password` - Specifies the bind password for the LDAP servers.
* `base_scope` - Specifies the default search scope for LDAP queries.
* `use_start_tls` - Specifies whether or not to use Start TLS over LDAP connections.
* `session_security` - Specifies the level of security to be used for LDAP communications.
### Default property values
* `schema` - _RFC-2307_
* `port` - _389_
* `min_bind_level` - _simple_
* `base_scope` - _subtree_
* `use_start_tls` - _false_
* `session_security` - _none_
<br/>
Configuring more than one LDAP server is recommended to avoid a single point of failure. Both FQDNs and IP addresses are supported for the `servers` property.
The LDAP servers are validated as part of this operation. LDAP validation fails in the following scenarios:<br/>
1. The server does not have LDAP installed.
2. The server is invalid.
3. The server is unreachable.<br/>

### Learn more
* [`DOC /security/authentication/cluster/ldap`](#docs-security-security_authentication_cluster_ldap)
*/
func (a *Client) ClusterLdapCreate(params *ClusterLdapCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterLdapCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ldap_create",
		Method:             "POST",
		PathPattern:        "/security/authentication/cluster/ldap",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterLdapCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterLdapCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterLdapCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterLdapDelete Deletes the LDAP configuration of the cluster.

### Learn more
* [`DOC /security/authentication/cluster/ldap`](#docs-security-security_authentication_cluster_ldap)
*/
func (a *Client) ClusterLdapDelete(params *ClusterLdapDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterLdapDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ldap_delete",
		Method:             "DELETE",
		PathPattern:        "/security/authentication/cluster/ldap",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterLdapDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterLdapDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterLdapDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterLdapGet Retrieves the cluster LDAP configuration.

### Learn more
* [`DOC /security/authentication/cluster/ldap`](#docs-security-security_authentication_cluster_ldap)
*/
func (a *Client) ClusterLdapGet(params *ClusterLdapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterLdapGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ldap_get",
		Method:             "GET",
		PathPattern:        "/security/authentication/cluster/ldap",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterLdapGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterLdapGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterLdapGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterLdapModify Both mandatory and optional parameters of the LDAP configuration can be updated.
IPv6 must be enabled if IPv6 family addresses are specified. Configuring more than one LDAP server is recommended to avoid a single point of failure. Both FQDNs and IP addresses are supported for the `servers` property.
The LDAP servers are validated as part of this operation. LDAP validation fails in the following scenarios:<br/>
1. The server does not have LDAP installed.
2. The server is invalid.
3. The server is unreachable. <br/>

### Learn more
* [`DOC /security/authentication/cluster/ldap`](#docs-security-security_authentication_cluster_ldap)
*/
func (a *Client) ClusterLdapModify(params *ClusterLdapModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterLdapModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterLdapModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_ldap_modify",
		Method:             "PATCH",
		PathPattern:        "/security/authentication/cluster/ldap",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterLdapModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterLdapModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterLdapModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNisCreate The cluster can have one NIS server configuration. Specify the NIS domain and NIS servers as input. Domain name and servers fields cannot be empty.
Both FQDNs and IP addresses are supported for the `server` property. IPv6 must be enabled if IPv6 family addresses are specified in the `server` property. A maximum of ten NIS servers are supported.
### Required properties
* `domain` - NIS domain to which this configuration belongs.
* `servers` - List of hostnames or IP addresses of NIS servers used by the NIS domain configuration.

### Learn more
* [`DOC /security/authentication/cluster/nis`](#docs-security-security_authentication_cluster_nis)
*/
func (a *Client) ClusterNisCreate(params *ClusterNisCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNisCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_nis_create",
		Method:             "POST",
		PathPattern:        "/security/authentication/cluster/nis",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNisCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNisCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNisCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNisDelete Deletes the NIS configuration of the cluster. NIS can be removed as a source from ns-switch if NIS is not used for lookups.

### Learn more
* [`DOC /security/authentication/cluster/nis`](#docs-security-security_authentication_cluster_nis)
*/
func (a *Client) ClusterNisDelete(params *ClusterNisDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNisDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_nis_delete",
		Method:             "DELETE",
		PathPattern:        "/security/authentication/cluster/nis",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNisDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNisDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNisDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNisGet Retrieves the NIS configuration of the cluster. Both NIS domain and servers are displayed by default.
The `bound_servers` property indicates the successfully bound NIS servers.

### Learn more
* [`DOC /security/authentication/cluster/nis`](#docs-security-security_authentication_cluster_nis)
*/
func (a *Client) ClusterNisGet(params *ClusterNisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNisGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_nis_get",
		Method:             "GET",
		PathPattern:        "/security/authentication/cluster/nis",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNisGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNisGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNisGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ClusterNisModify Both NIS domain and servers can be updated. Domains and servers cannot be empty. Both FQDNs and IP addresses are supported for the 'servers' field. If the domain is updated, NIS servers must also be specified. IPv6 must be enabled if IPv6 family addresses are specified for the `servers` property.<br/>

### Learn more
* [`DOC /security/authentication/cluster/nis`](#docs-security-security_authentication_cluster_nis)
*/
func (a *Client) ClusterNisModify(params *ClusterNisModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterNisModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterNisModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cluster_nis_modify",
		Method:             "PATCH",
		PathPattern:        "/security/authentication/cluster/nis",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterNisModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterNisModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterNisModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LoginMessagesCollectionGet Retrieves the login banner and messages of the day (MOTD) configured in the cluster
and in specific SVMs.

### Learn more
* [`DOC /security/login/messages`](#docs-security-security_login_messages)
*/
func (a *Client) LoginMessagesCollectionGet(params *LoginMessagesCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LoginMessagesCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLoginMessagesCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "login_messages_collection_get",
		Method:             "GET",
		PathPattern:        "/security/login/messages",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LoginMessagesCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LoginMessagesCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LoginMessagesCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LoginMessagesGet Retrieves the login messages configuration by UUID.
### Learn more
* [`DOC /security/login/messages`](#docs-security-security_login_messages)
*/
func (a *Client) LoginMessagesGet(params *LoginMessagesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LoginMessagesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLoginMessagesGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "login_messages_get",
		Method:             "GET",
		PathPattern:        "/security/login/messages/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LoginMessagesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LoginMessagesGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LoginMessagesGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LoginMessagesModify Updates the login messages configuration.
There are no required fields. An empty body makes no modifications.

### Learn more
* [`DOC /security/login/messages`](#docs-security-security_login_messages)
*/
func (a *Client) LoginMessagesModify(params *LoginMessagesModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LoginMessagesModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLoginMessagesModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "login_messages_modify",
		Method:             "PATCH",
		PathPattern:        "/security/login/messages/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LoginMessagesModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LoginMessagesModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LoginMessagesModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PublickeyCollectionGet Retrieves the public keys configured for user accounts.
### Learn more
* [`DOC /security/authentication/publickeys`](#docs-security-security_authentication_publickeys)
*/
func (a *Client) PublickeyCollectionGet(params *PublickeyCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublickeyCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "publickey_collection_get",
		Method:             "GET",
		PathPattern:        "/security/authentication/publickeys",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublickeyCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublickeyCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PublickeyCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PublickeyCreate Creates a public key for a user account.
### Learn more
* [`DOC /security/authentication/publickeys`](#docs-security-security_authentication_publickeys)
*/
func (a *Client) PublickeyCreate(params *PublickeyCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublickeyCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "publickey_create",
		Method:             "POST",
		PathPattern:        "/security/authentication/publickeys",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublickeyCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublickeyCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PublickeyCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PublickeyGet Retrieves the public keys configured for a user account.
### Learn more
* [`DOC /security/authentication/publickeys/{owner.uuid}/{account.name}/{index}`](#docs-security-security_authentication_publickeys_{owner.uuid}_{account.name}_{index})
*/
func (a *Client) PublickeyGet(params *PublickeyGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublickeyGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "publickey_get",
		Method:             "GET",
		PathPattern:        "/security/authentication/publickeys/{owner.uuid}/{account.name}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublickeyGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublickeyGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PublickeyGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PublickeyModify Updates the public key for a user account.
### Learn more
* [`DOC /security/authentication/publickeys/{owner.uuid}/{account.name}/{index}`](#docs-security-security_authentication_publickeys_{owner.uuid}_{account.name}_{index})
*/
func (a *Client) PublickeyModify(params *PublickeyModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublickeyModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublickeyModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "publickey_modify",
		Method:             "PATCH",
		PathPattern:        "/security/authentication/publickeys/{owner.uuid}/{account.name}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublickeyModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublickeyModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PublickeyModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RoleCollectionGet Retrieves a list of roles configured in the cluster.
### Related ONTAP commands
* `security login rest-role show`
### Learn more
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RoleCollectionGet(params *RoleCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoleCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_collection_get",
		Method:             "GET",
		PathPattern:        "/security/roles",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RoleCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoleCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RoleCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RoleCreate Creates a new cluster-scoped role or an SVM-scoped role. For an SVM-scoped role, specify either the SVM name as the owner.name or SVM UUID as the owner.uuid in the request body along with other parameters for the role. The owner.uuid or owner.name are not required to be specified for a cluster-scoped role.
### Required parameters
* `name` - Name of the role to be created.
* `privileges` - Array of privilege tuples. Each tuple consists of a REST API path and its desired access level.
### Optional parameters
* `owner.name` or `owner.uuid`  - Name or UUID of the SVM for an SVM-scoped role.
### Related ONTAP commands
* `security login rest-role create`
### Learn more
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RoleCreate(params *RoleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoleCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_create",
		Method:             "POST",
		PathPattern:        "/security/roles",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RoleCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoleCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RoleCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RoleDelete Deletes the specified role.
### Required parameters
* `name` - Name of the role to be deleted.
* `owner.uuid` - UUID of the SVM housing the role.
### Related ONTAP commands
* `security login rest-role delete`
### Learn more
* [`DOC /security/roles/{owner.uuid}/{name}`](#docs-security-security_roles_{owner.uuid}_{name})
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RoleDelete(params *RoleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoleDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_delete",
		Method:             "DELETE",
		PathPattern:        "/security/roles/{owner.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RoleDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoleDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RoleDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RoleGet Retrieves the details of the specified role.
### Related ONTAP commands
* `security login rest-role show`
### Learn more
* [`DOC /security/roles/{owner.uuid}/{name}`](#docs-security-security_roles_{owner.uuid}_{name})
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RoleGet(params *RoleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_get",
		Method:             "GET",
		PathPattern:        "/security/roles/{owner.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RoleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RoleGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RolePrivilegeCollectionGet Retrieves privilege details of the specified role.
### Related ONTAP commands
* `security login rest-role show`
### Learn more
* [`DOC /security/roles/{owner.uuid}/{name}/privileges`](#docs-security-security_roles_{owner.uuid}_{name}_privileges)
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RolePrivilegeCollectionGet(params *RolePrivilegeCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRolePrivilegeCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_privilege_collection_get",
		Method:             "GET",
		PathPattern:        "/security/roles/{owner.uuid}/{name}/privileges",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RolePrivilegeCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RolePrivilegeCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RolePrivilegeCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RolePrivilegeCreate Adds a privilege tuple (of REST URI and its access level) to an existing role.
### Required parameters
* `owner.uuid` - UUID of the SVM that houses this role.
* `name` - Name of the role to be updated.
* `path` - REST URI path (example: "/api/storage/volumes").
* `access` - Desired access level for the REST URI path (one of "all", "readonly" or "none").
### Related ONTAP commands
* `security login rest-role create`
### Learn more
* [`DOC /security/roles/{owner.uuid}/{name}/privileges`](#docs-security-security_roles_{owner.uuid}_{name}_privileges)
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RolePrivilegeCreate(params *RolePrivilegeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRolePrivilegeCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_privilege_create",
		Method:             "POST",
		PathPattern:        "/security/roles/{owner.uuid}/{name}/privileges",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RolePrivilegeCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RolePrivilegeCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RolePrivilegeCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RolePrivilegeDelete Deletes a privilege tuple (of REST URI and its access level) from the role.
### Required parameters
* `owner.uuid` - UUID of the SVM which houses this role.
* `name` - Name of the role to be updated.
* `path` - Constituent REST API path to be deleted from this role.
### Related ONTAP commands
* `security login rest-role delete`
### Learn more
* [`DOC /security/roles/{owner.uuid}/{name}/privileges/{path}`](#docs-security-security_roles_{owner.uuid}_{name}_privileges_{path})
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RolePrivilegeDelete(params *RolePrivilegeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRolePrivilegeDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_privilege_delete",
		Method:             "DELETE",
		PathPattern:        "/security/roles/{owner.uuid}/{name}/privileges/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RolePrivilegeDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RolePrivilegeDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RolePrivilegeDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RolePrivilegeGet Retrieves the privilege level for a REST API path for the specified role.
### Related ONTAP commands
* `security login rest-role show`
### Learn more
* [`DOC /security/roles/{owner.uuid}/{name}/privileges/{path}`](#docs-security-security_roles_{owner.uuid}_{name}_privileges_{path})
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RolePrivilegeGet(params *RolePrivilegeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRolePrivilegeGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_privilege_get",
		Method:             "GET",
		PathPattern:        "/security/roles/{owner.uuid}/{name}/privileges/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RolePrivilegeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RolePrivilegeGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RolePrivilegeGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RolePrivilegeModify Updates the privilege level for a REST API path.
### Required parameters
* `owner.uuid` - UUID of the SVM that houses this role.
* `name` - Name of the role to be updated.
* `path` - Constituent REST API path whose access level has to be updated.
* `access` - Access level for the path (one of "all", "readonly", or "none")
### Related ONTAP commands
* `security login rest-role modify`
### Learn more
* [`DOC /security/roles/{owner.uuid}/{name}/privileges/{path}`](#docs-security-security_roles_{owner.uuid}_{name}_privileges_{path})
* [`DOC /security/roles`](#docs-security-security_roles)

*/
func (a *Client) RolePrivilegeModify(params *RolePrivilegeModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RolePrivilegeModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRolePrivilegeModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "role_privilege_modify",
		Method:             "PATCH",
		PathPattern:        "/security/roles/{owner.uuid}/{name}/privileges/{path}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RolePrivilegeModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RolePrivilegeModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RolePrivilegeModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityAuditGet Retrieves administrative audit settings for GET requests.
### Learn more
* [`DOC /security/audit`](#docs-security-security_audit)
*/
func (a *Client) SecurityAuditGet(params *SecurityAuditGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityAuditGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityAuditGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_audit_get",
		Method:             "GET",
		PathPattern:        "/security/audit",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityAuditGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityAuditGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityAuditGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityAuditLogCollectionGet Retrieves the administrative audit log viewer.
### Learn more
* [`DOC /security/audit/messages`](#docs-security-security_audit_messages)
*/
func (a *Client) SecurityAuditLogCollectionGet(params *SecurityAuditLogCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityAuditLogCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityAuditLogCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_audit_log_collection_get",
		Method:             "GET",
		PathPattern:        "/security/audit/messages",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityAuditLogCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityAuditLogCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityAuditLogCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityAuditModify Updates administrative audit settings for GET requests.
All of the fields are optional. An empty body will make no changes.

### Learn more
* [`DOC /security/audit`](#docs-security-security_audit)
*/
func (a *Client) SecurityAuditModify(params *SecurityAuditModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityAuditModifyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityAuditModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_audit_modify",
		Method:             "PATCH",
		PathPattern:        "/security/audit",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityAuditModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityAuditModifyAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityAuditModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityCertificateCollectionGet Retrieves security certificates.
### Related ONTAP commands
* `security certificate show`

### Learn more
* [`DOC /security/certificates`](#docs-security-security_certificates)
*/
func (a *Client) SecurityCertificateCollectionGet(params *SecurityCertificateCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityCertificateCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_certificate_collection_get",
		Method:             "GET",
		PathPattern:        "/security/certificates",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityCertificateCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityCertificateCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityCertificateCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityCertificateCreate Creates or installs a certificate.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create or install the certificate.
* `common_name` - Common name of the certificate. Required when creating a certificate.
* `type` - Type of certificate.
* `public_certificate` - Public key certificate in PEM format. Required when installing a certificate.
* `private_key` - Private key certificate in PEM format. Required when installing a CA-signed certificate.
### Recommended optional properties
* `expiry_time` - Certificate expiration time. Specifying an expiration time is recommended when creating a certificate.
* `key_size` - Key size of the certificate in bits. Specifying a strong key size is recommended when creating a certificate.
### Default property values
If not specified in POST, the following default property values are assigned:
* `key_size` - _2048_
* `expiry_time` - _P365DT_
* `hash_function` - _sha256_
### Related ONTAP commands
* `security certificate create`
* `security certificate install`

### Learn more
* [`DOC /security/certificates`](#docs-security-security_certificates)
*/
func (a *Client) SecurityCertificateCreate(params *SecurityCertificateCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityCertificateCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_certificate_create",
		Method:             "POST",
		PathPattern:        "/security/certificates",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityCertificateCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityCertificateCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityCertificateCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityCertificateDelete Deletes a security certificate.
### Related ONTAP commands
* `security certificate delete`

### Learn more
* [`DOC /security/certificates`](#docs-security-security_certificates)
*/
func (a *Client) SecurityCertificateDelete(params *SecurityCertificateDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityCertificateDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_certificate_delete",
		Method:             "DELETE",
		PathPattern:        "/security/certificates/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityCertificateDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityCertificateDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityCertificateDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityCertificateGet Retrieves security certificates.
### Related ONTAP commands
* `security certificate show`

### Learn more
* [`DOC /security/certificates`](#docs-security-security_certificates)
*/
func (a *Client) SecurityCertificateGet(params *SecurityCertificateGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityCertificateGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_certificate_get",
		Method:             "GET",
		PathPattern:        "/security/certificates/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityCertificateGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityCertificateGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityCertificateGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityCertificateSign Signs a certificate.
### Required properties
* `signing_request` - Certificate signing request to be signed by the given certificate authority.
### Recommended optional properties
* `expiry_time` - Certificate expiration time. Specifying an expiration time for a signed certificate is recommended.
* `hash_function` - Hashing function. Specifying a strong hashing function is recommended when signing a certificate.
### Default property values
If not specified in POST, the following default property values are assigned:
* `expiry_time` - _P365DT_
* `hash_function` - _sha256_
### Related ONTAP commands
* `security certificate sign`
This API is used to sign a certificate request using a pre-existing self-signed root certificate. The self-signed root certificate acts as a certificate authority within its scope and maintains the records of its signed certificates. <br/>
The root certificate can be created for a given SVM or for the cluster using [`POST security/certificates`].<br/>

*/
func (a *Client) SecurityCertificateSign(params *SecurityCertificateSignParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityCertificateSignOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityCertificateSignParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_certificate_sign",
		Method:             "POST",
		PathPattern:        "/security/certificates/{ca.uuid}/sign",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityCertificateSignReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityCertificateSignOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityCertificateSignDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityConfigGet Retrieves information about the security configured on the cluster.

### Learn more
* [`DOC /security`](#docs-security-security)
*/
func (a *Client) SecurityConfigGet(params *SecurityConfigGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityConfigGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityConfigGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_config_get",
		Method:             "GET",
		PathPattern:        "/security",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityConfigGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityConfigGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityConfigGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerCollectionGet Retrieves key managers.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `connectivity`
* `status.message`
* `status.code`
### Related ONTAP commands
* `security key-manager show-keystore`
* `security key-manager external show`
* `security key-manager external show-status`
* `security key-manager onboard show-backup`

### Learn more
* [`DOC /security/key-managers`](#docs-security-security_key-managers)
*/
func (a *Client) SecurityKeyManagerCollectionGet(params *SecurityKeyManagerCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_collection_get",
		Method:             "GET",
		PathPattern:        "/security/key-managers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerCreate Creates a key manager.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create a key manager.
* `external.client_certificate` - Client certificate. Required only when creating an external key manager.
* `external.server_ca_certificates` - Server CA certificates. Required only when creating an external key manager.
* `external.servers.server` - Key servers. Required only when creating an external key manager.
* `onboard.passphrase` - Cluster-wide passphrase. Required only when creating an Onboard Key Manager.
* `synchronize` - Synchronizes missing onboard keys on any node in the cluster. Required only when creating an Onboard Key Manager at the partner site of a MetroCluster configuration.
### Related ONTAP commands
* `security key-manager external enable`
* `security key-manager onboard enable`
* `security key-manager onboard sync`

### Learn more
* [`DOC /security/key-managers`](#docs-security-security_key-managers)
*/
func (a *Client) SecurityKeyManagerCreate(params *SecurityKeyManagerCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_create",
		Method:             "POST",
		PathPattern:        "/security/key-managers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerDelete Deletes a key manager.
### Related ONTAP commands
* `security key-manager external disable`
* `security key-manager onboard disable`

### Learn more
* [`DOC /security/key-managers`](#docs-security-security_key-managers)
*/
func (a *Client) SecurityKeyManagerDelete(params *SecurityKeyManagerDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_delete",
		Method:             "DELETE",
		PathPattern:        "/security/key-managers/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerGet Retrieves key managers.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `connectivity`
* `status.message`
* `status.code`
### Related ONTAP commands
* `security key-manager show-keystore`
* `security key-manager external show`
* `security key-manager external show-status`
* `security key-manager onboard show-backup`

### Learn more
* [`DOC /security/key-managers`](#docs-security-security_key-managers)
*/
func (a *Client) SecurityKeyManagerGet(params *SecurityKeyManagerGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_get",
		Method:             "GET",
		PathPattern:        "/security/key-managers/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerKeyServersCollectionGet Retrieves the list of key servers configured in an external key manager.
*/
func (a *Client) SecurityKeyManagerKeyServersCollectionGet(params *SecurityKeyManagerKeyServersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerKeyServersCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_key_servers_collection_get",
		Method:             "GET",
		PathPattern:        "/security/key-managers/{uuid}/key-servers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerKeyServersCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerKeyServersCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerKeyServersCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerKeyServersCreate Adds key servers to a configured external key manager.
### Required properties
* `uuid` - UUID of the external key manager.
* `server` - Key server name.
### Related ONTAP commands
* `security key-manager external add-servers`

*/
func (a *Client) SecurityKeyManagerKeyServersCreate(params *SecurityKeyManagerKeyServersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerKeyServersCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_key_servers_create",
		Method:             "POST",
		PathPattern:        "/security/key-managers/{uuid}/key-servers",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerKeyServersCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerKeyServersCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerKeyServersCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerKeyServersDelete Deletes a key server.
### Related ONTAP commands
* `security key-manager external remove-servers`

*/
func (a *Client) SecurityKeyManagerKeyServersDelete(params *SecurityKeyManagerKeyServersDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerKeyServersDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_key_servers_delete",
		Method:             "DELETE",
		PathPattern:        "/security/key-managers/{uuid}/key-servers/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerKeyServersDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerKeyServersDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerKeyServersDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerKeyServersGet Retrieves key servers configured in an external key manager.
### Expensive properties
There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`DOC Requesting specific fields`](#docs-docs-Requesting-specific-fields) to learn more.
* `connectivity`
### Related ONTAP commands
* `security key-manager external show`
* `security key-manager external show-status`

*/
func (a *Client) SecurityKeyManagerKeyServersGet(params *SecurityKeyManagerKeyServersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerKeyServersGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_key_servers_get",
		Method:             "GET",
		PathPattern:        "/security/key-managers/{uuid}/key-servers/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerKeyServersGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerKeyServersGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerKeyServersGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerKeyServersModify Updates a key server.
### Related ONTAP commands
* `security key-manager external modify-server`

*/
func (a *Client) SecurityKeyManagerKeyServersModify(params *SecurityKeyManagerKeyServersModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerKeyServersModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerKeyServersModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_key_servers_modify",
		Method:             "PATCH",
		PathPattern:        "/security/key-managers/{uuid}/key-servers/{server}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerKeyServersModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerKeyServersModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerKeyServersModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerMigrate Migrates the keys belonging to an SVM between the cluster's key manager and the SVM's key manager. This operation can run for several minutes.
### Required properties
* `source.uuid` - UUID of the source key manager.
* `uuid` - UUID of the destination key manager.
### Related ONTAP commands
* `security key-manager migrate`

*/
func (a *Client) SecurityKeyManagerMigrate(params *SecurityKeyManagerMigrateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerMigrateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerMigrateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_migrate",
		Method:             "POST",
		PathPattern:        "/security/key-managers/{source.uuid}/migrate",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerMigrateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerMigrateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerMigrateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityKeyManagerModify Updates a key manager.
### Required properties
* `onboard.existing_passphrase` - Cluster-wide passphrase. Required only when synchronizing the passphrase of the Onboard Key Manager.
* `synchronize` - Synchronizes missing Onboard Key Manager keys on any node in the cluster. Required only when synchronizing the Onboard Key Manager keys in a local cluster.
### Related ONTAP commands
* `security key-manager external modify`
* `security key-manager onboard sync`
* `security key-manager onboard update-passphrase`

### Learn more
* [`DOC /security/key-managers`](#docs-security-security_key-managers)
*/
func (a *Client) SecurityKeyManagerModify(params *SecurityKeyManagerModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityKeyManagerModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityKeyManagerModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_key_manager_modify",
		Method:             "PATCH",
		PathPattern:        "/security/key-managers/{uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityKeyManagerModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityKeyManagerModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityKeyManagerModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityLogForwardingCreate Configures remote syslog/splunk server information.
### Required properties
All of the following fields are required for creating a remote syslog/splunk destination
* `address`
### Optional properties
All of the following fields are optional for creating a remote syslog/splunk destination
* `port`
* `protocol`
* `facility`
* `verify_server` (Can only be "true" when protocol is "tcp_encrypted")

### Learn more
* [`DOC /security/audit/destinations`](#docs-security-security_audit_destinations)
*/
func (a *Client) SecurityLogForwardingCreate(params *SecurityLogForwardingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityLogForwardingCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_log_forwarding_create",
		Method:             "POST",
		PathPattern:        "/security/audit/destinations",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityLogForwardingCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityLogForwardingCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityLogForwardingCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityLogForwardingDelete Deletes remote syslog/splunk server information.
### Learn more
* [`DOC /security/audit/destinations`](#docs-security-security_audit_destinations)
*/
func (a *Client) SecurityLogForwardingDelete(params *SecurityLogForwardingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityLogForwardingDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_log_forwarding_delete",
		Method:             "DELETE",
		PathPattern:        "/security/audit/destinations/{address}/{port}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityLogForwardingDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityLogForwardingDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityLogForwardingDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityLogForwardingGet Defines a remote syslog/splunk server for sending audit information to.
### Learn more
* [`DOC /security/audit/destinations`](#docs-security-security_audit_destinations)
*/
func (a *Client) SecurityLogForwardingGet(params *SecurityLogForwardingGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityLogForwardingGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_log_forwarding_get",
		Method:             "GET",
		PathPattern:        "/security/audit/destinations/{address}/{port}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityLogForwardingGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityLogForwardingGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityLogForwardingGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecurityLogForwardingModify Updates remote syslog/splunk server information.
### Learn more
* [`DOC /security/audit/destinations`](#docs-security-security_audit_destinations)
*/
func (a *Client) SecurityLogForwardingModify(params *SecurityLogForwardingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecurityLogForwardingModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecurityLogForwardingModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_log_forwarding_modify",
		Method:             "PATCH",
		PathPattern:        "/security/audit/destinations/{address}/{port}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecurityLogForwardingModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecurityLogForwardingModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecurityLogForwardingModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecuritySamlSpCreate Creates a SAML service provider configuration. Note that "common_name" is mutually exclusive with "serial_number" and "ca" in POST. SAML will initially be disabled, requiring a patch to set "enabled" to "true", so that the user has time to complete the setup of the IdP.
### Required properties
* `idp_uri`
### Optional properties
* `certificate`
* `enabled`
* `host`

### Learn more
* [`DOC /security/authentication/cluster/saml-sp`](#docs-security-security_authentication_cluster_saml-sp)
*/
func (a *Client) SecuritySamlSpCreate(params *SecuritySamlSpCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpCreateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecuritySamlSpCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_saml_sp_create",
		Method:             "POST",
		PathPattern:        "/security/authentication/cluster/saml-sp",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecuritySamlSpCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecuritySamlSpCreateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecuritySamlSpCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecuritySamlSpDelete Deletes a SAML service provider configuration.
### Learn more
* [`DOC /security/authentication/cluster/saml-sp`](#docs-security-security_authentication_cluster_saml-sp)
*/
func (a *Client) SecuritySamlSpDelete(params *SecuritySamlSpDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecuritySamlSpDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_saml_sp_delete",
		Method:             "DELETE",
		PathPattern:        "/security/authentication/cluster/saml-sp",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecuritySamlSpDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecuritySamlSpDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecuritySamlSpDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecuritySamlSpGet Retrieves a SAML service provider configuration.
### Learn more
* [`DOC /security/authentication/cluster/saml-sp`](#docs-security-security_authentication_cluster_saml-sp)
*/
func (a *Client) SecuritySamlSpGet(params *SecuritySamlSpGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecuritySamlSpGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_saml_sp_get",
		Method:             "GET",
		PathPattern:        "/security/authentication/cluster/saml-sp",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecuritySamlSpGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecuritySamlSpGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecuritySamlSpGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SecuritySamlSpModify Updates a SAML service provider configuration.
### Learn more
* [`DOC /security/authentication/cluster/saml-sp`](#docs-security-security_authentication_cluster_saml-sp)
*/
func (a *Client) SecuritySamlSpModify(params *SecuritySamlSpModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SecuritySamlSpModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSecuritySamlSpModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "security_saml_sp_modify",
		Method:             "PATCH",
		PathPattern:        "/security/authentication/cluster/saml-sp",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SecuritySamlSpModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SecuritySamlSpModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SecuritySamlSpModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SSHGet Retrieves the cluster SSH server ciphers, MAC algorithms, key exchange algorithms, and connection limits.
### Related ONTAP commands
* `security ssh`
* `security protocol ssh`

### Learn more
* [`DOC /security/ssh`](#docs-security-security_ssh)
*/
func (a *Client) SSHGet(params *SSHGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SSHGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSSHGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ssh_get",
		Method:             "GET",
		PathPattern:        "/security/ssh",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SSHGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SSHGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SSHGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SSHModify Updates the SSH server setting for a cluster.
### Optional parameters
* `ciphers` - Encryption algorithms for the payload
* `key_exchange_algorithms` - SSH key exchange algorithms
* `mac_algorithms` - MAC algorithms
* `max_authentication_retry_count` - Maximum authentication retries allowed before closing the connection
* `connections_per_second` - Maximum allowed connections per second
* `max_instances` - Maximum allowed connections per node
* `per_source_limit` - Maximum allowed connections from the same client host
### Related ONTAP commands
* `security ssh`
* `security protocol ssh`

### Learn more
* [`DOC /security/ssh`](#docs-security-security_ssh)
*/
func (a *Client) SSHModify(params *SSHModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SSHModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSSHModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ssh_modify",
		Method:             "PATCH",
		PathPattern:        "/security/ssh",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SSHModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SSHModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SSHModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

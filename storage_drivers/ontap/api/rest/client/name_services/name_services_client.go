// Code generated by go-swagger; DO NOT EDIT.

package name_services

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new name services API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for name services API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DNSCollectionGet(params *DNSCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSCollectionGetOK, error)

	DNSCreate(params *DNSCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSCreateCreated, error)

	DNSDelete(params *DNSDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSDeleteOK, error)

	DNSGet(params *DNSGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSGetOK, error)

	DNSModify(params *DNSModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSModifyOK, error)

	HostRecordGet(params *HostRecordGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HostRecordGetOK, error)

	LdapCollectionGet(params *LdapCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapCollectionGetOK, error)

	LdapCreate(params *LdapCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapCreateCreated, error)

	LdapDelete(params *LdapDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapDeleteOK, error)

	LdapGet(params *LdapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapGetOK, error)

	LdapModify(params *LdapModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapModifyOK, error)

	LocalHostCollectionGet(params *LocalHostCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostCollectionGetOK, error)

	LocalHostCreate(params *LocalHostCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostCreateCreated, error)

	LocalHostDelete(params *LocalHostDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostDeleteOK, error)

	LocalHostGet(params *LocalHostGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostGetOK, error)

	LocalHostModify(params *LocalHostModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostModifyOK, error)

	NameMappingCollectionGet(params *NameMappingCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingCollectionGetOK, error)

	NameMappingCreate(params *NameMappingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingCreateCreated, error)

	NameMappingDelete(params *NameMappingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingDeleteOK, error)

	NameMappingModify(params *NameMappingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingModifyOK, error)

	NameMappingPositionGet(params *NameMappingPositionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingPositionGetOK, error)

	NisCollectionGet(params *NisCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisCollectionGetOK, error)

	NisCreate(params *NisCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisCreateCreated, error)

	NisDelete(params *NisDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisDeleteOK, error)

	NisGet(params *NisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisGetOK, error)

	NisModify(params *NisModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisModifyOK, error)

	UnixGroupCollectionGet(params *UnixGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupCollectionGetOK, error)

	UnixGroupCreate(params *UnixGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupCreateCreated, error)

	UnixGroupDelete(params *UnixGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupDeleteOK, error)

	UnixGroupGet(params *UnixGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupGetOK, error)

	UnixGroupModify(params *UnixGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupModifyOK, error)

	UnixGroupUserDelete(params *UnixGroupUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUserDeleteOK, error)

	UnixGroupUsersCollectionGet(params *UnixGroupUsersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUsersCollectionGetOK, error)

	UnixGroupUsersCreate(params *UnixGroupUsersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUsersCreateCreated, error)

	UnixGroupUsersGet(params *UnixGroupUsersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUsersGetOK, error)

	UnixUserCollectionGet(params *UnixUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserCollectionGetOK, error)

	UnixUserCreate(params *UnixUserCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserCreateCreated, error)

	UnixUserDelete(params *UnixUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserDeleteOK, error)

	UnixUserGet(params *UnixUserGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserGetOK, error)

	UnixUserModify(params *UnixUserModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserModifyOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  DNSCollectionGet Retrieves the DNS configurations of all SVMs.
Specify 'scope' as 'svm' to retrieve the DNS configuration of all the data SVMs.
Specify 'scope' as 'cluster' to retrieve the DNS configuration of the cluster.
### Advanced properties
* 'tld_query_enabled'
* 'source_address_match'
* 'packet_query_match'
* 'status' property retrieves the status of each name server of the DNS configuration for an SVM.
### Related ONTAP commands
* `vserver services name-service dns show`
* `vserver services name-service dns check`
* `vserver services name-service dns dynamic-update show`
### Learn more
* [`DOC /name-services/dns`](#docs-name-services-name-services_dns)

*/
func (a *Client) DNSCollectionGet(params *DNSCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDNSCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dns_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/dns",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DNSCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DNSCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DNSCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DNSCreate Creates DNS domain and server configurations for an SVM.<br/>
### Important notes
- Each SVM can have only one DNS configuration.
- The domain name and the servers fields cannot be empty.
- IPv6 must be enabled if IPv6 family addresses are specified in the `servers` field.
- Configuring more than one DNS server is recommended to avoid a single point of failure.
- The DNS server specified using the `servers` field is validated during this operation.<br/>
</br> The validation fails in the following scenarios:<br/>
1. The server is not a DNS server.
2. The server does not exist.
3. The server is unreachable.<br/>
- The DNS server validation can be skipped by setting the property "skip_config_validation" to "true".
- Scope of the SVM can be specified using the "scope" parameter. "svm" scope refers to data SVMs and "cluster" scope refers to clusters.
#### The following parameters are optional:
- timeout
- attempts
- source_address_match
- packet_query_match
- tld_query_enabled
- skip_config_validation
- scope

*/
func (a *Client) DNSCreate(params *DNSCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDNSCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dns_create",
		Method:             "POST",
		PathPattern:        "/name-services/dns",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DNSCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DNSCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DNSCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DNSDelete Deletes DNS domain configuration of the specified SVM.
### Related ONTAP commands
* `vserver services name-service dns delete`
### Learn more
* [`DOC /name-services/dns`](#docs-name-services-name-services_dns)

*/
func (a *Client) DNSDelete(params *DNSDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDNSDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dns_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/dns/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DNSDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DNSDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DNSDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DNSGet Retrieves DNS domain and server configuration of an SVM. By default, both DNS domains and servers are displayed.
### Advanced properties
* 'tld_query_enabled'
* 'source_address_match'
* 'packet_query_match'
* 'status' property retrieves the status of each name server of the DNS configuration for an SVM.
### Related ONTAP commands
* `vserver services name-service dns show`
* `vserver services name-service dns check`
* `vserver services name-service dns dynamic-update show`
### Learn more
* [`DOC /name-services/dns`](#docs-name-services-name-services_dns)

*/
func (a *Client) DNSGet(params *DNSGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDNSGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dns_get",
		Method:             "GET",
		PathPattern:        "/name-services/dns/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DNSGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DNSGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DNSGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DNSModify Updates DNS domain and server configurations of an SVM.
### Important notes
- Both DNS domains and servers can be modified.
- The domains and servers fields cannot be empty.
- IPv6 must be enabled if IPv6 family addresses are specified for the `servers` field.
- The DNS server specified using the `servers` field is validated during this operation.<br/>
The validation fails in the following scenarios:<br/>
1. The server is not a DNS server.
2. The server does not exist.
3. The server is unreachable.<br/>
- The DNS server validation can be skipped by setting the property "skip_config_validation" to "true".
- Dynamic DNS configuration can be modified.
- If both DNS and Dynamic DNS parameters are modified, DNS parameters are updated first followed by Dynamic DNS parameters.
  If updating Dynamic DNS fails, then the updated DNS configuration is not reverted.
#### The following parameters are optional:
- timeout
- attempts
- source_address_match
- packet_query_match
- tld_query_enabled
- skip_config_validation
- dynamic_dns.enabled
- dynamic_dns.use_secure
- dynamic_dns.time_to_live
### Related ONTAP commands
* `vserver services name-service dns modify`
* `vserver services name-service dns dynamic-update modify`
### Learn more
* [`DOC /name-services/dns`](#docs-name-services-name-services_dns)

*/
func (a *Client) DNSModify(params *DNSModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DNSModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDNSModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dns_modify",
		Method:             "PATCH",
		PathPattern:        "/name-services/dns/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DNSModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DNSModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DNSModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  HostRecordGet Retrieves the IP address of the specified hostname.
### Related ONTAP commands
* `vserver services name-service getxxbyyy getnameinfo`
* `vserver services name-service getxxbyyy getaddrinfo`

*/
func (a *Client) HostRecordGet(params *HostRecordGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HostRecordGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHostRecordGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "host_record_get",
		Method:             "GET",
		PathPattern:        "/name-services/host-record/{svm.uuid}/{host}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &HostRecordGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HostRecordGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*HostRecordGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LdapCollectionGet Retrieves the LDAP configurations for all SVMs.

*/
func (a *Client) LdapCollectionGet(params *LdapCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLdapCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ldap_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/ldap",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LdapCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LdapCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LdapCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LdapCreate Creates an LDAP configuration for an SVM.
### Important notes
* Each SVM can have one LDAP configuration.
* The LDAP servers and Active Directory domain are mutually exclusive fields. These fields cannot be empty. At any point in time, either the LDAP servers or Active Directory domain must be populated.
* LDAP configuration with Active Directory domain cannot be created on an admin SVM.
* IPv6 must be enabled if IPv6 family addresses are specified.</br>
#### The following parameters are optional:
- preferred AD servers
- schema
- port
- ldaps_enabled
- min_bind_level
- bind_password
- base_scope
- use_start_tls
- session_security
- referral_enabled
- bind_as_cifs_server
- query_timeout
- user_dn
- user_scope
- group_dn
- group_scope
- netgroup_dn
- netgroup_scope
- netgroup_byhost_dn
- netgroup_byhost_scope
- is_netgroup_byhost_enabled
- group_membership_filter
- skip_config_validation
- try_channel_binding</br>
Configuring more than one LDAP server is recommended to avoid a single point of failure.
Both FQDNs and IP addresses are supported for the "servers" field.
The Acitve Directory domain or LDAP servers are validated as part of this operation.</br>
LDAP validation fails in the following scenarios:<br/>
1. The server does not have LDAP installed.
2. The server or Active Directory domain is invalid.
3. The server or Active Directory domain is unreachable.<br/>

*/
func (a *Client) LdapCreate(params *LdapCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLdapCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ldap_create",
		Method:             "POST",
		PathPattern:        "/name-services/ldap",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LdapCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LdapCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LdapCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LdapDelete Deletes the LDAP configuration of the specified SVM. LDAP can be removed as a source from the ns-switch if LDAP is not used as a source for lookups.

*/
func (a *Client) LdapDelete(params *LdapDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLdapDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ldap_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/ldap/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LdapDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LdapDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LdapDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LdapGet Retrieves LDAP configuration for an SVM. All parameters for the LDAP configuration are displayed by default.

*/
func (a *Client) LdapGet(params *LdapGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLdapGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ldap_get",
		Method:             "GET",
		PathPattern:        "/name-services/ldap/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LdapGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LdapGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LdapGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LdapModify Updates an LDAP configuration of an SVM.
### Important notes
* Both mandatory and optional parameters of the LDAP configuration can be updated.
* The LDAP servers and Active Directory domain are mutually exclusive fields. These fields cannot be empty. At any point in time, either the LDAP servers or Active Directory domain must be populated.
* IPv6 must be enabled if IPv6 family addresses are specified.<br/>
</br>Configuring more than one LDAP server is recommended to avoid a sinlge point of failure.
Both FQDNs and IP addresses are supported for the "servers" field.
The Active Directory domain or LDAP servers are validated as part of this operation.<br/>
LDAP validation fails in the following scenarios:<br/>
1. The server does not have LDAP installed.
2. The server or Active Directory domain is invalid.
3. The server or Active Directory domain is unreachable<br/>

*/
func (a *Client) LdapModify(params *LdapModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LdapModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLdapModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ldap_modify",
		Method:             "PATCH",
		PathPattern:        "/name-services/ldap/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LdapModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LdapModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LdapModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LocalHostCollectionGet Retrieves all IP to hostname mappings for all SVMs of the cluster.
### Related ONTAP commands
* `vserver services name-service dns hosts show`
### Learn more
* [`DOC /name-services/local-hosts`](#docs-name-services-name-services_local-hosts)

*/
func (a *Client) LocalHostCollectionGet(params *LocalHostCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalHostCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_host_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/local-hosts",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalHostCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalHostCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalHostCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LocalHostCreate Creates a new IP to hostname mapping.
### Required properties
* `owner.uuid` or `owner.name` - Existing SVM in which to create IP to host mapping.
* `address` - IPv4/IPv6 address in dotted form.
* `hostname` - Canonical hostname.
### Related ONTAP commands
* `vserver services name-service dns hosts create`
### Learn more
* [`DOC /name-services/local-hosts`](#docs-name-services-name-services_local-hosts)

*/
func (a *Client) LocalHostCreate(params *LocalHostCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalHostCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_host_create",
		Method:             "POST",
		PathPattern:        "/name-services/local-hosts",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalHostCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalHostCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalHostCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LocalHostDelete Deletes an existing host object.
### Related ONTAP commands
* `vserver services name-service dns hosts delete`
### Learn more
* [`DOC /name-services/local-hosts`](#docs-name-services-name-services_local-hosts)

*/
func (a *Client) LocalHostDelete(params *LocalHostDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalHostDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_host_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/local-hosts/{owner.uuid}/{address}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalHostDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalHostDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalHostDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LocalHostGet For a specified SVM and IP address, returns the corresponding IP to hostname mapping.
### Related ONTAP commands
* `vserver services name-service dns hosts show`
### Learn more
* [`DOC /name-services/local-hosts`](#docs-name-services-name-services_local-hosts)

*/
func (a *Client) LocalHostGet(params *LocalHostGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalHostGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_host_get",
		Method:             "GET",
		PathPattern:        "/name-services/local-hosts/{owner.uuid}/{address}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalHostGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalHostGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalHostGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  LocalHostModify For a specified SVM and IP address, modifies the corresponding IP to hostname mapping.
### Related ONTAP commands
* `vserver services name-service dns hosts modify`
### Learn more
* [`DOC /name-services/local-hosts`](#docs-name-services-name-services_local-hosts)

*/
func (a *Client) LocalHostModify(params *LocalHostModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*LocalHostModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLocalHostModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "local_host_modify",
		Method:             "PATCH",
		PathPattern:        "/name-services/local-hosts/{owner.uuid}/{address}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LocalHostModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LocalHostModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LocalHostModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NameMappingCollectionGet Retrieves the name mapping configuration for all SVMs.
### Related ONTAP commands
* `vserver name-mapping show`
### Learn more
* [`DOC /name-services/name-mappings`](#docs-name-services-name-services_name-mappings)

*/
func (a *Client) NameMappingCollectionGet(params *NameMappingCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNameMappingCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "name_mapping_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/name-mappings",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NameMappingCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NameMappingCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NameMappingCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NameMappingCreate Creates name mappings for an SVM.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the name mapping.
* `index` - Name mapping's position in the priority list.
* `direction` - Direction of the name mapping.
* `pattern` - Pattern to match to. Maximum length is 256 characters.
* `replacement` - Replacement pattern to match to. Maximum length is 256 characters.
### Recommended optional properties
* `client_match` - Hostname or IP address added to match the pattern to the client's workstation IP address.
### Related ONTAP commands
* `vserver name-mapping create`
* `vserver name-mapping insert`
### Learn more
* [`DOC /name-services/name-mappings`](#docs-name-services-name-services_name-mappings)

*/
func (a *Client) NameMappingCreate(params *NameMappingCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNameMappingCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "name_mapping_create",
		Method:             "POST",
		PathPattern:        "/name-services/name-mappings",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NameMappingCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NameMappingCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NameMappingCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NameMappingDelete Deletes the name mapping configuration.
### Related ONTAP commands
* `vserver name-mapping delete`
### Learn more
* [`DOC /name-services/name-mappings`](#docs-name-services-name-services_name-mappings)

*/
func (a *Client) NameMappingDelete(params *NameMappingDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNameMappingDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "name_mapping_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/name-mappings/{svm.uuid}/{direction}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NameMappingDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NameMappingDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NameMappingDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NameMappingModify Updates the name mapping configuration of an SVM. The positions can be swapped by providing the `new_index` property.
Swapping is not allowed for entries that have `client_match` property configured.
### Related ONTAP commands
* `vserver name-mapping insert`
* `vserver name-mapping modify`
* `vserver name-mapping swap`
### Learn more
* [`DOC /name-services/name-mappings`](#docs-name-services-name-services_name-mappings)

*/
func (a *Client) NameMappingModify(params *NameMappingModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNameMappingModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "name_mapping_modify",
		Method:             "PATCH",
		PathPattern:        "/name-services/name-mappings/{svm.uuid}/{direction}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NameMappingModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NameMappingModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NameMappingModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NameMappingPositionGet Retrieves the name mapping configuration of an SVM.
### Related ONTAP commands
* `vserver name-mapping show`
### Learn more
* [`DOC /name-services/name-mappings`](#docs-name-services-name-services_name-mappings)

*/
func (a *Client) NameMappingPositionGet(params *NameMappingPositionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NameMappingPositionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNameMappingPositionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "name_mapping_position_get",
		Method:             "GET",
		PathPattern:        "/name-services/name-mappings/{svm.uuid}/{direction}/{index}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NameMappingPositionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NameMappingPositionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NameMappingPositionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NisCollectionGet Retrieves NIS domain configurations of all the SVMs. The bound_servers field indicates the successfully bound NIS servers. Lookups and authentications fail if there are no bound servers.
### Related ONTAP commands
* `vserver services name-service nis-domain show`
* `vserver services name-service nis-domain show-bound`
### Learn more
* [`DOC /name-services/nis`](#docs-name-services-name-services_nis)

*/
func (a *Client) NisCollectionGet(params *NisCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNisCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nis_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/nis",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NisCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NisCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NisCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NisCreate Creates an NIS domain and server confguration for a data SVM.
NIS configuration for the cluster is managed via [`/api/security/authentication/cluster/nis`](#docs-security-security_authentication_cluster_nis).<br/>
### Important notes
  - Each SVM can have one NIS domain configuration.
  - Multiple SVMs can be configured with the same NIS domain. Specify the NIS domain and NIS servers as input.Domain name and servers fields cannot be empty.
  - Both FQDNs and IP addresses are supported for the servers field.
  - IPv6 must be enabled if IPv6 family addresses are specified in the servers field.
  - A maximum of ten NIS servers are supported.
### Required properties
* `svm.uuid` or `svm.name` - Existing SVM in which to create the NIS configuration.
* `domain` - NIS domain to which the configuration belongs.
* `servers` - List of NIS server IP addresses.
### Related ONTAP commands
* `vserver services name-service nis-domain create`
### Learn more
* [`DOC /name-services/nis`](#docs-name-services-name-services_nis)

*/
func (a *Client) NisCreate(params *NisCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNisCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nis_create",
		Method:             "POST",
		PathPattern:        "/name-services/nis",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NisCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NisCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NisCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NisDelete Deletes the NIS domain configuration of an SVM. NIS can be removed as a source from ns-switch if NIS is not used for lookups.
### Related ONTAP commands
* `vserver services name-service nis-domain delete`
### Learn more
* [`DOC /name-services/nis`](#docs-name-services-name-services_nis)

*/
func (a *Client) NisDelete(params *NisDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNisDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nis_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/nis/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NisDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NisDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NisDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NisGet Retrieves NIS domain and server configurations of an SVM. Both NIS domain and servers are displayed by default. The bound_servers field indicates the successfully bound NIS servers.
### Related ONTAP commands
* `vserver services name-service nis-domain show`
* `vserver services name-service nis-domain show-bound`
### Learn more
* [`DOC /name-services/nis`](#docs-name-services-name-services_nis)

*/
func (a *Client) NisGet(params *NisGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNisGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nis_get",
		Method:             "GET",
		PathPattern:        "/name-services/nis/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NisGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NisGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NisGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NisModify Updates NIS domain and server configuration of an SVM.<br/>
### Important notes
  - Both NIS domain and servers can be modified.
  - Domains and servers cannot be empty.
  - Both FQDNs and IP addresses are supported for the servers field.
  - If the domain is modified, NIS servers must also be specified.
  - IPv6 must be enabled if IPv6 family addresses are specified for the servers field.
### Related ONTAP commands
* `vserver services name-service nis-domain modify`
### Learn more
* [`DOC /name-services/nis`](#docs-name-services-name-services_nis)

*/
func (a *Client) NisModify(params *NisModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NisModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNisModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "nis_modify",
		Method:             "PATCH",
		PathPattern:        "/name-services/nis/{svm.uuid}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NisModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NisModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NisModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupCollectionGet Retrieves the UNIX groups for all of the SVMs. UNIX users who are the members of the group are also displayed.
### Related ONTAP commands
* `vserver services name-service unix-group show`
### Learn more
* [`DOC /name-services/unix-groups`](#docs-name-services-name-services_unix-groups)

*/
func (a *Client) UnixGroupCollectionGet(params *UnixGroupCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/unix-groups",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupCreate Creates the local UNIX group configuration for the specified SVM.<br/>
Group name and group ID are mandatory parameters.
### Learn more
* [`DOC /name-services/unix-groups`](#docs-name-services-name-services_unix-groups)

*/
func (a *Client) UnixGroupCreate(params *UnixGroupCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_create",
		Method:             "POST",
		PathPattern:        "/name-services/unix-groups",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupDelete Deletes a UNIX group configuration for the specified SVM.
### Related ONTAP commands
* `vserver services name-service unix-group delete`
### Learn more
* [`DOC /name-services/unix-groups`](#docs-name-services-name-services_unix-groups)

*/
func (a *Client) UnixGroupDelete(params *UnixGroupDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/unix-groups/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupGet Retrieves UNIX group information for the specified group and SVM. UNIX users who are part of this group
are also retrieved.
### Related ONTAP commands
* `vserver services name-service unix-group show`
### Learn more
* [`DOC /name-services/unix-groups`](#docs-name-services-name-services_unix-groups)

*/
func (a *Client) UnixGroupGet(params *UnixGroupGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_get",
		Method:             "GET",
		PathPattern:        "/name-services/unix-groups/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupModify Updates the UNIX group information of the specified group in the specified SVM.
### Learn more
* [`DOC /name-services/unix-groups`](#docs-name-services-name-services_unix-groups)

*/
func (a *Client) UnixGroupModify(params *UnixGroupModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_modify",
		Method:             "PATCH",
		PathPattern:        "/name-services/unix-groups/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupUserDelete Deletes a user from the specified UNIX group.
### Related ONTAP commands
* `vserver services name-service unix-group deluser`

*/
func (a *Client) UnixGroupUserDelete(params *UnixGroupUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUserDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupUserDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_user_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/unix-groups/{svm.uuid}/{unix_group.name}/users/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupUserDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupUserDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupUserDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupUsersCollectionGet Retrieves users for the specified UNIX group and SVM.
### Related ONTAP commands
* `vserver services name-service unix-group show`

*/
func (a *Client) UnixGroupUsersCollectionGet(params *UnixGroupUsersCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUsersCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupUsersCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_users_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/unix-groups/{svm.uuid}/{unix_group.name}/users",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupUsersCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupUsersCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupUsersCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupUsersCreate Adds users to the specified UNIX group and SVM.
### Important notes
- Multiple users can be added in a single call using the "records" parameter.
- "records" parameter must not be specified when "name" parameter is specified.
- Specified users are appended to the existing list of users.
- Duplicate users are ignored.
### Related ONTAP commands
* `vserver services name-service unix-group adduser`
* `vserver services name-service unix-group addusers`

*/
func (a *Client) UnixGroupUsersCreate(params *UnixGroupUsersCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUsersCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupUsersCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_users_create",
		Method:             "POST",
		PathPattern:        "/name-services/unix-groups/{svm.uuid}/{unix_group.name}/users",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupUsersCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupUsersCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupUsersCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixGroupUsersGet Retrieves users for the specified UNIX group and SVM.
### Related ONTAP commands
* `vserver services name-service unix-group show`

*/
func (a *Client) UnixGroupUsersGet(params *UnixGroupUsersGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixGroupUsersGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixGroupUsersGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_group_users_get",
		Method:             "GET",
		PathPattern:        "/name-services/unix-groups/{svm.uuid}/{unix_group.name}/users/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixGroupUsersGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixGroupUsersGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixGroupUsersGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixUserCollectionGet Retrieves all of the UNIX users for all of the SVMs.
### Related ONTAP commands
* `vserver services name-service unix-user show`

*/
func (a *Client) UnixUserCollectionGet(params *UnixUserCollectionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserCollectionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixUserCollectionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_user_collection_get",
		Method:             "GET",
		PathPattern:        "/name-services/unix-users",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixUserCollectionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixUserCollectionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixUserCollectionGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixUserCreate Creates the local UNIX user configuration for an SVM.<br/>

*/
func (a *Client) UnixUserCreate(params *UnixUserCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixUserCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_user_create",
		Method:             "POST",
		PathPattern:        "/name-services/unix-users",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixUserCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixUserCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixUserCreateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixUserDelete Deletes a UNIX user configuration for the specified SVM.
### Related ONTAP commands
* `vserver services name-service unix-user delete`

*/
func (a *Client) UnixUserDelete(params *UnixUserDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixUserDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_user_delete",
		Method:             "DELETE",
		PathPattern:        "/name-services/unix-users/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixUserDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixUserDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixUserDeleteDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixUserGet Retrieves UNIX user information for the specified user and SVM.
### Related ONTAP commands
* `vserver services name-service unix-user show`

*/
func (a *Client) UnixUserGet(params *UnixUserGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixUserGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_user_get",
		Method:             "GET",
		PathPattern:        "/name-services/unix-users/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixUserGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixUserGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixUserGetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnixUserModify Updates UNIX user information for the specified user and SVM.

*/
func (a *Client) UnixUserModify(params *UnixUserModifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnixUserModifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnixUserModifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "unix_user_modify",
		Method:             "PATCH",
		PathPattern:        "/name-services/unix-users/{svm.uuid}/{name}",
		ProducesMediaTypes: []string{"application/hal+json", "application/json"},
		ConsumesMediaTypes: []string{"application/hal+json", "application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnixUserModifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnixUserModifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnixUserModifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

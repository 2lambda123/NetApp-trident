package docker

import (
	"fmt"

	log "github.com/Sirupsen/logrus"
	hash "github.com/mitchellh/hashstructure"
	dvp_utils "github.com/netapp/netappdvp/utils"

	"github.com/netapp/trident/config"
	"github.com/netapp/trident/core"
	"github.com/netapp/trident/storage"
	"github.com/netapp/trident/storage_attribute"
	"github.com/netapp/trident/storage_class"
)

// getStorageClass accepts a list of volume creation options and returns a
// matching storage class.  If the orchestrator already has a matching
// storage class, that is returned; otherwise a new one is created and
// registered with the orchestrator.
func getStorageClass(options map[string]string, o core.Orchestrator) (*storage_class.Config, error) {

	// Create a storage class based on available options
	newScConfig, err := makeStorageClass(options)
	if err != nil {
		return nil, err
	}

	// Check existing storage classes for a match based on the name
	sc := o.GetStorageClass(newScConfig.Name)
	if sc != nil {
		log.WithField("storageClass", sc.Config.Name).Debug("Matched existing storage class.")
		return sc.Config, nil
	}

	// No match found, so register the new storage class
	addedSc, err := o.AddStorageClass(newScConfig)
	if err != nil {
		log.WithFields(log.Fields{
			"storageClass": addedSc.Config.Name,
		}).Error("Docker frontend couldn't add the storage class: ", err)
		return nil, err
	}

	return addedSc.Config, nil
}

// makeStorageClass accepts a list of volume creation options and creates a
// matching storage class.  The name of the new storage class contains a hash
// of the attributes it contains, thereby enabling comparison of storage
// classes generated by this method by simply comparing their names.
func makeStorageClass(options map[string]string) (*storage_class.Config, error) {

	scConfig := new(storage_class.Config)

	// Populate storage class config attributes
	scConfig.Attributes = make(map[string]storage_attribute.Request)
	for k, v := range options {
		// format: attribute: "type:value"
		req, err := storage_attribute.CreateAttributeRequestFromTypedValue(k, v)
		if err != nil {
			log.WithFields(log.Fields{
				"storageClass":            scConfig.Name,
				"storageClass_parameters": options,
			}).Debug("Docker frontend ignoring storage class attribute: ", err)
			continue
		}
		scConfig.Attributes[k] = req
	}

	// Set name based on hash value
	scHash, err := hash.Hash(scConfig.Attributes, nil)
	if err != nil {
		log.WithFields(log.Fields{
			"storageClass":            scConfig.Name,
			"storageClass_parameters": options,
		}).Error("Docker frontend couldn't hash the storage class attributes: ", err)
		return nil, err
	}
	scConfig.Name = fmt.Sprintf(auto_storage_class_prefix, scHash)

	return scConfig, nil
}

// getVolumeConfig accepts a set of parameters describing a volume creation request
// and returns a volume config structure suitable for passing to the orchestrator core.
func getVolumeConfig(name, storageClass string, opts map[string]string) (*storage.VolumeConfig, error) {

	sizeBytes, err := dvp_utils.GetVolumeSizeBytes(opts, default_volume_size)
	if err != nil {
		return nil, fmt.Errorf("Error creating volume: %v", err)
	}

	return &storage.VolumeConfig{
		Name:            name,
		Size:            fmt.Sprintf("%d", sizeBytes),
		Protocol:        config.ProtocolAny,
		SnapshotPolicy:  dvp_utils.GetV(opts, "snapshotPolicy", ""),
		ExportPolicy:    dvp_utils.GetV(opts, "exportPolicy", ""),
		SnapshotDir:     dvp_utils.GetV(opts, "snapshotDir", ""),
		UnixPermissions: dvp_utils.GetV(opts, "unixPermissions", ""),
		StorageClass:    storageClass,
		BlockSize:       dvp_utils.GetV(opts, "blocksize", ""),
		FileSystem:      "",
		AccessMode:      config.ModeAny,
	}, nil
}
